package middleware

import (
	"backend/config"
	"backend/utils/database"
	"backend/utils/errhandle"
	"backend/utils/jwt"
	"fmt"
	"net/http"
	"time"
)

func Authenticate(next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		db := database.GetDb()
		now := time.Now()

		accessToken, refreshToken, e := getRefAccFromRequest(r)
		if e.Handle(w, r) {
			return
		}

		if !jwt.WasGeneratedWithSecret(refreshToken, config.JwtSecret) || !jwt.WasGeneratedWithSecret(accessToken, config.JwtSecret) {
			e := errhandle.Error{
				Type:          errhandle.JwtError,
				ServerMessage: "one of the tokens or both weren't created with the server secret",
				ClientMessage: "Your authentication medium wasn't generated by this server.",
				Status:        http.StatusUnauthorized,
			}
			e.Handle(w, r)
			return
		}

		claimsRefresh, e := jwt.DecodePayload(refreshToken)
		if e.Handle(w, r) {
			return
		}

		claimsAccess, e := jwt.DecodePayload(accessToken)
		if e.Handle(w, r) {
			return
		}

		/* Check whether the refresh token has expired. If it has, delete the cookies and reply with 401.*/
		expiresRefresh := int64(claimsRefresh["exp"].(float64))
		if expiresRefresh < now.Unix() {
			e := db.DeleteRefreshTokenByToken(refreshToken)
			if e.Handle(w, r) {
				return
			}

			http.SetCookie(w, &http.Cookie{
				Name:     "refresh_token",
				Value:    "",
				HttpOnly: true,
				Path:     "/",
				Expires:  time.Unix(0, 0),
			})

			http.SetCookie(w, &http.Cookie{
				Name:     "access_token",
				Value:    "",
				HttpOnly: true,
				Path:     "/",
				Expires:  time.Unix(0, 0),
			})

			w.WriteHeader(http.StatusUnauthorized)
			return
		}

		/* Check whether refresh token is assigned to the right person (db). */
		userId := claimsRefresh["user"].(string)
		tk, e := db.GetRefreshTokenByUserId(userId)
		if e.Handle(w, r) {
			return
		}

		if tk.UserId != userId {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}

		/* Check whether the access token has expired, if it has, issue another one. */
		expiresAccess := int64(claimsAccess["exp"].(float64))
		if expiresAccess < now.Unix() {
			user, e := db.GetUserById(claimsAccess["user"].(string))
			if e.Handle(w, r) {
				return
			}

			access, e := jwt.GenerateAccessToken(user.Id, now)
			if e.Handle(w, r) {
				return
			}

			http.SetCookie(w, &http.Cookie{
				Name:     "access_token",
				Value:    access,
				HttpOnly: true,
				Path:     "/",
				Expires:  now.Add(time.Duration(config.JwtAccExpTime)),
			})
		}

		next(w, r)
	}
}

func Method(method string, next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != method {
			w.WriteHeader(http.StatusMethodNotAllowed)
			return
		}

		next(w, r)
	}
}

func getRefAccFromRequest(r *http.Request) (string, string, *errhandle.Error) {
	access, err := r.Cookie("access_token")
	if err == http.ErrNoCookie {
		return "", "", &errhandle.Error{
			Type:          errhandle.JwtError,
			ServerMessage: "no access_token cookie present",
			ClientMessage: "There was no authentication medium present in the request.",
			Status:        http.StatusUnauthorized,
		}
	} else if err != nil {
		return "", "", &errhandle.Error{
			Type:          errhandle.JwtError,
			ServerMessage: fmt.Sprintf("while trying to retrieve the access_token cookie -> %v", err),
			ClientMessage: "An error has occurred while processing your request.",
			Status:        http.StatusInternalServerError,
		}
	}

	refresh, err := r.Cookie("refresh_token")
	if err == http.ErrNoCookie {
		return "", "", &errhandle.Error{
			Type:          errhandle.JwtError,
			ServerMessage: "no refresh_token cookie present",
			ClientMessage: "There was no authentication medium present in the request.",
			Status:        http.StatusUnauthorized,
		}
	} else if err != nil {
		return "", "", &errhandle.Error{
			Type:          errhandle.JwtError,
			ServerMessage: fmt.Sprintf("while trying to retrieve the refresh_token cookie -> %v", err),
			ClientMessage: "An error has occurred while processing your request.",
			Status:        http.StatusInternalServerError,
		}
	}

	return access.Value, refresh.Value, nil
}
