<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>tls - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="../../../lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="../../../lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.22.2";</script>
<script src="../../../lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="../../../index.html">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="../../../index.html">GoDoc</a></div>
<a href="index.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:8080/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package tls
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "crypto/tls"</code></dd>
			</dl>
			<dl>
			<dd><a href="index.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="index.html#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="index.html#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
				<dd><a href="index.html#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package tls partially implements TLS 1.2, as specified in RFC 5246,
and TLS 1.3, as specified in RFC 8446.

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="index.html#pkg-constants">Constants</a></dd>
			
			
			
				
				<dd><a href="index.html#CipherSuiteName">func CipherSuiteName(id uint16) string</a></dd>
			
				
				<dd><a href="index.html#Listen">func Listen(network, laddr string, config *Config) (net.Listener, error)</a></dd>
			
				
				<dd><a href="index.html#NewListener">func NewListener(inner net.Listener, config *Config) net.Listener</a></dd>
			
				
				<dd><a href="index.html#VersionName">func VersionName(version uint16) string</a></dd>
			
			
				
				<dd><a href="index.html#AlertError">type AlertError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#AlertError.Error">func (e AlertError) Error() string</a></dd>
				
			
				
				<dd><a href="index.html#Certificate">type Certificate</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#LoadX509KeyPair">func LoadX509KeyPair(certFile, keyFile string) (Certificate, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#X509KeyPair">func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (Certificate, error)</a></dd>
				
				
			
				
				<dd><a href="index.html#CertificateRequestInfo">type CertificateRequestInfo</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#CertificateRequestInfo.Context">func (c *CertificateRequestInfo) Context() context.Context</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#CertificateRequestInfo.SupportsCertificate">func (cri *CertificateRequestInfo) SupportsCertificate(c *Certificate) error</a></dd>
				
			
				
				<dd><a href="index.html#CertificateVerificationError">type CertificateVerificationError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#CertificateVerificationError.Error">func (e *CertificateVerificationError) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#CertificateVerificationError.Unwrap">func (e *CertificateVerificationError) Unwrap() error</a></dd>
				
			
				
				<dd><a href="index.html#CipherSuite">type CipherSuite</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#CipherSuites">func CipherSuites() []*CipherSuite</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#InsecureCipherSuites">func InsecureCipherSuites() []*CipherSuite</a></dd>
				
				
			
				
				<dd><a href="index.html#ClientAuthType">type ClientAuthType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ClientAuthType.String">func (i ClientAuthType) String() string</a></dd>
				
			
				
				<dd><a href="index.html#ClientHelloInfo">type ClientHelloInfo</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ClientHelloInfo.Context">func (c *ClientHelloInfo) Context() context.Context</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ClientHelloInfo.SupportsCertificate">func (chi *ClientHelloInfo) SupportsCertificate(c *Certificate) error</a></dd>
				
			
				
				<dd><a href="index.html#ClientSessionCache">type ClientSessionCache</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewLRUClientSessionCache">func NewLRUClientSessionCache(capacity int) ClientSessionCache</a></dd>
				
				
			
				
				<dd><a href="index.html#ClientSessionState">type ClientSessionState</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewResumptionState">func NewResumptionState(ticket []byte, state *SessionState) (*ClientSessionState, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ClientSessionState.ResumptionState">func (cs *ClientSessionState) ResumptionState() (ticket []byte, state *SessionState, err error)</a></dd>
				
			
				
				<dd><a href="index.html#Config">type Config</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Config.BuildNameToCertificate">func (c *Config) BuildNameToCertificate()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Config.Clone">func (c *Config) Clone() *Config</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Config.DecryptTicket">func (c *Config) DecryptTicket(identity []byte, cs ConnectionState) (*SessionState, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Config.EncryptTicket">func (c *Config) EncryptTicket(cs ConnectionState, ss *SessionState) ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Config.SetSessionTicketKeys">func (c *Config) SetSessionTicketKeys(keys [][32]byte)</a></dd>
				
			
				
				<dd><a href="index.html#Conn">type Conn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Client">func Client(conn net.Conn, config *Config) *Conn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Dial">func Dial(network, addr string, config *Config) (*Conn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#DialWithDialer">func DialWithDialer(dialer *net.Dialer, network, addr string, config *Config) (*Conn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Server">func Server(conn net.Conn, config *Config) *Conn</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Conn.Close">func (c *Conn) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Conn.CloseWrite">func (c *Conn) CloseWrite() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Conn.ConnectionState">func (c *Conn) ConnectionState() ConnectionState</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Conn.Handshake">func (c *Conn) Handshake() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Conn.HandshakeContext">func (c *Conn) HandshakeContext(ctx context.Context) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Conn.LocalAddr">func (c *Conn) LocalAddr() net.Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Conn.NetConn">func (c *Conn) NetConn() net.Conn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Conn.OCSPResponse">func (c *Conn) OCSPResponse() []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Conn.Read">func (c *Conn) Read(b []byte) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Conn.RemoteAddr">func (c *Conn) RemoteAddr() net.Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Conn.SetDeadline">func (c *Conn) SetDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Conn.SetReadDeadline">func (c *Conn) SetReadDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Conn.SetWriteDeadline">func (c *Conn) SetWriteDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Conn.VerifyHostname">func (c *Conn) VerifyHostname(host string) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Conn.Write">func (c *Conn) Write(b []byte) (int, error)</a></dd>
				
			
				
				<dd><a href="index.html#ConnectionState">type ConnectionState</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ConnectionState.ExportKeyingMaterial">func (cs *ConnectionState) ExportKeyingMaterial(label string, context []byte, length int) ([]byte, error)</a></dd>
				
			
				
				<dd><a href="index.html#CurveID">type CurveID</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#CurveID.String">func (i CurveID) String() string</a></dd>
				
			
				
				<dd><a href="index.html#Dialer">type Dialer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Dialer.Dial">func (d *Dialer) Dial(network, addr string) (net.Conn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Dialer.DialContext">func (d *Dialer) DialContext(ctx context.Context, network, addr string) (net.Conn, error)</a></dd>
				
			
				
				<dd><a href="index.html#QUICConfig">type QUICConfig</a></dd>
				
				
			
				
				<dd><a href="index.html#QUICConn">type QUICConn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#QUICClient">func QUICClient(config *QUICConfig) *QUICConn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#QUICServer">func QUICServer(config *QUICConfig) *QUICConn</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#QUICConn.Close">func (q *QUICConn) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#QUICConn.ConnectionState">func (q *QUICConn) ConnectionState() ConnectionState</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#QUICConn.HandleData">func (q *QUICConn) HandleData(level QUICEncryptionLevel, data []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#QUICConn.NextEvent">func (q *QUICConn) NextEvent() QUICEvent</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#QUICConn.SendSessionTicket">func (q *QUICConn) SendSessionTicket(opts QUICSessionTicketOptions) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#QUICConn.SetTransportParameters">func (q *QUICConn) SetTransportParameters(params []byte)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#QUICConn.Start">func (q *QUICConn) Start(ctx context.Context) error</a></dd>
				
			
				
				<dd><a href="index.html#QUICEncryptionLevel">type QUICEncryptionLevel</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#QUICEncryptionLevel.String">func (l QUICEncryptionLevel) String() string</a></dd>
				
			
				
				<dd><a href="index.html#QUICEvent">type QUICEvent</a></dd>
				
				
			
				
				<dd><a href="index.html#QUICEventKind">type QUICEventKind</a></dd>
				
				
			
				
				<dd><a href="index.html#QUICSessionTicketOptions">type QUICSessionTicketOptions</a></dd>
				
				
			
				
				<dd><a href="index.html#RecordHeaderError">type RecordHeaderError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RecordHeaderError.Error">func (e RecordHeaderError) Error() string</a></dd>
				
			
				
				<dd><a href="index.html#RenegotiationSupport">type RenegotiationSupport</a></dd>
				
				
			
				
				<dd><a href="index.html#SessionState">type SessionState</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ParseSessionState">func ParseSessionState(data []byte) (*SessionState, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#SessionState.Bytes">func (s *SessionState) Bytes() ([]byte, error)</a></dd>
				
			
				
				<dd><a href="index.html#SignatureScheme">type SignatureScheme</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#SignatureScheme.String">func (i SignatureScheme) String() string</a></dd>
				
			
			
				
				<dd><a href="index.html#pkg-note-BUG">Bugs</a></dd>
				
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="index.html#example_Config_keyLogWriter">Config (KeyLogWriter)</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Config_verifyConnection">Config (VerifyConnection)</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Dial">Dial</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_LoadX509KeyPair">LoadX509KeyPair</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_X509KeyPair">X509KeyPair</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_X509KeyPair_httpServer">X509KeyPair (HttpServer)</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="../../../src/crypto/tls/alert.go">alert.go</a>
			
				<a href="../../../src/crypto/tls/auth.go">auth.go</a>
			
				<a href="../../../src/crypto/tls/cache.go">cache.go</a>
			
				<a href="../../../src/crypto/tls/cipher_suites.go">cipher_suites.go</a>
			
				<a href="../../../src/crypto/tls/common.go">common.go</a>
			
				<a href="../../../src/crypto/tls/common_string.go">common_string.go</a>
			
				<a href="../../../src/crypto/tls/conn.go">conn.go</a>
			
				<a href="../../../src/crypto/tls/handshake_client.go">handshake_client.go</a>
			
				<a href="../../../src/crypto/tls/handshake_client_tls13.go">handshake_client_tls13.go</a>
			
				<a href="../../../src/crypto/tls/handshake_messages.go">handshake_messages.go</a>
			
				<a href="../../../src/crypto/tls/handshake_server.go">handshake_server.go</a>
			
				<a href="../../../src/crypto/tls/handshake_server_tls13.go">handshake_server_tls13.go</a>
			
				<a href="../../../src/crypto/tls/key_agreement.go">key_agreement.go</a>
			
				<a href="../../../src/crypto/tls/key_schedule.go">key_schedule.go</a>
			
				<a href="../../../src/crypto/tls/notboring.go">notboring.go</a>
			
				<a href="../../../src/crypto/tls/prf.go">prf.go</a>
			
				<a href="../../../src/crypto/tls/quic.go">quic.go</a>
			
				<a href="../../../src/crypto/tls/ticket.go">ticket.go</a>
			
				<a href="../../../src/crypto/tls/tls.go">tls.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
			<h2 id="pkg-constants">Constants</h2>
			
				<p>A list of cipher suite IDs that are, or have been, implemented by this
package.
<p>See <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xml">https://www.iana.org/assignments/tls-parameters/tls-parameters.xml</a>

				<pre>const (
    <span class="comment">// TLS 1.0 - 1.2 cipher suites.</span>
    <span id="TLS_RSA_WITH_RC4_128_SHA">TLS_RSA_WITH_RC4_128_SHA</span>                      <a href="../../builtin/index.html#uint16">uint16</a> = 0x0005
    <span id="TLS_RSA_WITH_3DES_EDE_CBC_SHA">TLS_RSA_WITH_3DES_EDE_CBC_SHA</span>                 <a href="../../builtin/index.html#uint16">uint16</a> = 0x000a
    <span id="TLS_RSA_WITH_AES_128_CBC_SHA">TLS_RSA_WITH_AES_128_CBC_SHA</span>                  <a href="../../builtin/index.html#uint16">uint16</a> = 0x002f
    <span id="TLS_RSA_WITH_AES_256_CBC_SHA">TLS_RSA_WITH_AES_256_CBC_SHA</span>                  <a href="../../builtin/index.html#uint16">uint16</a> = 0x0035
    <span id="TLS_RSA_WITH_AES_128_CBC_SHA256">TLS_RSA_WITH_AES_128_CBC_SHA256</span>               <a href="../../builtin/index.html#uint16">uint16</a> = 0x003c
    <span id="TLS_RSA_WITH_AES_128_GCM_SHA256">TLS_RSA_WITH_AES_128_GCM_SHA256</span>               <a href="../../builtin/index.html#uint16">uint16</a> = 0x009c
    <span id="TLS_RSA_WITH_AES_256_GCM_SHA384">TLS_RSA_WITH_AES_256_GCM_SHA384</span>               <a href="../../builtin/index.html#uint16">uint16</a> = 0x009d
    <span id="TLS_ECDHE_ECDSA_WITH_RC4_128_SHA">TLS_ECDHE_ECDSA_WITH_RC4_128_SHA</span>              <a href="../../builtin/index.html#uint16">uint16</a> = 0xc007
    <span id="TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA">TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA</span>          <a href="../../builtin/index.html#uint16">uint16</a> = 0xc009
    <span id="TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA">TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA</span>          <a href="../../builtin/index.html#uint16">uint16</a> = 0xc00a
    <span id="TLS_ECDHE_RSA_WITH_RC4_128_SHA">TLS_ECDHE_RSA_WITH_RC4_128_SHA</span>                <a href="../../builtin/index.html#uint16">uint16</a> = 0xc011
    <span id="TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA">TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA</span>           <a href="../../builtin/index.html#uint16">uint16</a> = 0xc012
    <span id="TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA">TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA</span>            <a href="../../builtin/index.html#uint16">uint16</a> = 0xc013
    <span id="TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA">TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA</span>            <a href="../../builtin/index.html#uint16">uint16</a> = 0xc014
    <span id="TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256">TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256</span>       <a href="../../builtin/index.html#uint16">uint16</a> = 0xc023
    <span id="TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256">TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256</span>         <a href="../../builtin/index.html#uint16">uint16</a> = 0xc027
    <span id="TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256">TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</span>         <a href="../../builtin/index.html#uint16">uint16</a> = 0xc02f
    <span id="TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256">TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256</span>       <a href="../../builtin/index.html#uint16">uint16</a> = 0xc02b
    <span id="TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384">TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</span>         <a href="../../builtin/index.html#uint16">uint16</a> = 0xc030
    <span id="TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384">TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384</span>       <a href="../../builtin/index.html#uint16">uint16</a> = 0xc02c
    <span id="TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256">TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256</span>   <a href="../../builtin/index.html#uint16">uint16</a> = 0xcca8
    <span id="TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256">TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256</span> <a href="../../builtin/index.html#uint16">uint16</a> = 0xcca9

    <span class="comment">// TLS 1.3 cipher suites.</span>
    <span id="TLS_AES_128_GCM_SHA256">TLS_AES_128_GCM_SHA256</span>       <a href="../../builtin/index.html#uint16">uint16</a> = 0x1301
    <span id="TLS_AES_256_GCM_SHA384">TLS_AES_256_GCM_SHA384</span>       <a href="../../builtin/index.html#uint16">uint16</a> = 0x1302
    <span id="TLS_CHACHA20_POLY1305_SHA256">TLS_CHACHA20_POLY1305_SHA256</span> <a href="../../builtin/index.html#uint16">uint16</a> = 0x1303

    <span class="comment">// TLS_FALLBACK_SCSV isn&#39;t a standard cipher suite but an indicator</span>
    <span class="comment">// that the client is doing version fallback. See RFC 7507.</span>
    <span id="TLS_FALLBACK_SCSV">TLS_FALLBACK_SCSV</span> <a href="../../builtin/index.html#uint16">uint16</a> = 0x5600

    <span class="comment">// Legacy names for the corresponding cipher suites with the correct _SHA256</span>
    <span class="comment">// suffix, retained for backward compatibility.</span>
    <span id="TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305">TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305</span>   = <a href="index.html#TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256">TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256</a>
    <span id="TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305">TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305</span> = <a href="index.html#TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256">TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256</a>
)</pre>
			
				
				<pre>const (
    <span id="VersionTLS10">VersionTLS10</span> = 0x0301
    <span id="VersionTLS11">VersionTLS11</span> = 0x0302
    <span id="VersionTLS12">VersionTLS12</span> = 0x0303
    <span id="VersionTLS13">VersionTLS13</span> = 0x0304

    <span class="comment">// Deprecated: SSLv3 is cryptographically broken, and is no longer</span>
    <span class="comment">// supported by this package. See golang.org/issue/32716.</span>
    <span id="VersionSSL30">VersionSSL30</span> = 0x0300
)</pre>
			
				
				<pre>const (
    <span id="QUICEncryptionLevelInitial">QUICEncryptionLevelInitial</span> = <a href="index.html#QUICEncryptionLevel">QUICEncryptionLevel</a>(<a href="../../builtin/index.html#iota">iota</a>)
    <span id="QUICEncryptionLevelEarly">QUICEncryptionLevelEarly</span>
    <span id="QUICEncryptionLevelHandshake">QUICEncryptionLevelHandshake</span>
    <span id="QUICEncryptionLevelApplication">QUICEncryptionLevelApplication</span>
)</pre>
			
		
		
		
			
			
			<h2 id="CipherSuiteName">func <a href="../../../src/crypto/tls/cipher_suites.go?s=4749:4787#L89">CipherSuiteName</a>
				<a class="permalink" href="index.html#CipherSuiteName">&#xb6;</a>
				
				
			</h2>
			<pre>func CipherSuiteName(id <a href="../../builtin/index.html#uint16">uint16</a>) <a href="../../builtin/index.html#string">string</a></pre>
			<p>CipherSuiteName returns the standard name for the passed cipher suite ID
(e.g. &quot;TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256&quot;), or a fallback representation
of the ID value if the cipher suite is not implemented by this package.

			
			

		
			
			
			<h2 id="Listen">func <a href="../../../src/crypto/tls/tls.go?s=2453:2525#L78">Listen</a>
				<a class="permalink" href="index.html#Listen">&#xb6;</a>
				
				
			</h2>
			<pre>func Listen(network, laddr <a href="../../builtin/index.html#string">string</a>, config *<a href="index.html#Config">Config</a>) (<a href="../../net/index.html">net</a>.<a href="../../net/index.html#Listener">Listener</a>, <a href="../../builtin/index.html#error">error</a>)</pre>
			<p>Listen creates a TLS listener accepting connections on the
given network address using net.Listen.
The configuration config must be non-nil and must include
at least one certificate or else set GetCertificate.

			
			

		
			
			
			<h2 id="NewListener">func <a href="../../../src/crypto/tls/tls.go?s=2091:2156#L67">NewListener</a>
				<a class="permalink" href="index.html#NewListener">&#xb6;</a>
				
				
			</h2>
			<pre>func NewListener(inner <a href="../../net/index.html">net</a>.<a href="../../net/index.html#Listener">Listener</a>, config *<a href="index.html#Config">Config</a>) <a href="../../net/index.html">net</a>.<a href="../../net/index.html#Listener">Listener</a></pre>
			<p>NewListener creates a Listener which accepts connections from an inner
Listener and wraps each connection with <a href="index.html#Server">Server</a>.
The configuration config must be non-nil and must include
at least one certificate or else set GetCertificate.

			
			

		
			
			
			<h2 id="VersionName">func <a href="../../../src/crypto/tls/common.go?s=863:902#L33">VersionName</a>
				<a class="permalink" href="index.html#VersionName">&#xb6;</a>
				
				
			</h2>
			<pre>func VersionName(version <a href="../../builtin/index.html#uint16">uint16</a>) <a href="../../builtin/index.html#string">string</a></pre>
			<p>VersionName returns the name for the provided TLS version number
(e.g. &quot;TLS 1.3&quot;), or a fallback representation of the value if the
version is not implemented by this package.

			
			

		
		
			
			
			<h2 id="AlertError">type <a href="../../../src/crypto/tls/alert.go?s=356:377#L3">AlertError</a>
				<a class="permalink" href="index.html#AlertError">&#xb6;</a>
				
				
			</h2>
			<p>An AlertError is a TLS alert.
<p>When using a QUIC transport, QUICConn methods will return an error
which wraps AlertError rather than sending a TLS alert.

			<pre>type AlertError <a href="../../builtin/index.html#uint8">uint8</a></pre>

			

			

			
			
			

			

			
				
				<h3 id="AlertError.Error">func (AlertError) <a href="../../../src/crypto/tls/alert.go?s=379:413#L5">Error</a>
					<a class="permalink" href="index.html#AlertError.Error">&#xb6;</a>
					
					
				</h3>
				<pre>func (e <a href="index.html#AlertError">AlertError</a>) Error() <a href="../../builtin/index.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Certificate">type <a href="../../../src/crypto/tls/common.go?s=52057:53102#L1402">Certificate</a>
				<a class="permalink" href="index.html#Certificate">&#xb6;</a>
				
				
			</h2>
			<p>A Certificate is a chain of one or more certificates, leaf first.

			<pre>type Certificate struct {
<span id="Certificate.Certificate"></span>    Certificate [][]<a href="../../builtin/index.html#byte">byte</a>
<span id="Certificate.PrivateKey"></span>    <span class="comment">// PrivateKey contains the private key corresponding to the public key in</span>
<span id="Certificate.Leaf"></span>    <span class="comment">// Leaf. This must implement crypto.Signer with an RSA, ECDSA or Ed25519 PublicKey.</span>
    <span class="comment">// For a server up to TLS 1.2, it can also implement crypto.Decrypter with</span>
    <span class="comment">// an RSA PublicKey.</span>
    PrivateKey <a href="../index.html">crypto</a>.<a href="../index.html#PrivateKey">PrivateKey</a>
<span id="Certificate.SupportedSignatureAlgorithms"></span>    <span class="comment">// SupportedSignatureAlgorithms is an optional list restricting what</span>
    <span class="comment">// signature algorithms the PrivateKey can be used for.</span>
    SupportedSignatureAlgorithms []<a href="index.html#SignatureScheme">SignatureScheme</a>
<span id="Certificate.OCSPStaple"></span>    <span class="comment">// OCSPStaple contains an optional OCSP response which will be served</span>
    <span class="comment">// to clients that request it.</span>
    OCSPStaple []<a href="../../builtin/index.html#byte">byte</a>
<span id="Certificate.SignedCertificateTimestamps"></span>    <span class="comment">// SignedCertificateTimestamps contains an optional list of Signed</span>
    <span class="comment">// Certificate Timestamps which will be served to clients that request it.</span>
    SignedCertificateTimestamps [][]<a href="../../builtin/index.html#byte">byte</a>
    <span class="comment">// Leaf is the parsed form of the leaf certificate, which may be initialized</span>
    <span class="comment">// using x509.ParseCertificate to reduce per-handshake processing. If nil,</span>
    <span class="comment">// the leaf certificate will be parsed as needed.</span>
    Leaf *<a href="../x509/index.html">x509</a>.<a href="../x509/index.html#Certificate">Certificate</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="LoadX509KeyPair">func <a href="../../../src/crypto/tls/tls.go?s=7370:7437#L220">LoadX509KeyPair</a>
					<a class="permalink" href="index.html#LoadX509KeyPair">&#xb6;</a>
					
					
				</h3>
				<pre>func LoadX509KeyPair(certFile, keyFile <a href="../../builtin/index.html#string">string</a>) (<a href="index.html#Certificate">Certificate</a>, <a href="../../builtin/index.html#error">error</a>)</pre>
				<p>LoadX509KeyPair reads and parses a public/private key pair from a pair
of files. The files must contain PEM encoded data. The certificate file
may contain intermediate certificates following the leaf certificate to
form a certificate chain. On successful return, Certificate.Leaf will
be nil because the parsed form of the certificate is not retained.

				<div id="example_LoadX509KeyPair" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
cert, err := tls.LoadX509KeyPair(&#34;testdata/example-cert.pem&#34;, &#34;testdata/example-key.pem&#34;)
if err != nil {
    log.Fatal(err)
}
cfg := &amp;tls.Config{Certificates: []tls.Certificate{cert}}
listener, err := tls.Listen(&#34;tcp&#34;, &#34;:2000&#34;, cfg)
if err != nil {
    log.Fatal(err)
}
_ = listener
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="X509KeyPair">func <a href="../../../src/crypto/tls/tls.go?s=7870:7941#L235">X509KeyPair</a>
					<a class="permalink" href="index.html#X509KeyPair">&#xb6;</a>
					
					
				</h3>
				<pre>func X509KeyPair(certPEMBlock, keyPEMBlock []<a href="../../builtin/index.html#byte">byte</a>) (<a href="index.html#Certificate">Certificate</a>, <a href="../../builtin/index.html#error">error</a>)</pre>
				<p>X509KeyPair parses a public/private key pair from a pair of
PEM encoded data. On successful return, Certificate.Leaf will be nil because
the parsed form of the certificate is not retained.

				<div id="example_X509KeyPair" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
certPem := []byte(`-----BEGIN CERTIFICATE-----
MIIBhTCCASugAwIBAgIQIRi6zePL6mKjOipn+dNuaTAKBggqhkjOPQQDAjASMRAw
DgYDVQQKEwdBY21lIENvMB4XDTE3MTAyMDE5NDMwNloXDTE4MTAyMDE5NDMwNlow
EjEQMA4GA1UEChMHQWNtZSBDbzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABD0d
7VNhbWvZLWPuj/RtHFjvtJBEwOkhbN/BnnE8rnZR8+sbwnc/KhCk3FhnpHZnQz7B
5aETbbIgmuvewdjvSBSjYzBhMA4GA1UdDwEB/wQEAwICpDATBgNVHSUEDDAKBggr
BgEFBQcDATAPBgNVHRMBAf8EBTADAQH/MCkGA1UdEQQiMCCCDmxvY2FsaG9zdDo1
NDUzgg4xMjcuMC4wLjE6NTQ1MzAKBggqhkjOPQQDAgNIADBFAiEA2zpJEPQyz6/l
Wf86aX6PepsntZv2GYlA5UpabfT2EZICICpJ5h/iI+i341gBmLiAFQOyTDT+/wQc
6MF9+Yw1Yy0t
-----END CERTIFICATE-----`)
keyPem := []byte(`-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIIrYSSNQFaA2Hwf1duRSxKtLYX5CB04fSeQ6tF1aY/PuoAoGCCqGSM49
AwEHoUQDQgAEPR3tU2Fta9ktY+6P9G0cWO+0kETA6SFs38GecTyudlHz6xvCdz8q
EKTcWGekdmdDPsHloRNtsiCa697B2O9IFA==
-----END EC PRIVATE KEY-----`)
cert, err := tls.X509KeyPair(certPem, keyPem)
if err != nil {
    log.Fatal(err)
}
cfg := &amp;tls.Config{Certificates: []tls.Certificate{cert}}
listener, err := tls.Listen(&#34;tcp&#34;, &#34;:2000&#34;, cfg)
if err != nil {
    log.Fatal(err)
}
_ = listener
</pre>
			
		
	</div>
</div>
<div id="example_X509KeyPair_httpServer" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (HttpServer)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (HttpServer)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
certPem := []byte(`-----BEGIN CERTIFICATE-----
MIIBhTCCASugAwIBAgIQIRi6zePL6mKjOipn+dNuaTAKBggqhkjOPQQDAjASMRAw
DgYDVQQKEwdBY21lIENvMB4XDTE3MTAyMDE5NDMwNloXDTE4MTAyMDE5NDMwNlow
EjEQMA4GA1UEChMHQWNtZSBDbzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABD0d
7VNhbWvZLWPuj/RtHFjvtJBEwOkhbN/BnnE8rnZR8+sbwnc/KhCk3FhnpHZnQz7B
5aETbbIgmuvewdjvSBSjYzBhMA4GA1UdDwEB/wQEAwICpDATBgNVHSUEDDAKBggr
BgEFBQcDATAPBgNVHRMBAf8EBTADAQH/MCkGA1UdEQQiMCCCDmxvY2FsaG9zdDo1
NDUzgg4xMjcuMC4wLjE6NTQ1MzAKBggqhkjOPQQDAgNIADBFAiEA2zpJEPQyz6/l
Wf86aX6PepsntZv2GYlA5UpabfT2EZICICpJ5h/iI+i341gBmLiAFQOyTDT+/wQc
6MF9+Yw1Yy0t
-----END CERTIFICATE-----`)
keyPem := []byte(`-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIIrYSSNQFaA2Hwf1duRSxKtLYX5CB04fSeQ6tF1aY/PuoAoGCCqGSM49
AwEHoUQDQgAEPR3tU2Fta9ktY+6P9G0cWO+0kETA6SFs38GecTyudlHz6xvCdz8q
EKTcWGekdmdDPsHloRNtsiCa697B2O9IFA==
-----END EC PRIVATE KEY-----`)
cert, err := tls.X509KeyPair(certPem, keyPem)
if err != nil {
    log.Fatal(err)
}
cfg := &amp;tls.Config{Certificates: []tls.Certificate{cert}}
srv := &amp;http.Server{
    TLSConfig:    cfg,
    ReadTimeout:  time.Minute,
    WriteTimeout: time.Minute,
}
log.Fatal(srv.ListenAndServeTLS(&#34;&#34;, &#34;&#34;))
</pre>
			
		
	</div>
</div>

				
			

			
		
			
			
			<h2 id="CertificateRequestInfo">type <a href="../../../src/crypto/tls/common.go?s=16707:17335#L459">CertificateRequestInfo</a>
				<a class="permalink" href="index.html#CertificateRequestInfo">&#xb6;</a>
				
				
			</h2>
			<p>CertificateRequestInfo contains information from a server&apos;s
CertificateRequest message, which is used to demand a certificate and proof
of control from a client.

			<pre>type CertificateRequestInfo struct {
<span id="CertificateRequestInfo.AcceptableCAs"></span>    <span class="comment">// AcceptableCAs contains zero or more, DER-encoded, X.501</span>
    <span class="comment">// Distinguished Names. These are the names of root or intermediate CAs</span>
    <span class="comment">// that the server wishes the returned certificate to be signed by. An</span>
    <span class="comment">// empty slice indicates that the server has no preference.</span>
    AcceptableCAs [][]<a href="../../builtin/index.html#byte">byte</a>

<span id="CertificateRequestInfo.SignatureSchemes"></span>    <span class="comment">// SignatureSchemes lists the signature schemes that the server is</span>
    <span class="comment">// willing to verify.</span>
    SignatureSchemes []<a href="index.html#SignatureScheme">SignatureScheme</a>

<span id="CertificateRequestInfo.Version"></span>    <span class="comment">// Version is the TLS version that was negotiated for this connection.</span>
    Version <a href="../../builtin/index.html#uint16">uint16</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="CertificateRequestInfo.Context">func (*CertificateRequestInfo) <a href="../../../src/crypto/tls/common.go?s=17533:17591#L480">Context</a>
					<a class="permalink" href="index.html#CertificateRequestInfo.Context">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#CertificateRequestInfo">CertificateRequestInfo</a>) Context() <a href="../../context/index.html">context</a>.<a href="../../context/index.html#Context">Context</a></pre>
				<p>Context returns the context of the handshake that is in progress.
This context is a child of the context passed to HandshakeContext,
if any, and is canceled when the handshake concludes.

				
				
				
			
				
				<h3 id="CertificateRequestInfo.SupportsCertificate">func (*CertificateRequestInfo) <a href="../../../src/crypto/tls/common.go?s=49532:49608#L1320">SupportsCertificate</a>
					<a class="permalink" href="index.html#CertificateRequestInfo.SupportsCertificate">&#xb6;</a>
					
					
				</h3>
				<pre>func (cri *<a href="index.html#CertificateRequestInfo">CertificateRequestInfo</a>) SupportsCertificate(c *<a href="index.html#Certificate">Certificate</a>) <a href="../../builtin/index.html#error">error</a></pre>
				<p>SupportsCertificate returns nil if the provided certificate is supported by
the server that sent the CertificateRequest. Otherwise, it returns an error
describing the reason for the incompatibility.

				
				
				
			
		
			
			
			<h2 id="CertificateVerificationError">type <a href="../../../src/crypto/tls/common.go?s=55973:56159#L1535">CertificateVerificationError</a>
				<a class="permalink" href="index.html#CertificateVerificationError">&#xb6;</a>
				
				
			</h2>
			<p>CertificateVerificationError is returned when certificate verification fails during the handshake.

			<pre>type CertificateVerificationError struct {
<span id="CertificateVerificationError.UnverifiedCertificates"></span>    <span class="comment">// UnverifiedCertificates and its contents should not be modified.</span>
    UnverifiedCertificates []*<a href="../x509/index.html">x509</a>.<a href="../x509/index.html#Certificate">Certificate</a>
<span id="CertificateVerificationError.Err"></span>    Err                    <a href="../../builtin/index.html#error">error</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="CertificateVerificationError.Error">func (*CertificateVerificationError) <a href="../../../src/crypto/tls/common.go?s=56161:56214#L1541">Error</a>
					<a class="permalink" href="index.html#CertificateVerificationError.Error">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="index.html#CertificateVerificationError">CertificateVerificationError</a>) Error() <a href="../../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="CertificateVerificationError.Unwrap">func (*CertificateVerificationError) <a href="../../../src/crypto/tls/common.go?s=56288:56341#L1545">Unwrap</a>
					<a class="permalink" href="index.html#CertificateVerificationError.Unwrap">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="index.html#CertificateVerificationError">CertificateVerificationError</a>) Unwrap() <a href="../../builtin/index.html#error">error</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="CipherSuite">type <a href="../../../src/crypto/tls/cipher_suites.go?s=549:870#L17">CipherSuite</a>
				<a class="permalink" href="index.html#CipherSuite">&#xb6;</a>
				
				
			</h2>
			<p>CipherSuite is a TLS cipher suite. Note that most functions in this package
accept and expose cipher suite IDs instead of this type.

			<pre>type CipherSuite struct {
<span id="CipherSuite.ID"></span>    ID   <a href="../../builtin/index.html#uint16">uint16</a>
<span id="CipherSuite.Name"></span>    Name <a href="../../builtin/index.html#string">string</a>

    <span class="comment">// Supported versions is the list of TLS protocol versions that can</span>
    <span class="comment">// negotiate this cipher suite.</span>
<span id="CipherSuite.SupportedVersions"></span>    SupportedVersions []<a href="../../builtin/index.html#uint16">uint16</a>

<span id="CipherSuite.Insecure"></span>    <span class="comment">// Insecure is true if the cipher suite has known security issues</span>
    <span class="comment">// due to its primitives, design, or implementation.</span>
    Insecure <a href="../../builtin/index.html#bool">bool</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="CipherSuites">func <a href="../../../src/crypto/tls/cipher_suites.go?s=1436:1470#L43">CipherSuites</a>
					<a class="permalink" href="index.html#CipherSuites">&#xb6;</a>
					
					
				</h3>
				<pre>func CipherSuites() []*<a href="index.html#CipherSuite">CipherSuite</a></pre>
				<p>CipherSuites returns a list of cipher suites currently implemented by this
package, excluding those with security issues, which are returned by
<a href="index.html#InsecureCipherSuites">InsecureCipherSuites</a>.
<p>The list is sorted by ID. Note that the default cipher suites selected by
this package might depend on logic that can&apos;t be captured by a static list,
and might not match those returned by this function.

				
				
			
				
				<h3 id="InsecureCipherSuites">func <a href="../../../src/crypto/tls/cipher_suites.go?s=3146:3188#L67">InsecureCipherSuites</a>
					<a class="permalink" href="index.html#InsecureCipherSuites">&#xb6;</a>
					
					
				</h3>
				<pre>func InsecureCipherSuites() []*<a href="index.html#CipherSuite">CipherSuite</a></pre>
				<p>InsecureCipherSuites returns a list of cipher suites currently implemented by
this package and which have security issues.
<p>Most applications should not use the cipher suites in this list, and should
only use those returned by <a href="index.html#CipherSuites">CipherSuites</a>.

				
				
			

			
		
			
			
			<h2 id="ClientAuthType">type <a href="../../../src/crypto/tls/common.go?s=10605:10628#L310">ClientAuthType</a>
				<a class="permalink" href="index.html#ClientAuthType">&#xb6;</a>
				
				
			</h2>
			<p>ClientAuthType declares the policy the server will follow for
TLS Client Authentication.

			<pre>type ClientAuthType <a href="../../builtin/index.html#int">int</a></pre>

			
				
				<pre>const (
    <span class="comment">// NoClientCert indicates that no client certificate should be requested</span>
    <span class="comment">// during the handshake, and if any certificates are sent they will not</span>
    <span class="comment">// be verified.</span>
    <span id="NoClientCert">NoClientCert</span> <a href="index.html#ClientAuthType">ClientAuthType</a> = <a href="../../builtin/index.html#iota">iota</a>
    <span class="comment">// RequestClientCert indicates that a client certificate should be requested</span>
    <span class="comment">// during the handshake, but does not require that the client send any</span>
    <span class="comment">// certificates.</span>
    <span id="RequestClientCert">RequestClientCert</span>
    <span class="comment">// RequireAnyClientCert indicates that a client certificate should be requested</span>
    <span class="comment">// during the handshake, and that at least one certificate is required to be</span>
    <span class="comment">// sent by the client, but that certificate is not required to be valid.</span>
    <span id="RequireAnyClientCert">RequireAnyClientCert</span>
    <span class="comment">// VerifyClientCertIfGiven indicates that a client certificate should be requested</span>
    <span class="comment">// during the handshake, but does not require that the client sends a</span>
    <span class="comment">// certificate. If the client does send a certificate it is required to be</span>
    <span class="comment">// valid.</span>
    <span id="VerifyClientCertIfGiven">VerifyClientCertIfGiven</span>
    <span class="comment">// RequireAndVerifyClientCert indicates that a client certificate should be requested</span>
    <span class="comment">// during the handshake, and that at least one valid certificate is required</span>
    <span class="comment">// to be sent by the client.</span>
    <span id="RequireAndVerifyClientCert">RequireAndVerifyClientCert</span>
)</pre>
			

			

			
			
			

			

			
				
				<h3 id="ClientAuthType.String">func (ClientAuthType) <a href="../../../src/crypto/tls/common_string.go?s=3076:3115#L101">String</a>
					<a class="permalink" href="index.html#ClientAuthType.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (i <a href="index.html#ClientAuthType">ClientAuthType</a>) String() <a href="../../builtin/index.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="ClientHelloInfo">type <a href="../../../src/crypto/tls/common.go?s=14155:16267#L397">ClientHelloInfo</a>
				<a class="permalink" href="index.html#ClientHelloInfo">&#xb6;</a>
				
				
			</h2>
			<p>ClientHelloInfo contains information from a ClientHello message in order to
guide application logic in the GetCertificate and GetConfigForClient callbacks.

			<pre>type ClientHelloInfo struct {
<span id="ClientHelloInfo.CipherSuites"></span>    <span class="comment">// CipherSuites lists the CipherSuites supported by the client (e.g.</span>
    <span class="comment">// TLS_AES_128_GCM_SHA256, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256).</span>
    CipherSuites []<a href="../../builtin/index.html#uint16">uint16</a>

<span id="ClientHelloInfo.ServerName"></span>    <span class="comment">// ServerName indicates the name of the server requested by the client</span>
    <span class="comment">// in order to support virtual hosting. ServerName is only set if the</span>
    <span class="comment">// client is using SNI (see RFC 4366, Section 3.1).</span>
    ServerName <a href="../../builtin/index.html#string">string</a>

<span id="ClientHelloInfo.SupportedCurves"></span>    <span class="comment">// SupportedCurves lists the elliptic curves supported by the client.</span>
    <span class="comment">// SupportedCurves is set only if the Supported Elliptic Curves</span>
    <span class="comment">// Extension is being used (see RFC 4492, Section 5.1.1).</span>
    SupportedCurves []<a href="index.html#CurveID">CurveID</a>

<span id="ClientHelloInfo.SupportedPoints"></span>    <span class="comment">// SupportedPoints lists the point formats supported by the client.</span>
    <span class="comment">// SupportedPoints is set only if the Supported Point Formats Extension</span>
    <span class="comment">// is being used (see RFC 4492, Section 5.1.2).</span>
    SupportedPoints []<a href="../../builtin/index.html#uint8">uint8</a>

<span id="ClientHelloInfo.SignatureSchemes"></span>    <span class="comment">// SignatureSchemes lists the signature and hash schemes that the client</span>
    <span class="comment">// is willing to verify. SignatureSchemes is set only if the Signature</span>
    <span class="comment">// Algorithms Extension is being used (see RFC 5246, Section 7.4.1.4.1).</span>
    SignatureSchemes []<a href="index.html#SignatureScheme">SignatureScheme</a>

<span id="ClientHelloInfo.SupportedProtos"></span>    <span class="comment">// SupportedProtos lists the application protocols supported by the client.</span>
    <span class="comment">// SupportedProtos is set only if the Application-Layer Protocol</span>
    <span class="comment">// Negotiation Extension is being used (see RFC 7301, Section 3.1).</span>
    <span class="comment">//</span>
    <span class="comment">// Servers can select a protocol by setting Config.NextProtos in a</span>
    <span class="comment">// GetConfigForClient return value.</span>
    SupportedProtos []<a href="../../builtin/index.html#string">string</a>

<span id="ClientHelloInfo.SupportedVersions"></span>    <span class="comment">// SupportedVersions lists the TLS versions supported by the client.</span>
    <span class="comment">// For TLS versions less than 1.3, this is extrapolated from the max</span>
    <span class="comment">// version advertised by the client, so values other than the greatest</span>
    <span class="comment">// might be rejected if used.</span>
    SupportedVersions []<a href="../../builtin/index.html#uint16">uint16</a>

<span id="ClientHelloInfo.Conn"></span>    <span class="comment">// Conn is the underlying net.Conn for the connection. Do not read</span>
    <span class="comment">// from, or write to, this connection; that will cause the TLS</span>
    <span class="comment">// connection to fail.</span>
    Conn <a href="../../net/index.html">net</a>.<a href="../../net/index.html#Conn">Conn</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="ClientHelloInfo.Context">func (*ClientHelloInfo) <a href="../../../src/crypto/tls/common.go?s=16465:16516#L452">Context</a>
					<a class="permalink" href="index.html#ClientHelloInfo.Context">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#ClientHelloInfo">ClientHelloInfo</a>) Context() <a href="../../context/index.html">context</a>.<a href="../../context/index.html#Context">Context</a></pre>
				<p>Context returns the context of the handshake that is in progress.
This context is a child of the context passed to HandshakeContext,
if any, and is canceled when the handshake concludes.

				
				
				
			
				
				<h3 id="ClientHelloInfo.SupportsCertificate">func (*ClientHelloInfo) <a href="../../../src/crypto/tls/common.go?s=44519:44588#L1167">SupportsCertificate</a>
					<a class="permalink" href="index.html#ClientHelloInfo.SupportsCertificate">&#xb6;</a>
					
					
				</h3>
				<pre>func (chi *<a href="index.html#ClientHelloInfo">ClientHelloInfo</a>) SupportsCertificate(c *<a href="index.html#Certificate">Certificate</a>) <a href="../../builtin/index.html#error">error</a></pre>
				<p>SupportsCertificate returns nil if the provided certificate is supported by
the client that sent the ClientHello. Otherwise, it returns an error
describing the reason for the incompatibility.
<p>If this <a href="index.html#ClientHelloInfo">ClientHelloInfo</a> was passed to a GetConfigForClient or GetCertificate
callback, this method will take into account the associated <a href="index.html#Config">Config</a>. Note that
if GetConfigForClient returns a different <a href="index.html#Config">Config</a>, the change can&apos;t be
accounted for by this method.
<p>This function will call x509.ParseCertificate unless c.Leaf is set, which can
incur a significant performance cost.

				
				
				
			
		
			
			
			<h2 id="ClientSessionCache">type <a href="../../../src/crypto/tls/common.go?s=12469:13002#L353">ClientSessionCache</a>
				<a class="permalink" href="index.html#ClientSessionCache">&#xb6;</a>
				
				
			</h2>
			<p>ClientSessionCache is a cache of ClientSessionState objects that can be used
by a client to resume a TLS session with a given server. ClientSessionCache
implementations should expect to be called concurrently from different
goroutines. Up to TLS 1.2, only ticket-based resumption is supported, not
SessionID-based resumption. In TLS 1.3 they were merged into PSK modes, which
are supported via this interface.

			<pre>type ClientSessionCache interface {
    <span class="comment">// Get searches for a ClientSessionState associated with the given key.</span>
    <span class="comment">// On return, ok is true if one was found.</span>
    Get(sessionKey <a href="../../builtin/index.html#string">string</a>) (session *<a href="index.html#ClientSessionState">ClientSessionState</a>, ok <a href="../../builtin/index.html#bool">bool</a>)

    <span class="comment">// Put adds the ClientSessionState to the cache with the given key. It might</span>
    <span class="comment">// get called multiple times in a connection if a TLS 1.3 server provides</span>
    <span class="comment">// more than one session ticket. If called with a nil *ClientSessionState,</span>
    <span class="comment">// it should remove the cache entry.</span>
    Put(sessionKey <a href="../../builtin/index.html#string">string</a>, cs *<a href="index.html#ClientSessionState">ClientSessionState</a>)
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewLRUClientSessionCache">func <a href="../../../src/crypto/tls/common.go?s=53935:53997#L1456">NewLRUClientSessionCache</a>
					<a class="permalink" href="index.html#NewLRUClientSessionCache">&#xb6;</a>
					
					
				</h3>
				<pre>func NewLRUClientSessionCache(capacity <a href="../../builtin/index.html#int">int</a>) <a href="index.html#ClientSessionCache">ClientSessionCache</a></pre>
				<p>NewLRUClientSessionCache returns a <a href="index.html#ClientSessionCache">ClientSessionCache</a> with the given
capacity that uses an LRU strategy. If capacity is &lt; 1, a default capacity
is used instead.

				
				
			

			
		
			
			
			<h2 id="ClientSessionState">type <a href="../../../src/crypto/tls/ticket.go?s=11862:11935#L388">ClientSessionState</a>
				<a class="permalink" href="index.html#ClientSessionState">&#xb6;</a>
				
				
			</h2>
			<p>ClientSessionState contains the state needed by a client to
resume a previous TLS session.

			<pre>type ClientSessionState struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewResumptionState">func <a href="../../../src/crypto/tls/ticket.go?s=12630:12718#L407">NewResumptionState</a>
					<a class="permalink" href="index.html#NewResumptionState">&#xb6;</a>
					
					
				</h3>
				<pre>func NewResumptionState(ticket []<a href="../../builtin/index.html#byte">byte</a>, state *<a href="index.html#SessionState">SessionState</a>) (*<a href="index.html#ClientSessionState">ClientSessionState</a>, <a href="../../builtin/index.html#error">error</a>)</pre>
				<p>NewResumptionState returns a state value that can be returned by
[ClientSessionCache.Get] to resume a previous session.
<p>state needs to be returned by <a href="index.html#ParseSessionState">ParseSessionState</a>, and the ticket and session
state must have been returned by <a href="index.html#ClientSessionState.ResumptionState">ClientSessionState.ResumptionState</a>.

				
				
			

			
				
				<h3 id="ClientSessionState.ResumptionState">func (*ClientSessionState) <a href="../../../src/crypto/tls/ticket.go?s=12210:12305#L398">ResumptionState</a>
					<a class="permalink" href="index.html#ClientSessionState.ResumptionState">&#xb6;</a>
					
					
				</h3>
				<pre>func (cs *<a href="index.html#ClientSessionState">ClientSessionState</a>) ResumptionState() (ticket []<a href="../../builtin/index.html#byte">byte</a>, state *<a href="index.html#SessionState">SessionState</a>, err <a href="../../builtin/index.html#error">error</a>)</pre>
				<p>ResumptionState returns the session ticket sent by the server (also known as
the session&apos;s identity) and the state necessary to resume this session.
<p>It can be called by [ClientSessionCache.Put] to serialize (with
<a href="index.html#SessionState.Bytes">SessionState.Bytes</a>) and store the session.

				
				
				
			
		
			
			
			<h2 id="Config">type <a href="../../../src/crypto/tls/common.go?s=18997:31457#L517">Config</a>
				<a class="permalink" href="index.html#Config">&#xb6;</a>
				
				
			</h2>
			<p>A Config structure is used to configure a TLS client or server.
After one has been passed to a TLS function it must not be
modified. A Config may be reused; the tls package will also not
modify it.

			<pre>type Config struct {
<span id="Config.Rand"></span>    <span class="comment">// Rand provides the source of entropy for nonces and RSA blinding.</span>
    <span class="comment">// If Rand is nil, TLS uses the cryptographic random reader in package</span>
    <span class="comment">// crypto/rand.</span>
    <span class="comment">// The Reader must be safe for use by multiple goroutines.</span>
    Rand <a href="../../io/index.html">io</a>.<a href="../../io/index.html#Reader">Reader</a>

<span id="Config.Time"></span>    <span class="comment">// Time returns the current time as the number of seconds since the epoch.</span>
    <span class="comment">// If Time is nil, TLS uses time.Now.</span>
    Time func() <a href="../../time/index.html">time</a>.<a href="../../time/index.html#Time">Time</a>

<span id="Config.Certificates"></span>    <span class="comment">// Certificates contains one or more certificate chains to present to the</span>
    <span class="comment">// other side of the connection. The first certificate compatible with the</span>
    <span class="comment">// peer&#39;s requirements is selected automatically.</span>
    <span class="comment">//</span>
    <span class="comment">// Server configurations must set one of Certificates, GetCertificate or</span>
<span id="Config.GetConfigForClient"></span>    <span class="comment">// GetConfigForClient. Clients doing client-authentication may set either</span>
    <span class="comment">// Certificates or GetClientCertificate.</span>
    <span class="comment">//</span>
    <span class="comment">// Note: if there are multiple Certificates, and they don&#39;t have the</span>
    <span class="comment">// optional field Leaf set, certificate selection will incur a significant</span>
    <span class="comment">// per-handshake performance cost.</span>
    Certificates []<a href="index.html#Certificate">Certificate</a>

<span id="Config.NameToCertificate"></span>    <span class="comment">// NameToCertificate maps from a certificate name to an element of</span>
    <span class="comment">// Certificates. Note that a certificate name can be of the form</span>
    <span class="comment">// &#39;*.example.com&#39; and so doesn&#39;t have to be a domain name as such.</span>
    <span class="comment">//</span>
    <span class="comment">// Deprecated: NameToCertificate only allows associating a single</span>
    <span class="comment">// certificate with a given name. Leave this field nil to let the library</span>
    <span class="comment">// select the first compatible chain from Certificates.</span>
    NameToCertificate map[<a href="../../builtin/index.html#string">string</a>]*<a href="index.html#Certificate">Certificate</a>

<span id="Config.GetCertificate"></span>    <span class="comment">// GetCertificate returns a Certificate based on the given</span>
    <span class="comment">// ClientHelloInfo. It will only be called if the client supplies SNI</span>
    <span class="comment">// information or if Certificates is empty.</span>
    <span class="comment">//</span>
    <span class="comment">// If GetCertificate is nil or returns nil, then the certificate is</span>
    <span class="comment">// retrieved from NameToCertificate. If NameToCertificate is nil, the</span>
    <span class="comment">// best element of Certificates will be used.</span>
    <span class="comment">//</span>
    <span class="comment">// Once a Certificate is returned it should not be modified.</span>
    GetCertificate func(*<a href="index.html#ClientHelloInfo">ClientHelloInfo</a>) (*<a href="index.html#Certificate">Certificate</a>, <a href="../../builtin/index.html#error">error</a>)

<span id="Config.GetClientCertificate"></span>    <span class="comment">// GetClientCertificate, if not nil, is called when a server requests a</span>
    <span class="comment">// certificate from a client. If set, the contents of Certificates will</span>
    <span class="comment">// be ignored.</span>
    <span class="comment">//</span>
    <span class="comment">// If GetClientCertificate returns an error, the handshake will be</span>
    <span class="comment">// aborted and that error will be returned. Otherwise</span>
    <span class="comment">// GetClientCertificate must return a non-nil Certificate. If</span>
    <span class="comment">// Certificate.Certificate is empty then no certificate will be sent to</span>
    <span class="comment">// the server. If this is unacceptable to the server then it may abort</span>
    <span class="comment">// the handshake.</span>
    <span class="comment">//</span>
    <span class="comment">// GetClientCertificate may be called multiple times for the same</span>
    <span class="comment">// connection if renegotiation occurs or if TLS 1.3 is in use.</span>
    <span class="comment">//</span>
    <span class="comment">// Once a Certificate is returned it should not be modified.</span>
    GetClientCertificate func(*<a href="index.html#CertificateRequestInfo">CertificateRequestInfo</a>) (*<a href="index.html#Certificate">Certificate</a>, <a href="../../builtin/index.html#error">error</a>)

    <span class="comment">// GetConfigForClient, if not nil, is called after a ClientHello is</span>
    <span class="comment">// received from a client. It may return a non-nil Config in order to</span>
    <span class="comment">// change the Config that will be used to handle this connection. If</span>
    <span class="comment">// the returned Config is nil, the original Config will be used. The</span>
    <span class="comment">// Config returned by this callback may not be subsequently modified.</span>
    <span class="comment">//</span>
    <span class="comment">// If GetConfigForClient is nil, the Config passed to Server() will be</span>
    <span class="comment">// used for all connections.</span>
    <span class="comment">//</span>
    <span class="comment">// If SessionTicketKey was explicitly set on the returned Config, or if</span>
    <span class="comment">// SetSessionTicketKeys was called on the returned Config, those keys will</span>
    <span class="comment">// be used. Otherwise, the original Config keys will be used (and possibly</span>
    <span class="comment">// rotated if they are automatically managed).</span>
    GetConfigForClient func(*<a href="index.html#ClientHelloInfo">ClientHelloInfo</a>) (*<a href="index.html#Config">Config</a>, <a href="../../builtin/index.html#error">error</a>)

<span id="Config.VerifyPeerCertificate"></span>    <span class="comment">// VerifyPeerCertificate, if not nil, is called after normal</span>
    <span class="comment">// certificate verification by either a TLS client or server. It</span>
    <span class="comment">// receives the raw ASN.1 certificates provided by the peer and also</span>
    <span class="comment">// any verified chains that normal processing found. If it returns a</span>
    <span class="comment">// non-nil error, the handshake is aborted and that error results.</span>
    <span class="comment">//</span>
    <span class="comment">// If normal verification fails then the handshake will abort before</span>
    <span class="comment">// considering this callback. If normal verification is disabled (on the</span>
    <span class="comment">// client when InsecureSkipVerify is set, or on a server when ClientAuth is</span>
    <span class="comment">// RequestClientCert or RequireAnyClientCert), then this callback will be</span>
    <span class="comment">// considered but the verifiedChains argument will always be nil. When</span>
<span id="Config.ClientAuth"></span>    <span class="comment">// ClientAuth is NoClientCert, this callback is not called on the server.</span>
    <span class="comment">// rawCerts may be empty on the server if ClientAuth is RequestClientCert or</span>
    <span class="comment">// VerifyClientCertIfGiven.</span>
    <span class="comment">//</span>
    <span class="comment">// This callback is not invoked on resumed connections, as certificates are</span>
    <span class="comment">// not re-verified on resumption.</span>
    <span class="comment">//</span>
    <span class="comment">// verifiedChains and its contents should not be modified.</span>
    VerifyPeerCertificate func(rawCerts [][]<a href="../../builtin/index.html#byte">byte</a>, verifiedChains [][]*<a href="../x509/index.html">x509</a>.<a href="../x509/index.html#Certificate">Certificate</a>) <a href="../../builtin/index.html#error">error</a>

<span id="Config.VerifyConnection"></span>    <span class="comment">// VerifyConnection, if not nil, is called after normal certificate</span>
    <span class="comment">// verification and after VerifyPeerCertificate by either a TLS client</span>
    <span class="comment">// or server. If it returns a non-nil error, the handshake is aborted</span>
    <span class="comment">// and that error results.</span>
    <span class="comment">//</span>
    <span class="comment">// If normal verification fails then the handshake will abort before</span>
    <span class="comment">// considering this callback. This callback will run for all connections,</span>
    <span class="comment">// including resumptions, regardless of InsecureSkipVerify or ClientAuth</span>
    <span class="comment">// settings.</span>
    VerifyConnection func(<a href="index.html#ConnectionState">ConnectionState</a>) <a href="../../builtin/index.html#error">error</a>

<span id="Config.RootCAs"></span>    <span class="comment">// RootCAs defines the set of root certificate authorities</span>
    <span class="comment">// that clients use when verifying server certificates.</span>
    <span class="comment">// If RootCAs is nil, TLS uses the host&#39;s root CA set.</span>
    RootCAs *<a href="../x509/index.html">x509</a>.<a href="../x509/index.html#CertPool">CertPool</a>

<span id="Config.NextProtos"></span>    <span class="comment">// NextProtos is a list of supported application level protocols, in</span>
    <span class="comment">// order of preference. If both peers support ALPN, the selected</span>
    <span class="comment">// protocol will be one from this list, and the connection will fail</span>
    <span class="comment">// if there is no mutually supported protocol. If NextProtos is empty</span>
    <span class="comment">// or the peer doesn&#39;t support ALPN, the connection will succeed and</span>
    <span class="comment">// ConnectionState.NegotiatedProtocol will be empty.</span>
    NextProtos []<a href="../../builtin/index.html#string">string</a>

<span id="Config.ServerName"></span>    <span class="comment">// ServerName is used to verify the hostname on the returned</span>
    <span class="comment">// certificates unless InsecureSkipVerify is given. It is also included</span>
    <span class="comment">// in the client&#39;s handshake to support virtual hosting unless it is</span>
    <span class="comment">// an IP address.</span>
    ServerName <a href="../../builtin/index.html#string">string</a>

    <span class="comment">// ClientAuth determines the server&#39;s policy for</span>
    <span class="comment">// TLS Client Authentication. The default is NoClientCert.</span>
    ClientAuth <a href="index.html#ClientAuthType">ClientAuthType</a>

<span id="Config.ClientCAs"></span>    <span class="comment">// ClientCAs defines the set of root certificate authorities</span>
    <span class="comment">// that servers use if required to verify a client certificate</span>
    <span class="comment">// by the policy in ClientAuth.</span>
    ClientCAs *<a href="../x509/index.html">x509</a>.<a href="../x509/index.html#CertPool">CertPool</a>

<span id="Config.InsecureSkipVerify"></span>    <span class="comment">// InsecureSkipVerify controls whether a client verifies the server&#39;s</span>
    <span class="comment">// certificate chain and host name. If InsecureSkipVerify is true, crypto/tls</span>
    <span class="comment">// accepts any certificate presented by the server and any host name in that</span>
    <span class="comment">// certificate. In this mode, TLS is susceptible to machine-in-the-middle</span>
    <span class="comment">// attacks unless custom verification is used. This should be used only for</span>
    <span class="comment">// testing or in combination with VerifyConnection or VerifyPeerCertificate.</span>
    InsecureSkipVerify <a href="../../builtin/index.html#bool">bool</a>

<span id="Config.CipherSuites"></span>    <span class="comment">// CipherSuites is a list of enabled TLS 1.0–1.2 cipher suites. The order of</span>
    <span class="comment">// the list is ignored. Note that TLS 1.3 ciphersuites are not configurable.</span>
    <span class="comment">//</span>
    <span class="comment">// If CipherSuites is nil, a safe default list is used. The default cipher</span>
    <span class="comment">// suites might change over time. In Go 1.22 RSA key exchange based cipher</span>
    <span class="comment">// suites were removed from the default list, but can be re-added with the</span>
    <span class="comment">// GODEBUG setting tlsrsakex=1.</span>
    CipherSuites []<a href="../../builtin/index.html#uint16">uint16</a>

<span id="Config.PreferServerCipherSuites"></span>    <span class="comment">// PreferServerCipherSuites is a legacy field and has no effect.</span>
    <span class="comment">//</span>
    <span class="comment">// It used to control whether the server would follow the client&#39;s or the</span>
    <span class="comment">// server&#39;s preference. Servers now select the best mutually supported</span>
    <span class="comment">// cipher suite based on logic that takes into account inferred client</span>
    <span class="comment">// hardware, server hardware, and security.</span>
    <span class="comment">//</span>
    <span class="comment">// Deprecated: PreferServerCipherSuites is ignored.</span>
    PreferServerCipherSuites <a href="../../builtin/index.html#bool">bool</a>

<span id="Config.SessionTicketsDisabled"></span>    <span class="comment">// SessionTicketsDisabled may be set to true to disable session ticket and</span>
    <span class="comment">// PSK (resumption) support. Note that on clients, session ticket support is</span>
    <span class="comment">// also disabled if ClientSessionCache is nil.</span>
    SessionTicketsDisabled <a href="../../builtin/index.html#bool">bool</a>

<span id="Config.SessionTicketKey"></span>    <span class="comment">// SessionTicketKey is used by TLS servers to provide session resumption.</span>
    <span class="comment">// See RFC 5077 and the PSK mode of RFC 8446. If zero, it will be filled</span>
    <span class="comment">// with random data before the first server handshake.</span>
    <span class="comment">//</span>
    <span class="comment">// Deprecated: if this field is left at zero, session ticket keys will be</span>
    <span class="comment">// automatically rotated every day and dropped after seven days. For</span>
    <span class="comment">// customizing the rotation schedule or synchronizing servers that are</span>
    <span class="comment">// terminating connections for the same host, use SetSessionTicketKeys.</span>
    SessionTicketKey [32]<a href="../../builtin/index.html#byte">byte</a>

<span id="Config.ClientSessionCache"></span>    <span class="comment">// ClientSessionCache is a cache of ClientSessionState entries for TLS</span>
    <span class="comment">// session resumption. It is only used by clients.</span>
    ClientSessionCache <a href="index.html#ClientSessionCache">ClientSessionCache</a>

<span id="Config.UnwrapSession"></span>    <span class="comment">// UnwrapSession is called on the server to turn a ticket/identity</span>
    <span class="comment">// previously produced by [WrapSession] into a usable session.</span>
    <span class="comment">//</span>
    <span class="comment">// UnwrapSession will usually either decrypt a session state in the ticket</span>
    <span class="comment">// (for example with [Config.EncryptTicket]), or use the ticket as a handle</span>
    <span class="comment">// to recover a previously stored state. It must use [ParseSessionState] to</span>
    <span class="comment">// deserialize the session state.</span>
    <span class="comment">//</span>
    <span class="comment">// If UnwrapSession returns an error, the connection is terminated. If it</span>
    <span class="comment">// returns (nil, nil), the session is ignored. crypto/tls may still choose</span>
    <span class="comment">// not to resume the returned session.</span>
    UnwrapSession func(identity []<a href="../../builtin/index.html#byte">byte</a>, cs <a href="index.html#ConnectionState">ConnectionState</a>) (*<a href="index.html#SessionState">SessionState</a>, <a href="../../builtin/index.html#error">error</a>)

<span id="Config.WrapSession"></span>    <span class="comment">// WrapSession is called on the server to produce a session ticket/identity.</span>
    <span class="comment">//</span>
    <span class="comment">// WrapSession must serialize the session state with [SessionState.Bytes].</span>
    <span class="comment">// It may then encrypt the serialized state (for example with</span>
    <span class="comment">// [Config.DecryptTicket]) and use it as the ticket, or store the state and</span>
    <span class="comment">// return a handle for it.</span>
    <span class="comment">//</span>
    <span class="comment">// If WrapSession returns an error, the connection is terminated.</span>
    <span class="comment">//</span>
    <span class="comment">// Warning: the return value will be exposed on the wire and to clients in</span>
    <span class="comment">// plaintext. The application is in charge of encrypting and authenticating</span>
    <span class="comment">// it (and rotating keys) or returning high-entropy identifiers. Failing to</span>
    <span class="comment">// do so correctly can compromise current, previous, and future connections</span>
    <span class="comment">// depending on the protocol version.</span>
    WrapSession func(<a href="index.html#ConnectionState">ConnectionState</a>, *<a href="index.html#SessionState">SessionState</a>) ([]<a href="../../builtin/index.html#byte">byte</a>, <a href="../../builtin/index.html#error">error</a>)

<span id="Config.MinVersion"></span>    <span class="comment">// MinVersion contains the minimum TLS version that is acceptable.</span>
    <span class="comment">//</span>
    <span class="comment">// By default, TLS 1.2 is currently used as the minimum. TLS 1.0 is the</span>
    <span class="comment">// minimum supported by this package.</span>
    <span class="comment">//</span>
    <span class="comment">// The server-side default can be reverted to TLS 1.0 by including the value</span>
    <span class="comment">// &#34;tls10server=1&#34; in the GODEBUG environment variable.</span>
    MinVersion <a href="../../builtin/index.html#uint16">uint16</a>

<span id="Config.MaxVersion"></span>    <span class="comment">// MaxVersion contains the maximum TLS version that is acceptable.</span>
    <span class="comment">//</span>
    <span class="comment">// By default, the maximum version supported by this package is used,</span>
    <span class="comment">// which is currently TLS 1.3.</span>
    MaxVersion <a href="../../builtin/index.html#uint16">uint16</a>

<span id="Config.CurvePreferences"></span>    <span class="comment">// CurvePreferences contains the elliptic curves that will be used in</span>
    <span class="comment">// an ECDHE handshake, in preference order. If empty, the default will</span>
    <span class="comment">// be used. The client will use the first preference as the type for</span>
    <span class="comment">// its key share in TLS 1.3. This may change in the future.</span>
    CurvePreferences []<a href="index.html#CurveID">CurveID</a>

<span id="Config.DynamicRecordSizingDisabled"></span>    <span class="comment">// DynamicRecordSizingDisabled disables adaptive sizing of TLS records.</span>
    <span class="comment">// When true, the largest possible TLS record size is always used. When</span>
    <span class="comment">// false, the size of TLS records may be adjusted in an attempt to</span>
    <span class="comment">// improve latency.</span>
    DynamicRecordSizingDisabled <a href="../../builtin/index.html#bool">bool</a>

<span id="Config.Renegotiation"></span>    <span class="comment">// Renegotiation controls what types of renegotiation are supported.</span>
    <span class="comment">// The default, none, is correct for the vast majority of applications.</span>
    Renegotiation <a href="index.html#RenegotiationSupport">RenegotiationSupport</a>

<span id="Config.KeyLogWriter"></span>    <span class="comment">// KeyLogWriter optionally specifies a destination for TLS master secrets</span>
    <span class="comment">// in NSS key log format that can be used to allow external programs</span>
    <span class="comment">// such as Wireshark to decrypt TLS connections.</span>
    <span class="comment">// See https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format.</span>
    <span class="comment">// Use of KeyLogWriter compromises security and should only be</span>
    <span class="comment">// used for debugging.</span>
    KeyLogWriter <a href="../../io/index.html">io</a>.<a href="../../io/index.html#Writer">Writer</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_Config_keyLogWriter" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (KeyLogWriter)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (KeyLogWriter)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
<span class="comment">// Debugging TLS applications by decrypting a network traffic capture.</span>

<span class="comment">// WARNING: Use of KeyLogWriter compromises security and should only be</span>
<span class="comment">// used for debugging.</span>

<span class="comment">// Dummy test HTTP server for the example with insecure random so output is</span>
<span class="comment">// reproducible.</span>
server := httptest.NewUnstartedServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {}))
server.TLS = &amp;tls.Config{
    Rand: zeroSource{}, <span class="comment">// for example only; don&#39;t do this.</span>
}
server.StartTLS()
defer server.Close()

<span class="comment">// Typically the log would go to an open file:</span>
<span class="comment">// w, err := os.OpenFile(&#34;tls-secrets.txt&#34;, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)</span>
w := os.Stdout

client := &amp;http.Client{
    Transport: &amp;http.Transport{
        TLSClientConfig: &amp;tls.Config{
            KeyLogWriter: w,

            Rand:               zeroSource{}, <span class="comment">// for reproducible output; don&#39;t do this.</span>
            InsecureSkipVerify: true,         <span class="comment">// test server certificate is not trusted.</span>
        },
    },
}
resp, err := client.Get(server.URL)
if err != nil {
    log.Fatalf(&#34;Failed to get URL: %v&#34;, err)
}
resp.Body.Close()

<span class="comment">// The resulting file can be used with Wireshark to decrypt the TLS</span>
<span class="comment">// connection by setting (Pre)-Master-Secret log filename in SSL Protocol</span>
<span class="comment">// preferences.</span>
</pre>
			
		
	</div>
</div>
<div id="example_Config_verifyConnection" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (VerifyConnection)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (VerifyConnection)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
<span class="comment">// VerifyConnection can be used to replace and customize connection</span>
<span class="comment">// verification. This example shows a VerifyConnection implementation that</span>
<span class="comment">// will be approximately equivalent to what crypto/tls does normally to</span>
<span class="comment">// verify the peer&#39;s certificate.</span>

<span class="comment">// Client side configuration.</span>
_ = &amp;tls.Config{
    <span class="comment">// Set InsecureSkipVerify to skip the default validation we are</span>
    <span class="comment">// replacing. This will not disable VerifyConnection.</span>
    InsecureSkipVerify: true,
    VerifyConnection: func(cs tls.ConnectionState) error {
        opts := x509.VerifyOptions{
            DNSName:       cs.ServerName,
            Intermediates: x509.NewCertPool(),
        }
        for _, cert := range cs.PeerCertificates[1:] {
            opts.Intermediates.AddCert(cert)
        }
        _, err := cs.PeerCertificates[0].Verify(opts)
        return err
    },
}

<span class="comment">// Server side configuration.</span>
_ = &amp;tls.Config{
    <span class="comment">// Require client certificates (or VerifyConnection will run anyway and</span>
    <span class="comment">// panic accessing cs.PeerCertificates[0]) but don&#39;t verify them with the</span>
    <span class="comment">// default verifier. This will not disable VerifyConnection.</span>
    ClientAuth: tls.RequireAnyClientCert,
    VerifyConnection: func(cs tls.ConnectionState) error {
        opts := x509.VerifyOptions{
            DNSName:       cs.ServerName,
            Intermediates: x509.NewCertPool(),
            KeyUsages:     []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth},
        }
        for _, cert := range cs.PeerCertificates[1:] {
            opts.Intermediates.AddCert(cert)
        }
        _, err := cs.PeerCertificates[0].Verify(opts)
        return err
    },
}

<span class="comment">// Note that when certificates are not handled by the default verifier</span>
<span class="comment">// ConnectionState.VerifiedChains will be nil.</span>
</pre>
			
		
	</div>
</div>

			
			

			

			
				
				<h3 id="Config.BuildNameToCertificate">func (*Config) <a href="../../../src/crypto/tls/common.go?s=50666:50707#L1356">BuildNameToCertificate</a>
					<a class="permalink" href="index.html#Config.BuildNameToCertificate">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Config">Config</a>) BuildNameToCertificate()</pre>
				<p>BuildNameToCertificate parses c.Certificates and builds c.NameToCertificate
from the CommonName and SubjectAlternateName fields of each of the leaf
certificates.
<p>Deprecated: NameToCertificate only allows associating a single certificate
with a given name. Leave that field nil to let the library select the first
compatible chain from Certificates.

				
				
				
			
				
				<h3 id="Config.Clone">func (*Config) <a href="../../../src/crypto/tls/common.go?s=33114:33146#L819">Clone</a>
					<a class="permalink" href="index.html#Config.Clone">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Config">Config</a>) Clone() *<a href="index.html#Config">Config</a></pre>
				<p>Clone returns a shallow clone of c or nil if c is nil. It is safe to clone a <a href="index.html#Config">Config</a> that is
being used concurrently by a TLS client or server.

				
				
				
			
				
				<h3 id="Config.DecryptTicket">func (*Config) <a href="../../../src/crypto/tls/ticket.go?s=10605:10695#L341">DecryptTicket</a>
					<a class="permalink" href="index.html#Config.DecryptTicket">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Config">Config</a>) DecryptTicket(identity []<a href="../../builtin/index.html#byte">byte</a>, cs <a href="index.html#ConnectionState">ConnectionState</a>) (*<a href="index.html#SessionState">SessionState</a>, <a href="../../builtin/index.html#error">error</a>)</pre>
				<p>DecryptTicket decrypts a ticket encrypted by <a href="index.html#Config.EncryptTicket">Config.EncryptTicket</a>. It can
be used as a [Config.UnwrapSession] implementation.
<p>If the ticket can&apos;t be decrypted or parsed, DecryptTicket returns (nil, nil).

				
				
				
			
				
				<h3 id="Config.EncryptTicket">func (*Config) <a href="../../../src/crypto/tls/ticket.go?s=9233:9317#L300">EncryptTicket</a>
					<a class="permalink" href="index.html#Config.EncryptTicket">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Config">Config</a>) EncryptTicket(cs <a href="index.html#ConnectionState">ConnectionState</a>, ss *<a href="index.html#SessionState">SessionState</a>) ([]<a href="../../builtin/index.html#byte">byte</a>, <a href="../../builtin/index.html#error">error</a>)</pre>
				<p>EncryptTicket encrypts a ticket with the <a href="index.html#Config">Config</a>&apos;s configured (or default)
session ticket keys. It can be used as a [Config.WrapSession] implementation.

				
				
				
			
				
				<h3 id="Config.SetSessionTicketKeys">func (*Config) <a href="../../../src/crypto/tls/common.go?s=39383:39437#L970">SetSessionTicketKeys</a>
					<a class="permalink" href="index.html#Config.SetSessionTicketKeys">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Config">Config</a>) SetSessionTicketKeys(keys [][32]<a href="../../builtin/index.html#byte">byte</a>)</pre>
				<p>SetSessionTicketKeys updates the session ticket keys for a server.
<p>The first key will be used when creating new tickets, while all keys can be
used for decrypting tickets. It is safe to call this function while the
server is running in order to rotate the session ticket keys. The function
will panic if keys is empty.
<p>Calling this function will turn off automatic session ticket key rotation.
<p>If multiple servers are terminating connections for the same host they should
all have the same session ticket keys. If the session ticket keys leaks,
previously recorded and future TLS connections using those keys might be
compromised.

				
				
				
			
		
			
			
			<h2 id="Conn">type <a href="../../../src/crypto/tls/conn.go?s=473:4516#L18">Conn</a>
				<a class="permalink" href="index.html#Conn">&#xb6;</a>
				
				
			</h2>
			<p>A Conn represents a secured connection.
It implements the net.Conn interface.

			<pre>type Conn struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="Client">func <a href="../../../src/crypto/tls/tls.go?s=1276:1324#L37">Client</a>
					<a class="permalink" href="index.html#Client">&#xb6;</a>
					
					
				</h3>
				<pre>func Client(conn <a href="../../net/index.html">net</a>.<a href="../../net/index.html#Conn">Conn</a>, config *<a href="index.html#Config">Config</a>) *<a href="index.html#Conn">Conn</a></pre>
				<p>Client returns a new TLS client side connection
using conn as the underlying transport.
The config cannot be nil: users must set either ServerName or
InsecureSkipVerify in the config.

				
				
			
				
				<h3 id="Dial">func <a href="../../../src/crypto/tls/tls.go?s=5145:5207#L160">Dial</a>
					<a class="permalink" href="index.html#Dial">&#xb6;</a>
					
					
				</h3>
				<pre>func Dial(network, addr <a href="../../builtin/index.html#string">string</a>, config *<a href="index.html#Config">Config</a>) (*<a href="index.html#Conn">Conn</a>, <a href="../../builtin/index.html#error">error</a>)</pre>
				<p>Dial connects to the given network address using net.Dial
and then initiates a TLS handshake, returning the resulting
TLS connection.
Dial interprets a nil configuration as equivalent to
the zero configuration; see the documentation of Config
for the defaults.

				<div id="example_Dial" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
<span class="comment">// Connecting with a custom root-certificate set.</span>

const rootPEM = `
-- GlobalSign Root R2, valid until Dec 15, 2021
-----BEGIN CERTIFICATE-----
MIIDujCCAqKgAwIBAgILBAAAAAABD4Ym5g0wDQYJKoZIhvcNAQEFBQAwTDEgMB4G
A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjIxEzARBgNVBAoTCkdsb2JhbFNp
Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDYxMjE1MDgwMDAwWhcNMjExMjE1
MDgwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMjETMBEG
A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI
hvcNAQEBBQADggEPADCCAQoCggEBAKbPJA6+Lm8omUVCxKs+IVSbC9N/hHD6ErPL
v4dfxn+G07IwXNb9rfF73OX4YJYJkhD10FPe+3t+c4isUoh7SqbKSaZeqKeMWhG8
eoLrvozps6yWJQeXSpkqBy+0Hne/ig+1AnwblrjFuTosvNYSuetZfeLQBoZfXklq
tTleiDTsvHgMCJiEbKjNS7SgfQx5TfC4LcshytVsW33hoCmEofnTlEnLJGKRILzd
C9XZzPnqJworc5HGnRusyMvo4KD0L5CLTfuwNhv2GXqF4G3yYROIXJ/gkwpRl4pa
zq+r1feqCapgvdzZX99yqWATXgAByUr6P6TqBwMhAo6CygPCm48CAwEAAaOBnDCB
mTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUm+IH
V2ccHsBqBt5ZtJot39wZhi4wNgYDVR0fBC8wLTAroCmgJ4YlaHR0cDovL2NybC5n
bG9iYWxzaWduLm5ldC9yb290LXIyLmNybDAfBgNVHSMEGDAWgBSb4gdXZxwewGoG
3lm0mi3f3BmGLjANBgkqhkiG9w0BAQUFAAOCAQEAmYFThxxol4aR7OBKuEQLq4Gs
J0/WwbgcQ3izDJr86iw8bmEbTUsp9Z8FHSbBuOmDAGJFtqkIk7mpM0sYmsL4h4hO
291xNBrBVNpGP+DTKqttVCL1OmLNIG+6KYnX3ZHu01yiPqFbQfXf5WRDLenVOavS
ot+3i9DAgBkcRcAtjOj4LaR0VknFBbVPFd5uRHg5h6h+u/N5GJG79G+dwfCMNYxd
AfvDbbnvRG15RjF+Cv6pgsH/76tuIMRQyV+dTZsXjAzlAcmgQWpzU/qlULRuJQ/7
TBj0/VLZjmmx6BEP3ojY+x1J96relc8geMJgEtslQIxq/H5COEBkEveegeGTLg==
-----END CERTIFICATE-----`

<span class="comment">// First, create the set of root certificates. For this example we only</span>
<span class="comment">// have one. It&#39;s also possible to omit this in order to use the</span>
<span class="comment">// default root set of the current operating system.</span>
roots := x509.NewCertPool()
ok := roots.AppendCertsFromPEM([]byte(rootPEM))
if !ok {
    panic(&#34;failed to parse root certificate&#34;)
}

conn, err := tls.Dial(&#34;tcp&#34;, &#34;mail.google.com:443&#34;, &amp;tls.Config{
    RootCAs: roots,
})
if err != nil {
    panic(&#34;failed to connect: &#34; + err.Error())
}
conn.Close()
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="DialWithDialer">func <a href="../../../src/crypto/tls/tls.go?s=3644:3736#L106">DialWithDialer</a>
					<a class="permalink" href="index.html#DialWithDialer">&#xb6;</a>
					
					
				</h3>
				<pre>func DialWithDialer(dialer *<a href="../../net/index.html">net</a>.<a href="../../net/index.html#Dialer">Dialer</a>, network, addr <a href="../../builtin/index.html#string">string</a>, config *<a href="index.html#Config">Config</a>) (*<a href="index.html#Conn">Conn</a>, <a href="../../builtin/index.html#error">error</a>)</pre>
				<p>DialWithDialer connects to the given network address using dialer.Dial and
then initiates a TLS handshake, returning the resulting TLS connection. Any
timeout or deadline given in the dialer apply to connection and TLS
handshake as a whole.
<p>DialWithDialer interprets a nil configuration as equivalent to the zero
configuration; see the documentation of <a href="index.html#Config">Config</a> for the defaults.
<p>DialWithDialer uses context.Background internally; to specify the context,
use <a href="index.html#Dialer.DialContext">Dialer.DialContext</a> with NetDialer set to the desired dialer.

				
				
			
				
				<h3 id="Server">func <a href="../../../src/crypto/tls/tls.go?s=931:979#L24">Server</a>
					<a class="permalink" href="index.html#Server">&#xb6;</a>
					
					
				</h3>
				<pre>func Server(conn <a href="../../net/index.html">net</a>.<a href="../../net/index.html#Conn">Conn</a>, config *<a href="index.html#Config">Config</a>) *<a href="index.html#Conn">Conn</a></pre>
				<p>Server returns a new TLS server side connection
using conn as the underlying transport.
The configuration config must be non-nil and must include
at least one certificate or else set GetCertificate.

				
				
			

			
				
				<h3 id="Conn.Close">func (*Conn) <a href="../../../src/crypto/tls/conn.go?s=43766:43794#L1390">Close</a>
					<a class="permalink" href="index.html#Conn.Close">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Conn">Conn</a>) Close() <a href="../../builtin/index.html#error">error</a></pre>
				<p>Close closes the connection.

				
				
				
			
				
				<h3 id="Conn.CloseWrite">func (*Conn) <a href="../../../src/crypto/tls/conn.go?s=44989:45022#L1430">CloseWrite</a>
					<a class="permalink" href="index.html#Conn.CloseWrite">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Conn">Conn</a>) CloseWrite() <a href="../../builtin/index.html#error">error</a></pre>
				<p>CloseWrite shuts down the writing side of the connection. It should only be
called once the handshake has completed and does not call CloseWrite on the
underlying connection. Most callers should just use <a href="index.html#Conn.Close">Conn.Close</a>.

				
				
				
			
				
				<h3 id="Conn.ConnectionState">func (*Conn) <a href="../../../src/crypto/tls/conn.go?s=50038:50086#L1587">ConnectionState</a>
					<a class="permalink" href="index.html#Conn.ConnectionState">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Conn">Conn</a>) ConnectionState() <a href="index.html#ConnectionState">ConnectionState</a></pre>
				<p>ConnectionState returns basic TLS details about the connection.

				
				
				
			
				
				<h3 id="Conn.Handshake">func (*Conn) <a href="../../../src/crypto/tls/conn.go?s=46195:46227#L1466">Handshake</a>
					<a class="permalink" href="index.html#Conn.Handshake">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Conn">Conn</a>) Handshake() <a href="../../builtin/index.html#error">error</a></pre>
				<p>Handshake runs the client or server handshake
protocol if it has not yet been run.
<p>Most uses of this package need not call Handshake explicitly: the
first <a href="index.html#Conn.Read">Conn.Read</a> or <a href="index.html#Conn.Write">Conn.Write</a> will call it automatically.
<p>For control over canceling or setting a timeout on a handshake, use
<a href="index.html#Conn.HandshakeContext">Conn.HandshakeContext</a> or the <a href="index.html#Dialer">Dialer</a>&apos;s DialContext method instead.
<p>In order to avoid denial of service attacks, the maximum RSA key size allowed
in certificates sent by either the TLS server or client is limited to 8192
bits. This limit can be overridden by setting tlsmaxrsasize in the GODEBUG
environment variable (e.g. GODEBUG=tlsmaxrsasize=4096).

				
				
				
			
				
				<h3 id="Conn.HandshakeContext">func (*Conn) <a href="../../../src/crypto/tls/conn.go?s=46785:46843#L1480">HandshakeContext</a>
					<a class="permalink" href="index.html#Conn.HandshakeContext">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Conn">Conn</a>) HandshakeContext(ctx <a href="../../context/index.html">context</a>.<a href="../../context/index.html#Context">Context</a>) <a href="../../builtin/index.html#error">error</a></pre>
				<p>HandshakeContext runs the client or server handshake
protocol if it has not yet been run.
<p>The provided Context must be non-nil. If the context is canceled before
the handshake is complete, the handshake is interrupted and an error is returned.
Once the handshake has completed, cancellation of the context will not affect the
connection.
<p>Most uses of this package need not call HandshakeContext explicitly: the
first <a href="index.html#Conn.Read">Conn.Read</a> or <a href="index.html#Conn.Write">Conn.Write</a> will call it automatically.

				
				
				
			
				
				<h3 id="Conn.LocalAddr">func (*Conn) <a href="../../../src/crypto/tls/conn.go?s=4679:4714#L120">LocalAddr</a>
					<a class="permalink" href="index.html#Conn.LocalAddr">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Conn">Conn</a>) LocalAddr() <a href="../../net/index.html">net</a>.<a href="../../net/index.html#Addr">Addr</a></pre>
				<p>LocalAddr returns the local network address.

				
				
				
			
				
				<h3 id="Conn.NetConn">func (*Conn) <a href="../../../src/crypto/tls/conn.go?s=5936:5969#L152">NetConn</a>
					<a class="permalink" href="index.html#Conn.NetConn">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Conn">Conn</a>) NetConn() <a href="../../net/index.html">net</a>.<a href="../../net/index.html#Conn">Conn</a></pre>
				<p>NetConn returns the underlying connection that is wrapped by c.
Note that writing to or reading from this connection directly will corrupt the
TLS session.

				
				
				
			
				
				<h3 id="Conn.OCSPResponse">func (*Conn) <a href="../../../src/crypto/tls/conn.go?s=51513:51549#L1633">OCSPResponse</a>
					<a class="permalink" href="index.html#Conn.OCSPResponse">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Conn">Conn</a>) OCSPResponse() []<a href="../../builtin/index.html#byte">byte</a></pre>
				<p>OCSPResponse returns the stapled OCSP response from the TLS server, if
any. (Only valid for client connections.)

				
				
				
			
				
				<h3 id="Conn.Read">func (*Conn) <a href="../../../src/crypto/tls/conn.go?s=42479:42521#L1346">Read</a>
					<a class="permalink" href="index.html#Conn.Read">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Conn">Conn</a>) Read(b []<a href="../../builtin/index.html#byte">byte</a>) (<a href="../../builtin/index.html#int">int</a>, <a href="../../builtin/index.html#error">error</a>)</pre>
				<p>Read reads data from the connection.
<p>As Read calls <a href="index.html#Conn.Handshake">Conn.Handshake</a>, in order to prevent indefinite blocking a deadline
must be set for both Read and <a href="index.html#Conn.Write">Conn.Write</a> before Read is called when the handshake
has not yet completed. See <a href="index.html#Conn.SetDeadline">Conn.SetDeadline</a>, <a href="index.html#Conn.SetReadDeadline">Conn.SetReadDeadline</a>, and
<a href="index.html#Conn.SetWriteDeadline">Conn.SetWriteDeadline</a>.

				
				
				
			
				
				<h3 id="Conn.RemoteAddr">func (*Conn) <a href="../../../src/crypto/tls/conn.go?s=4797:4833#L125">RemoteAddr</a>
					<a class="permalink" href="index.html#Conn.RemoteAddr">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Conn">Conn</a>) RemoteAddr() <a href="../../net/index.html">net</a>.<a href="../../net/index.html#Addr">Addr</a></pre>
				<p>RemoteAddr returns the remote network address.

				
				
				
			
				
				<h3 id="Conn.SetDeadline">func (*Conn) <a href="../../../src/crypto/tls/conn.go?s=5131:5176#L132">SetDeadline</a>
					<a class="permalink" href="index.html#Conn.SetDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Conn">Conn</a>) SetDeadline(t <a href="../../time/index.html">time</a>.<a href="../../time/index.html#Time">Time</a>) <a href="../../builtin/index.html#error">error</a></pre>
				<p>SetDeadline sets the read and write deadlines associated with the connection.
A zero value for t means <a href="index.html#Conn.Read">Conn.Read</a> and <a href="index.html#Conn.Write">Conn.Write</a> will not time out.
After a Write has timed out, the TLS state is corrupt and all future writes will return the same error.

				
				
				
			
				
				<h3 id="Conn.SetReadDeadline">func (*Conn) <a href="../../../src/crypto/tls/conn.go?s=5343:5392#L138">SetReadDeadline</a>
					<a class="permalink" href="index.html#Conn.SetReadDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Conn">Conn</a>) SetReadDeadline(t <a href="../../time/index.html">time</a>.<a href="../../time/index.html#Time">Time</a>) <a href="../../builtin/index.html#error">error</a></pre>
				<p>SetReadDeadline sets the read deadline on the underlying connection.
A zero value for t means <a href="index.html#Conn.Read">Conn.Read</a> will not time out.

				
				
				
			
				
				<h3 id="Conn.SetWriteDeadline">func (*Conn) <a href="../../../src/crypto/tls/conn.go?s=5680:5730#L145">SetWriteDeadline</a>
					<a class="permalink" href="index.html#Conn.SetWriteDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Conn">Conn</a>) SetWriteDeadline(t <a href="../../time/index.html">time</a>.<a href="../../time/index.html#Time">Time</a>) <a href="../../builtin/index.html#error">error</a></pre>
				<p>SetWriteDeadline sets the write deadline on the underlying connection.
A zero value for t means <a href="index.html#Conn.Write">Conn.Write</a> will not time out.
After a <a href="index.html#Conn.Write">Conn.Write</a> has timed out, the TLS state is corrupt and all future writes will return the same error.

				
				
				
			
				
				<h3 id="Conn.VerifyHostname">func (*Conn) <a href="../../../src/crypto/tls/conn.go?s=51808:51856#L1643">VerifyHostname</a>
					<a class="permalink" href="index.html#Conn.VerifyHostname">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Conn">Conn</a>) VerifyHostname(host <a href="../../builtin/index.html#string">string</a>) <a href="../../builtin/index.html#error">error</a></pre>
				<p>VerifyHostname checks that the peer certificate chain is valid for
connecting to host. If so, it returns nil; if not, it returns an error
describing the problem.

				
				
				
			
				
				<h3 id="Conn.Write">func (*Conn) <a href="../../../src/crypto/tls/conn.go?s=37665:37708#L1171">Write</a>
					<a class="permalink" href="index.html#Conn.Write">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Conn">Conn</a>) Write(b []<a href="../../builtin/index.html#byte">byte</a>) (<a href="../../builtin/index.html#int">int</a>, <a href="../../builtin/index.html#error">error</a>)</pre>
				<p>Write writes data to the connection.
<p>As Write calls <a href="index.html#Conn.Handshake">Conn.Handshake</a>, in order to prevent indefinite blocking a deadline
must be set for both <a href="index.html#Conn.Read">Conn.Read</a> and Write before Write is called when the handshake
has not yet completed. See <a href="index.html#Conn.SetDeadline">Conn.SetDeadline</a>, <a href="index.html#Conn.SetReadDeadline">Conn.SetReadDeadline</a>, and
<a href="index.html#Conn.SetWriteDeadline">Conn.SetWriteDeadline</a>.

				
				
				
			
		
			
			
			<h2 id="ConnectionState">type <a href="../../../src/crypto/tls/common.go?s=7061:9737#L228">ConnectionState</a>
				<a class="permalink" href="index.html#ConnectionState">&#xb6;</a>
				
				
			</h2>
			<p>ConnectionState records basic TLS details about the connection.

			<pre>type ConnectionState struct {
<span id="ConnectionState.Version"></span>    <span class="comment">// Version is the TLS version used by the connection (e.g. VersionTLS12).</span>
    Version <a href="../../builtin/index.html#uint16">uint16</a>

<span id="ConnectionState.HandshakeComplete"></span>    <span class="comment">// HandshakeComplete is true if the handshake has concluded.</span>
    HandshakeComplete <a href="../../builtin/index.html#bool">bool</a>

<span id="ConnectionState.DidResume"></span>    <span class="comment">// DidResume is true if this connection was successfully resumed from a</span>
    <span class="comment">// previous session with a session ticket or similar mechanism.</span>
    DidResume <a href="../../builtin/index.html#bool">bool</a>

<span id="ConnectionState.CipherSuite"></span>    <span class="comment">// CipherSuite is the cipher suite negotiated for the connection (e.g.</span>
    <span class="comment">// TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_AES_128_GCM_SHA256).</span>
    CipherSuite <a href="../../builtin/index.html#uint16">uint16</a>

<span id="ConnectionState.NegotiatedProtocol"></span>    <span class="comment">// NegotiatedProtocol is the application protocol negotiated with ALPN.</span>
    NegotiatedProtocol <a href="../../builtin/index.html#string">string</a>

<span id="ConnectionState.NegotiatedProtocolIsMutual"></span>    <span class="comment">// NegotiatedProtocolIsMutual used to indicate a mutual NPN negotiation.</span>
    <span class="comment">//</span>
    <span class="comment">// Deprecated: this value is always true.</span>
    NegotiatedProtocolIsMutual <a href="../../builtin/index.html#bool">bool</a>

<span id="ConnectionState.ServerName"></span>    <span class="comment">// ServerName is the value of the Server Name Indication extension sent by</span>
    <span class="comment">// the client. It&#39;s available both on the server and on the client side.</span>
    ServerName <a href="../../builtin/index.html#string">string</a>

<span id="ConnectionState.PeerCertificates"></span>    <span class="comment">// PeerCertificates are the parsed certificates sent by the peer, in the</span>
    <span class="comment">// order in which they were sent. The first element is the leaf certificate</span>
    <span class="comment">// that the connection is verified against.</span>
    <span class="comment">//</span>
    <span class="comment">// On the client side, it can&#39;t be empty. On the server side, it can be</span>
    <span class="comment">// empty if Config.ClientAuth is not RequireAnyClientCert or</span>
    <span class="comment">// RequireAndVerifyClientCert.</span>
    <span class="comment">//</span>
    <span class="comment">// PeerCertificates and its contents should not be modified.</span>
    PeerCertificates []*<a href="../x509/index.html">x509</a>.<a href="../x509/index.html#Certificate">Certificate</a>

<span id="ConnectionState.VerifiedChains"></span>    <span class="comment">// VerifiedChains is a list of one or more chains where the first element is</span>
    <span class="comment">// PeerCertificates[0] and the last element is from Config.RootCAs (on the</span>
    <span class="comment">// client side) or Config.ClientCAs (on the server side).</span>
    <span class="comment">//</span>
    <span class="comment">// On the client side, it&#39;s set if Config.InsecureSkipVerify is false. On</span>
    <span class="comment">// the server side, it&#39;s set if Config.ClientAuth is VerifyClientCertIfGiven</span>
    <span class="comment">// (and the peer provided a certificate) or RequireAndVerifyClientCert.</span>
    <span class="comment">//</span>
    <span class="comment">// VerifiedChains and its contents should not be modified.</span>
    VerifiedChains [][]*<a href="../x509/index.html">x509</a>.<a href="../x509/index.html#Certificate">Certificate</a>

<span id="ConnectionState.SignedCertificateTimestamps"></span>    <span class="comment">// SignedCertificateTimestamps is a list of SCTs provided by the peer</span>
    <span class="comment">// through the TLS handshake for the leaf certificate, if any.</span>
    SignedCertificateTimestamps [][]<a href="../../builtin/index.html#byte">byte</a>

<span id="ConnectionState.OCSPResponse"></span>    <span class="comment">// OCSPResponse is a stapled Online Certificate Status Protocol (OCSP)</span>
    <span class="comment">// response provided by the peer for the leaf certificate, if any.</span>
    OCSPResponse []<a href="../../builtin/index.html#byte">byte</a>

<span id="ConnectionState.TLSUnique"></span>    <span class="comment">// TLSUnique contains the &#34;tls-unique&#34; channel binding value (see RFC 5929,</span>
    <span class="comment">// Section 3). This value will be nil for TLS 1.3 connections and for</span>
    <span class="comment">// resumed connections that don&#39;t support Extended Master Secret (RFC 7627).</span>
    TLSUnique []<a href="../../builtin/index.html#byte">byte</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="ConnectionState.ExportKeyingMaterial">func (*ConnectionState) <a href="../../../src/crypto/tls/common.go?s=10360:10465#L304">ExportKeyingMaterial</a>
					<a class="permalink" href="index.html#ConnectionState.ExportKeyingMaterial">&#xb6;</a>
					
					
				</h3>
				<pre>func (cs *<a href="index.html#ConnectionState">ConnectionState</a>) ExportKeyingMaterial(label <a href="../../builtin/index.html#string">string</a>, context []<a href="../../builtin/index.html#byte">byte</a>, length <a href="../../builtin/index.html#int">int</a>) ([]<a href="../../builtin/index.html#byte">byte</a>, <a href="../../builtin/index.html#error">error</a>)</pre>
				<p>ExportKeyingMaterial returns length bytes of exported key material in a new
slice as defined in RFC 5705. If context is nil, it is not used as part of
the seed. If the connection was set to allow renegotiation via
Config.Renegotiation, or if the connections supports neither TLS 1.3 nor
Extended Master Secret, this function will return an error.
<p>Exporting key material without Extended Master Secret or TLS 1.3 was disabled
in Go 1.22 due to security issues (see the Security Considerations sections
of RFC 5705 and RFC 7627), but can be re-enabled with the GODEBUG setting
tlsunsafeekm=1.

				
				
				
			
		
			
			
			<h2 id="CurveID">type <a href="../../../src/crypto/tls/common.go?s=3997:4016#L128">CurveID</a>
				<a class="permalink" href="index.html#CurveID">&#xb6;</a>
				
				
			</h2>
			<p>CurveID is the type of a TLS identifier for an elliptic curve. See
<a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8">https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8</a>.
<p>In TLS 1.3, this type is called NamedGroup, but at this time this library
only supports Elliptic Curve based groups. See RFC 8446, Section 4.2.7.

			<pre>type CurveID <a href="../../builtin/index.html#uint16">uint16</a></pre>

			
				
				<pre>const (
    <span id="CurveP256">CurveP256</span> <a href="index.html#CurveID">CurveID</a> = 23
    <span id="CurveP384">CurveP384</span> <a href="index.html#CurveID">CurveID</a> = 24
    <span id="CurveP521">CurveP521</span> <a href="index.html#CurveID">CurveID</a> = 25
    <span id="X25519">X25519</span>    <a href="index.html#CurveID">CurveID</a> = 29
)</pre>
			

			

			
			
			

			

			
				
				<h3 id="CurveID.String">func (CurveID) <a href="../../../src/crypto/tls/common_string.go?s=2283:2315#L75">String</a>
					<a class="permalink" href="index.html#CurveID.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (i <a href="index.html#CurveID">CurveID</a>) String() <a href="../../builtin/index.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Dialer">type <a href="../../../src/crypto/tls/tls.go?s=5377:5791#L166">Dialer</a>
				<a class="permalink" href="index.html#Dialer">&#xb6;</a>
				
				
			</h2>
			<p>Dialer dials TLS connections given a configuration and a Dialer for the
underlying connection.

			<pre>type Dialer struct {
<span id="Dialer.NetDialer"></span>    <span class="comment">// NetDialer is the optional dialer to use for the TLS connections&#39;</span>
    <span class="comment">// underlying TCP connections.</span>
    <span class="comment">// A nil NetDialer is equivalent to the net.Dialer zero value.</span>
    NetDialer *<a href="../../net/index.html">net</a>.<a href="../../net/index.html#Dialer">Dialer</a>

<span id="Dialer.Config"></span>    <span class="comment">// Config is the TLS configuration to use for new connections.</span>
    <span class="comment">// A nil configuration is equivalent to the zero</span>
    <span class="comment">// configuration; see the documentation of Config for the</span>
    <span class="comment">// defaults.</span>
    Config *<a href="index.html#Config">Config</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Dialer.Dial">func (*Dialer) <a href="../../../src/crypto/tls/tls.go?s=6080:6141#L186">Dial</a>
					<a class="permalink" href="index.html#Dialer.Dial">&#xb6;</a>
					
					
				</h3>
				<pre>func (d *<a href="index.html#Dialer">Dialer</a>) Dial(network, addr <a href="../../builtin/index.html#string">string</a>) (<a href="../../net/index.html">net</a>.<a href="../../net/index.html#Conn">Conn</a>, <a href="../../builtin/index.html#error">error</a>)</pre>
				<p>Dial connects to the given network address and initiates a TLS
handshake, returning the resulting TLS connection.
<p>The returned <a href="index.html#Conn">Conn</a>, if any, will always be of type *<a href="index.html#Conn">Conn</a>.
<p>Dial uses context.Background internally; to specify the context,
use <a href="index.html#Dialer.DialContext">Dialer.DialContext</a>.

				
				
				
			
				
				<h3 id="Dialer.DialContext">func (*Dialer) <a href="../../../src/crypto/tls/tls.go?s=6743:6832#L206">DialContext</a>
					<a class="permalink" href="index.html#Dialer.DialContext">&#xb6;</a>
					
					
				</h3>
				<pre>func (d *<a href="index.html#Dialer">Dialer</a>) DialContext(ctx <a href="../../context/index.html">context</a>.<a href="../../context/index.html#Context">Context</a>, network, addr <a href="../../builtin/index.html#string">string</a>) (<a href="../../net/index.html">net</a>.<a href="../../net/index.html#Conn">Conn</a>, <a href="../../builtin/index.html#error">error</a>)</pre>
				<p>DialContext connects to the given network address and initiates a TLS
handshake, returning the resulting TLS connection.
<p>The provided Context must be non-nil. If the context expires before
the connection is complete, an error is returned. Once successfully
connected, any expiration of the context will not affect the
connection.
<p>The returned <a href="index.html#Conn">Conn</a>, if any, will always be of type *<a href="index.html#Conn">Conn</a>.

				
				
				
			
		
			
			
			<h2 id="QUICConfig">type <a href="../../../src/crypto/tls/quic.go?s=1138:1183#L40">QUICConfig</a>
				<a class="permalink" href="index.html#QUICConfig">&#xb6;</a>
				
				
			</h2>
			<p>A QUICConfig configures a <a href="index.html#QUICConn">QUICConn</a>.

			<pre>type QUICConfig struct {
<span id="QUICConfig.TLSConfig"></span>    TLSConfig *<a href="index.html#Config">Config</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="QUICConn">type <a href="../../../src/crypto/tls/quic.go?s=1034:1095#L33">QUICConn</a>
				<a class="permalink" href="index.html#QUICConn">&#xb6;</a>
				
				
			</h2>
			<p>A QUICConn represents a connection which uses a QUIC implementation as the underlying
transport as described in RFC 9001.
<p>Methods of QUICConn are not safe for concurrent use.

			<pre>type QUICConn struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="QUICClient">func <a href="../../../src/crypto/tls/quic.go?s=4401:4446#L132">QUICClient</a>
					<a class="permalink" href="index.html#QUICClient">&#xb6;</a>
					
					
				</h3>
				<pre>func QUICClient(config *<a href="index.html#QUICConfig">QUICConfig</a>) *<a href="index.html#QUICConn">QUICConn</a></pre>
				<p>QUICClient returns a new TLS client side connection using QUICTransport as the
underlying transport. The config cannot be nil.
<p>The config&apos;s MinVersion must be at least TLS 1.3.

				
				
			
				
				<h3 id="QUICServer">func <a href="../../../src/crypto/tls/quic.go?s=4692:4737#L140">QUICServer</a>
					<a class="permalink" href="index.html#QUICServer">&#xb6;</a>
					
					
				</h3>
				<pre>func QUICServer(config *<a href="index.html#QUICConfig">QUICConfig</a>) *<a href="index.html#QUICConn">QUICConn</a></pre>
				<p>QUICServer returns a new TLS server side connection using QUICTransport as the
underlying transport. The config cannot be nil.
<p>The config&apos;s MinVersion must be at least TLS 1.3.

				
				
			

			
				
				<h3 id="QUICConn.Close">func (*QUICConn) <a href="../../../src/crypto/tls/quic.go?s=6362:6394#L195">Close</a>
					<a class="permalink" href="index.html#QUICConn.Close">&#xb6;</a>
					
					
				</h3>
				<pre>func (q *<a href="index.html#QUICConn">QUICConn</a>) Close() <a href="../../builtin/index.html#error">error</a></pre>
				<p>Close closes the connection and stops any in-progress handshake.

				
				
				
			
				
				<h3 id="QUICConn.ConnectionState">func (*QUICConn) <a href="../../../src/crypto/tls/quic.go?s=8670:8722#L269">ConnectionState</a>
					<a class="permalink" href="index.html#QUICConn.ConnectionState">&#xb6;</a>
					
					
				</h3>
				<pre>func (q *<a href="index.html#QUICConn">QUICConn</a>) ConnectionState() <a href="index.html#ConnectionState">ConnectionState</a></pre>
				<p>ConnectionState returns basic TLS details about the connection.

				
				
				
			
				
				<h3 id="QUICConn.HandleData">func (*QUICConn) <a href="../../../src/crypto/tls/quic.go?s=6745:6820#L208">HandleData</a>
					<a class="permalink" href="index.html#QUICConn.HandleData">&#xb6;</a>
					
					
				</h3>
				<pre>func (q *<a href="index.html#QUICConn">QUICConn</a>) HandleData(level <a href="index.html#QUICEncryptionLevel">QUICEncryptionLevel</a>, data []<a href="../../builtin/index.html#byte">byte</a>) <a href="../../builtin/index.html#error">error</a></pre>
				<p>HandleData handles handshake bytes received from the peer.
It may produce connection events, which may be read with <a href="index.html#QUICConn.NextEvent">QUICConn.NextEvent</a>.

				
				
				
			
				
				<h3 id="QUICConn.NextEvent">func (*QUICConn) <a href="../../../src/crypto/tls/quic.go?s=5771:5811#L176">NextEvent</a>
					<a class="permalink" href="index.html#QUICConn.NextEvent">&#xb6;</a>
					
					
				</h3>
				<pre>func (q *<a href="index.html#QUICConn">QUICConn</a>) NextEvent() <a href="index.html#QUICEvent">QUICEvent</a></pre>
				<p>NextEvent returns the next event occurring on the connection.
It returns an event with a Kind of <a href="index.html#QUICNoEvent">QUICNoEvent</a> when no events are available.

				
				
				
			
				
				<h3 id="QUICConn.SendSessionTicket">func (*QUICConn) <a href="../../../src/crypto/tls/quic.go?s=8092:8165#L253">SendSessionTicket</a>
					<a class="permalink" href="index.html#QUICConn.SendSessionTicket">&#xb6;</a>
					
					
				</h3>
				<pre>func (q *<a href="index.html#QUICConn">QUICConn</a>) SendSessionTicket(opts <a href="index.html#QUICSessionTicketOptions">QUICSessionTicketOptions</a>) <a href="../../builtin/index.html#error">error</a></pre>
				<p>SendSessionTicket sends a session ticket to the client.
It produces connection events, which may be read with <a href="index.html#QUICConn.NextEvent">QUICConn.NextEvent</a>.
Currently, it can only be called once.

				
				
				
			
				
				<h3 id="QUICConn.SetTransportParameters">func (*QUICConn) <a href="../../../src/crypto/tls/quic.go?s=9005:9061#L277">SetTransportParameters</a>
					<a class="permalink" href="index.html#QUICConn.SetTransportParameters">&#xb6;</a>
					
					
				</h3>
				<pre>func (q *<a href="index.html#QUICConn">QUICConn</a>) SetTransportParameters(params []<a href="../../builtin/index.html#byte">byte</a>)</pre>
				<p>SetTransportParameters sets the transport parameters to send to the peer.
<p>Server connections may delay setting the transport parameters until after
receiving the client&apos;s transport parameters. See <a href="index.html#QUICTransportParametersRequired">QUICTransportParametersRequired</a>.

				
				
				
			
				
				<h3 id="QUICConn.Start">func (*QUICConn) <a href="../../../src/crypto/tls/quic.go?s=5191:5242#L159">Start</a>
					<a class="permalink" href="index.html#QUICConn.Start">&#xb6;</a>
					
					
				</h3>
				<pre>func (q *<a href="index.html#QUICConn">QUICConn</a>) Start(ctx <a href="../../context/index.html">context</a>.<a href="../../context/index.html#Context">Context</a>) <a href="../../builtin/index.html#error">error</a></pre>
				<p>Start starts the client or server handshake protocol.
It may produce connection events, which may be read with <a href="index.html#QUICConn.NextEvent">QUICConn.NextEvent</a>.
<p>Start must be called at most once.

				
				
				
			
		
			
			
			<h2 id="QUICEncryptionLevel">type <a href="../../../src/crypto/tls/quic.go?s=311:339#L5">QUICEncryptionLevel</a>
				<a class="permalink" href="index.html#QUICEncryptionLevel">&#xb6;</a>
				
				
			</h2>
			<p>QUICEncryptionLevel represents a QUIC encryption level used to transmit
handshake messages.

			<pre>type QUICEncryptionLevel <a href="../../builtin/index.html#int">int</a></pre>

			

			

			
			
			

			

			
				
				<h3 id="QUICEncryptionLevel.String">func (QUICEncryptionLevel) <a href="../../../src/crypto/tls/quic.go?s=496:540#L14">String</a>
					<a class="permalink" href="index.html#QUICEncryptionLevel.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (l <a href="index.html#QUICEncryptionLevel">QUICEncryptionLevel</a>) String() <a href="../../builtin/index.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="QUICEvent">type <a href="../../../src/crypto/tls/quic.go?s=2884:3292#L90">QUICEvent</a>
				<a class="permalink" href="index.html#QUICEvent">&#xb6;</a>
				
				
			</h2>
			<p>A QUICEvent is an event occurring on a QUIC connection.
<p>The type of event is specified by the Kind field.
The contents of the other fields are kind-specific.

			<pre>type QUICEvent struct {
<span id="QUICEvent.Kind"></span>    Kind <a href="index.html#QUICEventKind">QUICEventKind</a>

    <span class="comment">// Set for QUICSetReadSecret, QUICSetWriteSecret, and QUICWriteData.</span>
<span id="QUICEvent.Level"></span>    Level <a href="index.html#QUICEncryptionLevel">QUICEncryptionLevel</a>

    <span class="comment">// Set for QUICTransportParameters, QUICSetReadSecret, QUICSetWriteSecret, and QUICWriteData.</span>
    <span class="comment">// The contents are owned by crypto/tls, and are valid until the next NextEvent call.</span>
<span id="QUICEvent.Data"></span>    Data []<a href="../../builtin/index.html#byte">byte</a>

    <span class="comment">// Set for QUICSetReadSecret and QUICSetWriteSecret.</span>
<span id="QUICEvent.Suite"></span>    Suite <a href="../../builtin/index.html#uint16">uint16</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="QUICEventKind">type <a href="../../../src/crypto/tls/quic.go?s=1249:1271#L45">QUICEventKind</a>
				<a class="permalink" href="index.html#QUICEventKind">&#xb6;</a>
				
				
			</h2>
			<p>A QUICEventKind is a type of operation on a QUIC connection.

			<pre>type QUICEventKind <a href="../../builtin/index.html#int">int</a></pre>

			
				
				<pre>const (
    <span class="comment">// QUICNoEvent indicates that there are no events available.</span>
    <span id="QUICNoEvent">QUICNoEvent</span> <a href="index.html#QUICEventKind">QUICEventKind</a> = <a href="../../builtin/index.html#iota">iota</a>

    <span class="comment">// QUICSetReadSecret and QUICSetWriteSecret provide the read and write</span>
    <span class="comment">// secrets for a given encryption level.</span>
    <span class="comment">// QUICEvent.Level, QUICEvent.Data, and QUICEvent.Suite are set.</span>
    <span class="comment">//</span>
    <span class="comment">// Secrets for the Initial encryption level are derived from the initial</span>
    <span class="comment">// destination connection ID, and are not provided by the QUICConn.</span>
    <span id="QUICSetReadSecret">QUICSetReadSecret</span>
    <span id="QUICSetWriteSecret">QUICSetWriteSecret</span>

    <span class="comment">// QUICWriteData provides data to send to the peer in CRYPTO frames.</span>
    <span class="comment">// QUICEvent.Data is set.</span>
    <span id="QUICWriteData">QUICWriteData</span>

    <span class="comment">// QUICTransportParameters provides the peer&#39;s QUIC transport parameters.</span>
    <span class="comment">// QUICEvent.Data is set.</span>
    <span id="QUICTransportParameters">QUICTransportParameters</span>

    <span class="comment">// QUICTransportParametersRequired indicates that the caller must provide</span>
    <span class="comment">// QUIC transport parameters to send to the peer. The caller should set</span>
    <span class="comment">// the transport parameters with QUICConn.SetTransportParameters and call</span>
    <span class="comment">// QUICConn.NextEvent again.</span>
    <span class="comment">//</span>
    <span class="comment">// If transport parameters are set before calling QUICConn.Start, the</span>
    <span class="comment">// connection will never generate a QUICTransportParametersRequired event.</span>
    <span id="QUICTransportParametersRequired">QUICTransportParametersRequired</span>

    <span class="comment">// QUICRejectedEarlyData indicates that the server rejected 0-RTT data even</span>
    <span class="comment">// if we offered it. It&#39;s returned before QUICEncryptionLevelApplication</span>
    <span class="comment">// keys are returned.</span>
    <span id="QUICRejectedEarlyData">QUICRejectedEarlyData</span>

    <span class="comment">// QUICHandshakeDone indicates that the TLS handshake has completed.</span>
    <span id="QUICHandshakeDone">QUICHandshakeDone</span>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="QUICSessionTicketOptions">type <a href="../../../src/crypto/tls/quic.go?s=7788:7910#L245">QUICSessionTicketOptions</a>
				<a class="permalink" href="index.html#QUICSessionTicketOptions">&#xb6;</a>
				
				
			</h2>
			
			<pre>type QUICSessionTicketOptions struct {
<span id="QUICSessionTicketOptions.EarlyData"></span>    <span class="comment">// EarlyData specifies whether the ticket may be used for 0-RTT.</span>
    EarlyData <a href="../../builtin/index.html#bool">bool</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="RecordHeaderError">type <a href="../../../src/crypto/tls/conn.go?s=18294:18765#L555">RecordHeaderError</a>
				<a class="permalink" href="index.html#RecordHeaderError">&#xb6;</a>
				
				
			</h2>
			<p>RecordHeaderError is returned when a TLS record header is invalid.

			<pre>type RecordHeaderError struct {
<span id="RecordHeaderError.Msg"></span>    <span class="comment">// Msg contains a human readable string that describes the error.</span>
    Msg <a href="../../builtin/index.html#string">string</a>
<span id="RecordHeaderError.RecordHeader"></span>    <span class="comment">// RecordHeader contains the five bytes of TLS record header that</span>
    <span class="comment">// triggered the error.</span>
    RecordHeader [5]<a href="../../builtin/index.html#byte">byte</a>
<span id="RecordHeaderError.Conn"></span>    <span class="comment">// Conn provides the underlying net.Conn in the case that a client</span>
    <span class="comment">// sent an initial handshake that didn&#39;t look like TLS.</span>
    <span class="comment">// It is nil if there&#39;s already been a handshake or a TLS alert has</span>
    <span class="comment">// been written to the connection.</span>
    Conn <a href="../../net/index.html">net</a>.<a href="../../net/index.html#Conn">Conn</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="RecordHeaderError.Error">func (RecordHeaderError) <a href="../../../src/crypto/tls/conn.go?s=18767:18808#L568">Error</a>
					<a class="permalink" href="index.html#RecordHeaderError.Error">&#xb6;</a>
					
					
				</h3>
				<pre>func (e <a href="index.html#RecordHeaderError">RecordHeaderError</a>) Error() <a href="../../builtin/index.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="RenegotiationSupport">type <a href="../../../src/crypto/tls/common.go?s=18405:18434#L498">RenegotiationSupport</a>
				<a class="permalink" href="index.html#RenegotiationSupport">&#xb6;</a>
				
				
			</h2>
			<p>RenegotiationSupport enumerates the different levels of support for TLS
renegotiation. TLS renegotiation is the act of performing subsequent
handshakes on a connection after the first. This significantly complicates
the state machine and has been the source of numerous, subtle security
issues. Initiating a renegotiation is not supported, but support for
accepting renegotiation requests may be enabled.
<p>Even when enabled, the server may not change its identity between handshakes
(i.e. the leaf certificate must be the same). Additionally, concurrent
handshake and application data flow is not permitted so renegotiation can
only be used with protocols that synchronise with the renegotiation, such as
HTTPS.
<p>Renegotiation is not defined in TLS 1.3.

			<pre>type RenegotiationSupport <a href="../../builtin/index.html#int">int</a></pre>

			
				
				<pre>const (
    <span class="comment">// RenegotiateNever disables renegotiation.</span>
    <span id="RenegotiateNever">RenegotiateNever</span> <a href="index.html#RenegotiationSupport">RenegotiationSupport</a> = <a href="../../builtin/index.html#iota">iota</a>

    <span class="comment">// RenegotiateOnceAsClient allows a remote server to request</span>
    <span class="comment">// renegotiation once per connection.</span>
    <span id="RenegotiateOnceAsClient">RenegotiateOnceAsClient</span>

    <span class="comment">// RenegotiateFreelyAsClient allows a remote server to repeatedly</span>
    <span class="comment">// request renegotiation.</span>
    <span id="RenegotiateFreelyAsClient">RenegotiateFreelyAsClient</span>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="SessionState">type <a href="../../../src/crypto/tls/ticket.go?s=373:3187#L11">SessionState</a>
				<a class="permalink" href="index.html#SessionState">&#xb6;</a>
				
				
			</h2>
			<p>A SessionState is a resumable session.

			<pre>type SessionState struct {

<span id="SessionState.Extra"></span>    <span class="comment">// Extra is ignored by crypto/tls, but is encoded by [SessionState.Bytes]</span>
    <span class="comment">// and parsed by [ParseSessionState].</span>
    <span class="comment">//</span>
    <span class="comment">// This allows [Config.UnwrapSession]/[Config.WrapSession] and</span>
    <span class="comment">// [ClientSessionCache] implementations to store and retrieve additional</span>
    <span class="comment">// data alongside this session.</span>
    <span class="comment">//</span>
    <span class="comment">// To allow different layers in a protocol stack to share this field,</span>
    <span class="comment">// applications must only append to it, not replace it, and must use entries</span>
    <span class="comment">// that can be recognized even if out of order (for example, by starting</span>
    <span class="comment">// with an id and version prefix).</span>
    Extra [][]<a href="../../builtin/index.html#byte">byte</a>

<span id="SessionState.EarlyData"></span>    <span class="comment">// EarlyData indicates whether the ticket can be used for 0-RTT in a QUIC</span>
    <span class="comment">// connection. The application may set this to false if it is true to</span>
    <span class="comment">// decline to offer 0-RTT even if supported.</span>
    EarlyData <a href="../../builtin/index.html#bool">bool</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="ParseSessionState">func <a href="../../../src/crypto/tls/ticket.go?s=5347:5405#L171">ParseSessionState</a>
					<a class="permalink" href="index.html#ParseSessionState">&#xb6;</a>
					
					
				</h3>
				<pre>func ParseSessionState(data []<a href="../../builtin/index.html#byte">byte</a>) (*<a href="index.html#SessionState">SessionState</a>, <a href="../../builtin/index.html#error">error</a>)</pre>
				<p>ParseSessionState parses a <a href="index.html#SessionState">SessionState</a> encoded by <a href="index.html#SessionState.Bytes">SessionState.Bytes</a>.

				
				
			

			
				
				<h3 id="SessionState.Bytes">func (*SessionState) <a href="../../../src/crypto/tls/ticket.go?s=3511:3557#L97">Bytes</a>
					<a class="permalink" href="index.html#SessionState.Bytes">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#SessionState">SessionState</a>) Bytes() ([]<a href="../../builtin/index.html#byte">byte</a>, <a href="../../builtin/index.html#error">error</a>)</pre>
				<p>Bytes encodes the session, including any private fields, so that it can be
parsed by <a href="index.html#ParseSessionState">ParseSessionState</a>. The encoding contains secret values critical
to the security of future and possibly past sessions.
<p>The specific encoding should be considered opaque and may change incompatibly
between Go versions.

				
				
				
			
		
			
			
			<h2 id="SignatureScheme">type <a href="../../../src/crypto/tls/common.go?s=13200:13227#L369">SignatureScheme</a>
				<a class="permalink" href="index.html#SignatureScheme">&#xb6;</a>
				
				
			</h2>
			<p>SignatureScheme identifies a signature algorithm supported by TLS. See
RFC 8446, Section 4.2.3.

			<pre>type SignatureScheme <a href="../../builtin/index.html#uint16">uint16</a></pre>

			
				
				<pre>const (
    <span class="comment">// RSASSA-PKCS1-v1_5 algorithms.</span>
    <span id="PKCS1WithSHA256">PKCS1WithSHA256</span> <a href="index.html#SignatureScheme">SignatureScheme</a> = 0x0401
    <span id="PKCS1WithSHA384">PKCS1WithSHA384</span> <a href="index.html#SignatureScheme">SignatureScheme</a> = 0x0501
    <span id="PKCS1WithSHA512">PKCS1WithSHA512</span> <a href="index.html#SignatureScheme">SignatureScheme</a> = 0x0601

    <span class="comment">// RSASSA-PSS algorithms with public key OID rsaEncryption.</span>
    <span id="PSSWithSHA256">PSSWithSHA256</span> <a href="index.html#SignatureScheme">SignatureScheme</a> = 0x0804
    <span id="PSSWithSHA384">PSSWithSHA384</span> <a href="index.html#SignatureScheme">SignatureScheme</a> = 0x0805
    <span id="PSSWithSHA512">PSSWithSHA512</span> <a href="index.html#SignatureScheme">SignatureScheme</a> = 0x0806

    <span class="comment">// ECDSA algorithms. Only constrained to a specific curve in TLS 1.3.</span>
    <span id="ECDSAWithP256AndSHA256">ECDSAWithP256AndSHA256</span> <a href="index.html#SignatureScheme">SignatureScheme</a> = 0x0403
    <span id="ECDSAWithP384AndSHA384">ECDSAWithP384AndSHA384</span> <a href="index.html#SignatureScheme">SignatureScheme</a> = 0x0503
    <span id="ECDSAWithP521AndSHA512">ECDSAWithP521AndSHA512</span> <a href="index.html#SignatureScheme">SignatureScheme</a> = 0x0603

    <span class="comment">// EdDSA algorithms.</span>
    <span id="Ed25519">Ed25519</span> <a href="index.html#SignatureScheme">SignatureScheme</a> = 0x0807

    <span class="comment">// Legacy signature and hash algorithms for TLS 1.2.</span>
    <span id="PKCS1WithSHA1">PKCS1WithSHA1</span> <a href="index.html#SignatureScheme">SignatureScheme</a> = 0x0201
    <span id="ECDSAWithSHA1">ECDSAWithSHA1</span> <a href="index.html#SignatureScheme">SignatureScheme</a> = 0x0203
)</pre>
			

			

			
			
			

			

			
				
				<h3 id="SignatureScheme.String">func (SignatureScheme) <a href="../../../src/crypto/tls/common_string.go?s=1210:1250#L31">String</a>
					<a class="permalink" href="index.html#SignatureScheme.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (i <a href="index.html#SignatureScheme">SignatureScheme</a>) String() <a href="../../builtin/index.html#string">string</a></pre>
				
				
				
				
			
		
	

	
		
			<h2 id="pkg-note-BUG">Bugs</h2>
			<ul style="list-style: none; padding: 0;">
			
			<li><a href="../../../src/crypto/tls/tls.go?s=286:556#L1" style="float: left;">&#x261e;</a> <p>The crypto/tls package only implements some countermeasures
against Lucky13 attacks on CBC-mode encryption, and only on SHA1
variants. See <a href="http://www.isg.rhul.ac.uk/tls/TLStiming.pdf">http://www.isg.rhul.ac.uk/tls/TLStiming.pdf</a> and
<a href="https://www.imperialviolet.org/2013/02/04/luckythirteen.html">https://www.imperialviolet.org/2013/02/04/luckythirteen.html</a>.
</li>
			
			</ul>
		
	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	<div class="pkg-dir">
		<table>
			<tr>
				<th class="pkg-name">Name</th>
				<th class="pkg-synopsis">Synopsis</th>
			</tr>

			
			<tr>
				<td colspan="2"><a href="../index.html">..</a></td>
			</tr>
			

			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="fipsonly/index.html">fipsonly</a>
					</td>
				
					<td class="pkg-synopsis">
						Package fipsonly restricts all TLS configuration to FIPS-approved settings.
					</td>
				</tr>
			
		</table>
	</div>



<div id="footer">
Build version go1.22.2.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:8080/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
