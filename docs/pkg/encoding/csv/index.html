<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>csv - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="../../../lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="../../../lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.22.2";</script>
<script src="../../../lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="../../../index.html">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="../../../index.html">GoDoc</a></div>
<a href="index.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:8080/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package csv
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "encoding/csv"</code></dd>
			</dl>
			<dl>
			<dd><a href="index.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="index.html#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="index.html#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package csv reads and writes comma-separated values (CSV) files.
There are many kinds of CSV files; this package supports the format
described in RFC 4180.
<p>A csv file contains zero or more records of one or more fields per record.
Each record is separated by the newline character. The final record may
optionally be followed by a newline character.
<pre>field1,field2,field3
</pre>
<p>White space is considered part of a field.
<p>Carriage returns before newline characters are silently removed.
<p>Blank lines are ignored. A line with only whitespace characters (excluding
the ending newline character) is not considered a blank line.
<p>Fields which start and stop with the quote character &quot; are called
quoted-fields. The beginning and ending quote are not part of the
field.
<p>The source:
<pre>normal string,&quot;quoted-field&quot;
</pre>
<p>results in the fields
<pre>{`normal string`, `quoted-field`}
</pre>
<p>Within a quoted-field a quote character followed by a second quote
character is considered a single quote.
<pre>&quot;the &quot;&quot;word&quot;&quot; is true&quot;,&quot;a &quot;&quot;quoted-field&quot;&quot;&quot;
</pre>
<p>results in
<pre>{`the &quot;word&quot; is true`, `a &quot;quoted-field&quot;`}
</pre>
<p>Newlines and commas may be included in a quoted-field
<pre>&quot;Multi-line
field&quot;,&quot;comma is ,&quot;
</pre>
<p>results in
<pre>{`Multi-line
field`, `comma is ,`}
</pre>

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
				<dd><a href="index.html#pkg-variables">Variables</a></dd>
			
			
			
				
				<dd><a href="index.html#ParseError">type ParseError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ParseError.Error">func (e *ParseError) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ParseError.Unwrap">func (e *ParseError) Unwrap() error</a></dd>
				
			
				
				<dd><a href="index.html#Reader">type Reader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewReader">func NewReader(r io.Reader) *Reader</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Reader.FieldPos">func (r *Reader) FieldPos(field int) (line, column int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Reader.InputOffset">func (r *Reader) InputOffset() int64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Reader.Read">func (r *Reader) Read() (record []string, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Reader.ReadAll">func (r *Reader) ReadAll() (records [][]string, err error)</a></dd>
				
			
				
				<dd><a href="index.html#Writer">type Writer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewWriter">func NewWriter(w io.Writer) *Writer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Writer.Error">func (w *Writer) Error() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Writer.Flush">func (w *Writer) Flush()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Writer.Write">func (w *Writer) Write(record []string) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Writer.WriteAll">func (w *Writer) WriteAll(records [][]string) error</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="index.html#example_Reader">Reader</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Reader_ReadAll">Reader.ReadAll</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Reader_options">Reader (Options)</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Writer">Writer</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Writer_WriteAll">Writer.WriteAll</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="../../../src/encoding/csv/reader.go">reader.go</a>
			
				<a href="../../../src/encoding/csv/writer.go">writer.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<p>These are the errors that can be returned in [ParseError.Err].

				<pre>var (
    <span id="ErrBareQuote">ErrBareQuote</span>  = <a href="../../errors/index.html">errors</a>.<a href="../../errors/index.html#New">New</a>(&#34;bare \&#34; in non-quoted-field&#34;)
    <span id="ErrQuote">ErrQuote</span>      = <a href="../../errors/index.html">errors</a>.<a href="../../errors/index.html#New">New</a>(&#34;extraneous or missing \&#34; in quoted-field&#34;)
    <span id="ErrFieldCount">ErrFieldCount</span> = <a href="../../errors/index.html">errors</a>.<a href="../../errors/index.html#New">New</a>(&#34;wrong number of fields&#34;)

    <span class="comment">// Deprecated: ErrTrailingComma is no longer used.</span>
    <span id="ErrTrailingComma">ErrTrailingComma</span> = <a href="../../errors/index.html">errors</a>.<a href="../../errors/index.html#New">New</a>(&#34;extra delimiter at end of line&#34;)
)</pre>
			
		
		
		
			
			
			<h2 id="ParseError">type <a href="../../../src/encoding/csv/reader.go?s=1673:1908#L56">ParseError</a>
				<a class="permalink" href="index.html#ParseError">&#xb6;</a>
				
				
			</h2>
			<p>A ParseError is returned for parsing errors.
Line and column numbers are 1-indexed.

			<pre>type ParseError struct {
<span id="ParseError.StartLine"></span>    StartLine <a href="../../builtin/index.html#int">int</a>   <span class="comment">// Line where the record starts</span>
<span id="ParseError.Line"></span>    Line      <a href="../../builtin/index.html#int">int</a>   <span class="comment">// Line where the error occurred</span>
<span id="ParseError.Column"></span>    Column    <a href="../../builtin/index.html#int">int</a>   <span class="comment">// Column (1-based byte index) where the error occurred</span>
<span id="ParseError.Err"></span>    Err       <a href="../../builtin/index.html#error">error</a> <span class="comment">// The actual error</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="ParseError.Error">func (*ParseError) <a href="../../../src/encoding/csv/reader.go?s=1910:1945#L63">Error</a>
					<a class="permalink" href="index.html#ParseError.Error">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="index.html#ParseError">ParseError</a>) Error() <a href="../../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="ParseError.Unwrap">func (*ParseError) <a href="../../../src/encoding/csv/reader.go?s=2280:2315#L73">Unwrap</a>
					<a class="permalink" href="index.html#ParseError.Unwrap">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="index.html#ParseError">ParseError</a>) Unwrap() <a href="../../builtin/index.html#error">error</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Reader">type <a href="../../../src/encoding/csv/reader.go?s=3386:6014#L100">Reader</a>
				<a class="permalink" href="index.html#Reader">&#xb6;</a>
				
				
			</h2>
			<p>A Reader reads records from a CSV-encoded file.
<p>As returned by <a href="index.html#NewReader">NewReader</a>, a Reader expects input conforming to RFC 4180.
The exported fields can be changed to customize the details before the
first call to <a href="index.html#Reader.Read">Reader.Read</a> or <a href="index.html#Reader.ReadAll">Reader.ReadAll</a>.
<p>The Reader converts all \r\n sequences in its input to plain \n,
including in multiline field values, so that the returned data does
not depend on which line-ending convention an input file uses.

			<pre>type Reader struct {
<span id="Reader.Comma"></span>    <span class="comment">// Comma is the field delimiter.</span>
    <span class="comment">// It is set to comma (&#39;,&#39;) by NewReader.</span>
    <span class="comment">// Comma must be a valid rune and must not be \r, \n,</span>
    <span class="comment">// or the Unicode replacement character (0xFFFD).</span>
    Comma <a href="../../builtin/index.html#rune">rune</a>

<span id="Reader.Comment"></span>    <span class="comment">// Comment, if not 0, is the comment character. Lines beginning with the</span>
    <span class="comment">// Comment character without preceding whitespace are ignored.</span>
    <span class="comment">// With leading whitespace the Comment character becomes part of the</span>
    <span class="comment">// field, even if TrimLeadingSpace is true.</span>
    <span class="comment">// Comment must be a valid rune and must not be \r, \n,</span>
    <span class="comment">// or the Unicode replacement character (0xFFFD).</span>
    <span class="comment">// It must also not be equal to Comma.</span>
    Comment <a href="../../builtin/index.html#rune">rune</a>

<span id="Reader.FieldsPerRecord"></span>    <span class="comment">// FieldsPerRecord is the number of expected fields per record.</span>
    <span class="comment">// If FieldsPerRecord is positive, Read requires each record to</span>
    <span class="comment">// have the given number of fields. If FieldsPerRecord is 0, Read sets it to</span>
    <span class="comment">// the number of fields in the first record, so that future records must</span>
    <span class="comment">// have the same field count. If FieldsPerRecord is negative, no check is</span>
    <span class="comment">// made and records may have a variable number of fields.</span>
    FieldsPerRecord <a href="../../builtin/index.html#int">int</a>

    <span class="comment">// If LazyQuotes is true, a quote may appear in an unquoted field and a</span>
    <span class="comment">// non-doubled quote may appear in a quoted field.</span>
<span id="Reader.LazyQuotes"></span>    LazyQuotes <a href="../../builtin/index.html#bool">bool</a>

    <span class="comment">// If TrimLeadingSpace is true, leading white space in a field is ignored.</span>
    <span class="comment">// This is done even if the field delimiter, Comma, is white space.</span>
<span id="Reader.TrimLeadingSpace"></span>    TrimLeadingSpace <a href="../../builtin/index.html#bool">bool</a>

<span id="Reader.ReuseRecord"></span>    <span class="comment">// ReuseRecord controls whether calls to Read may return a slice sharing</span>
    <span class="comment">// the backing array of the previous call&#39;s returned slice for performance.</span>
    <span class="comment">// By default, each call to Read returns newly allocated memory owned by the caller.</span>
    ReuseRecord <a href="../../builtin/index.html#bool">bool</a>

    <span class="comment">// Deprecated: TrailingComma is no longer used.</span>
<span id="Reader.TrailingComma"></span>    TrailingComma <a href="../../builtin/index.html#bool">bool</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_Reader" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">in := `first_name,last_name,username
&#34;Rob&#34;,&#34;Pike&#34;,rob
Ken,Thompson,ken
&#34;Robert&#34;,&#34;Griesemer&#34;,&#34;gri&#34;
`
r := csv.NewReader(strings.NewReader(in))

for {
    record, err := r.Read()
    if err == io.EOF {
        break
    }
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println(record)
}
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[first_name last_name username]
[Rob Pike rob]
[Ken Thompson ken]
[Robert Griesemer gri]
</pre>
			
		
	</div>
</div>
<div id="example_Reader_options" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (Options)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (Options)</span></p>
		<p>This example shows how csv.Reader can be configured to handle other
types of CSV files.
</p>
		
		
			<p>Code:</p>
			<pre class="code">in := `first_name;last_name;username
&#34;Rob&#34;;&#34;Pike&#34;;rob
# lines beginning with a # character are ignored
Ken;Thompson;ken
&#34;Robert&#34;;&#34;Griesemer&#34;;&#34;gri&#34;
`
r := csv.NewReader(strings.NewReader(in))
r.Comma = &#39;;&#39;
r.Comment = &#39;#&#39;

records, err := r.ReadAll()
if err != nil {
    log.Fatal(err)
}

fmt.Print(records)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[[first_name last_name username] [Rob Pike rob] [Ken Thompson ken] [Robert Griesemer gri]]
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewReader">func <a href="../../../src/encoding/csv/reader.go?s=6069:6104#L170">NewReader</a>
					<a class="permalink" href="index.html#NewReader">&#xb6;</a>
					
					
				</h3>
				<pre>func NewReader(r <a href="../../io/index.html">io</a>.<a href="../../io/index.html#Reader">Reader</a>) *<a href="index.html#Reader">Reader</a></pre>
				<p>NewReader returns a new Reader that reads from r.

				
				
			

			
				
				<h3 id="Reader.FieldPos">func (*Reader) <a href="../../../src/encoding/csv/reader.go?s=7224:7279#L202">FieldPos</a>
					<a class="permalink" href="index.html#Reader.FieldPos">&#xb6;</a>
					
					
				</h3>
				<pre>func (r *<a href="index.html#Reader">Reader</a>) FieldPos(field <a href="../../builtin/index.html#int">int</a>) (line, column <a href="../../builtin/index.html#int">int</a>)</pre>
				<p>FieldPos returns the line and column corresponding to
the start of the field with the given index in the slice most recently
returned by <a href="index.html#Reader.Read">Reader.Read</a>. Numbering of lines and columns starts at 1;
columns are counted in bytes, not runes.
<p>If this is called with an out-of-bounds index, it panics.

				
				
				
			
				
				<h3 id="Reader.InputOffset">func (*Reader) <a href="../../../src/encoding/csv/reader.go?s=7636:7672#L213">InputOffset</a>
					<a class="permalink" href="index.html#Reader.InputOffset">&#xb6;</a>
					
					
				</h3>
				<pre>func (r *<a href="index.html#Reader">Reader</a>) InputOffset() <a href="../../builtin/index.html#int64">int64</a></pre>
				<p>InputOffset returns the input stream byte offset of the current reader
position. The offset gives the location of the end of the most recently
read row and the beginning of the next row.

				
				
				
			
				
				<h3 id="Reader.Read">func (*Reader) <a href="../../../src/encoding/csv/reader.go?s=6699:6751#L186">Read</a>
					<a class="permalink" href="index.html#Reader.Read">&#xb6;</a>
					
					
				</h3>
				<pre>func (r *<a href="index.html#Reader">Reader</a>) Read() (record []<a href="../../builtin/index.html#string">string</a>, err <a href="../../builtin/index.html#error">error</a>)</pre>
				<p>Read reads one record (a slice of fields) from r.
If the record has an unexpected number of fields,
Read returns the record along with the error <a href="index.html#ErrFieldCount">ErrFieldCount</a>.
If the record contains a field that cannot be parsed,
Read returns a partial record along with the parse error.
The partial record contains all fields read before the error.
If there is no data left to be read, Read returns nil, <a href="http://localhost:8080/io#EOF">io.EOF</a>.
If [Reader.ReuseRecord] is true, the returned slice may be shared
between multiple calls to Read.

				
				
				
			
				
				<h3 id="Reader.ReadAll">func (*Reader) <a href="../../../src/encoding/csv/reader.go?s=8054:8112#L227">ReadAll</a>
					<a class="permalink" href="index.html#Reader.ReadAll">&#xb6;</a>
					
					
				</h3>
				<pre>func (r *<a href="index.html#Reader">Reader</a>) ReadAll() (records [][]<a href="../../builtin/index.html#string">string</a>, err <a href="../../builtin/index.html#error">error</a>)</pre>
				<p>ReadAll reads all the remaining records from r.
Each record is a slice of fields.
A successful call returns err == nil, not err == <a href="http://localhost:8080/io#EOF">io.EOF</a>. Because ReadAll is
defined to read until EOF, it does not treat end of file as an error to be
reported.

				
				<div id="example_Reader_ReadAll" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">in := `first_name,last_name,username
&#34;Rob&#34;,&#34;Pike&#34;,rob
Ken,Thompson,ken
&#34;Robert&#34;,&#34;Griesemer&#34;,&#34;gri&#34;
`
r := csv.NewReader(strings.NewReader(in))

records, err := r.ReadAll()
if err != nil {
    log.Fatal(err)
}

fmt.Print(records)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[[first_name last_name username] [Rob Pike rob] [Ken Thompson ken] [Robert Griesemer gri]]
</pre>
			
		
	</div>
</div>

				
			
		
			
			
			<h2 id="Writer">type <a href="../../../src/encoding/csv/writer.go?s=977:1138#L22">Writer</a>
				<a class="permalink" href="index.html#Writer">&#xb6;</a>
				
				
			</h2>
			<p>A Writer writes records using CSV encoding.
<p>As returned by <a href="index.html#NewWriter">NewWriter</a>, a Writer writes records terminated by a
newline and uses &apos;,&apos; as the field delimiter. The exported fields can be
changed to customize the details before
the first call to <a href="index.html#Writer.Write">Writer.Write</a> or <a href="index.html#Writer.WriteAll">Writer.WriteAll</a>.
<p>[Writer.Comma] is the field delimiter.
<p>If [Writer.UseCRLF] is true,
the Writer ends each output line with \r\n instead of \n.
<p>The writes of individual records are buffered.
After all data has been written, the client should call the
<a href="index.html#Writer.Flush">Writer.Flush</a> method to guarantee all data has been forwarded to
the underlying <a href="http://localhost:8080/io#Writer">io.Writer</a>.  Any errors that occurred should
be checked by calling the <a href="index.html#Writer.Error">Writer.Error</a> method.

			<pre>type Writer struct {
<span id="Writer.Comma"></span>    Comma   <a href="../../builtin/index.html#rune">rune</a> <span class="comment">// Field delimiter (set to &#39;,&#39; by NewWriter)</span>
<span id="Writer.UseCRLF"></span>    UseCRLF <a href="../../builtin/index.html#bool">bool</a> <span class="comment">// True to use \r\n as the line terminator</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_Writer" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">records := [][]string{
    {&#34;first_name&#34;, &#34;last_name&#34;, &#34;username&#34;},
    {&#34;Rob&#34;, &#34;Pike&#34;, &#34;rob&#34;},
    {&#34;Ken&#34;, &#34;Thompson&#34;, &#34;ken&#34;},
    {&#34;Robert&#34;, &#34;Griesemer&#34;, &#34;gri&#34;},
}

w := csv.NewWriter(os.Stdout)

for _, record := range records {
    if err := w.Write(record); err != nil {
        log.Fatalln(&#34;error writing record to csv:&#34;, err)
    }
}

<span class="comment">// Write any buffered data to the underlying writer (standard output).</span>
w.Flush()

if err := w.Error(); err != nil {
    log.Fatal(err)
}
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">first_name,last_name,username
Rob,Pike,rob
Ken,Thompson,ken
Robert,Griesemer,gri
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewWriter">func <a href="../../../src/encoding/csv/writer.go?s=1192:1227#L29">NewWriter</a>
					<a class="permalink" href="index.html#NewWriter">&#xb6;</a>
					
					
				</h3>
				<pre>func NewWriter(w <a href="../../io/index.html">io</a>.<a href="../../io/index.html#Writer">Writer</a>) *<a href="index.html#Writer">Writer</a></pre>
				<p>NewWriter returns a new Writer that writes to w.

				
				
			

			
				
				<h3 id="Writer.Error">func (*Writer) <a href="../../../src/encoding/csv/writer.go?s=3299:3329#L121">Error</a>
					<a class="permalink" href="index.html#Writer.Error">&#xb6;</a>
					
					
				</h3>
				<pre>func (w *<a href="index.html#Writer">Writer</a>) Error() <a href="../../builtin/index.html#error">error</a></pre>
				<p>Error reports any error that has occurred during
a previous <a href="index.html#Writer.Write">Writer.Write</a> or <a href="index.html#Writer.Flush">Writer.Flush</a>.

				
				
				
			
				
				<h3 id="Writer.Flush">func (*Writer) <a href="../../../src/encoding/csv/writer.go?s=3156:3180#L115">Flush</a>
					<a class="permalink" href="index.html#Writer.Flush">&#xb6;</a>
					
					
				</h3>
				<pre>func (w *<a href="index.html#Writer">Writer</a>) Flush()</pre>
				<p>Flush writes any buffered data to the underlying <a href="http://localhost:8080/io#Writer">io.Writer</a>.
To check if an error occurred during Flush, call <a href="index.html#Writer.Error">Writer.Error</a>.

				
				
				
			
				
				<h3 id="Writer.Write">func (*Writer) <a href="../../../src/encoding/csv/writer.go?s=1578:1623#L40">Write</a>
					<a class="permalink" href="index.html#Writer.Write">&#xb6;</a>
					
					
				</h3>
				<pre>func (w *<a href="index.html#Writer">Writer</a>) Write(record []<a href="../../builtin/index.html#string">string</a>) <a href="../../builtin/index.html#error">error</a></pre>
				<p>Write writes a single CSV record to w along with any necessary quoting.
A record is a slice of strings with each string being one field.
Writes are buffered, so <a href="index.html#Writer.Flush">Writer.Flush</a> must eventually be called to ensure
that the record is written to the underlying <a href="http://localhost:8080/io#Writer">io.Writer</a>.

				
				
				
			
				
				<h3 id="Writer.WriteAll">func (*Writer) <a href="../../../src/encoding/csv/writer.go?s=3509:3560#L128">WriteAll</a>
					<a class="permalink" href="index.html#Writer.WriteAll">&#xb6;</a>
					
					
				</h3>
				<pre>func (w *<a href="index.html#Writer">Writer</a>) WriteAll(records [][]<a href="../../builtin/index.html#string">string</a>) <a href="../../builtin/index.html#error">error</a></pre>
				<p>WriteAll writes multiple CSV records to w using <a href="index.html#Writer.Write">Writer.Write</a> and
then calls <a href="index.html#Writer.Flush">Writer.Flush</a>, returning any error from the Flush.

				
				<div id="example_Writer_WriteAll" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">records := [][]string{
    {&#34;first_name&#34;, &#34;last_name&#34;, &#34;username&#34;},
    {&#34;Rob&#34;, &#34;Pike&#34;, &#34;rob&#34;},
    {&#34;Ken&#34;, &#34;Thompson&#34;, &#34;ken&#34;},
    {&#34;Robert&#34;, &#34;Griesemer&#34;, &#34;gri&#34;},
}

w := csv.NewWriter(os.Stdout)
w.WriteAll(records) <span class="comment">// calls Flush internally</span>

if err := w.Error(); err != nil {
    log.Fatalln(&#34;error writing csv:&#34;, err)
}
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">first_name,last_name,username
Rob,Pike,rob
Ken,Thompson,ken
Robert,Griesemer,gri
</pre>
			
		
	</div>
</div>

				
			
		
	

	







<div id="footer">
Build version go1.22.2.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:8080/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
