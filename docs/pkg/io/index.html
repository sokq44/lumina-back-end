<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>io - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="../../lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="../../lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.22.2";</script>
<script src="../../lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="../../index.html">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="../../index.html">GoDoc</a></div>
<a href="index.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:8080/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package io
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "io"</code></dd>
			</dl>
			<dl>
			<dd><a href="index.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="index.html#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="index.html#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
				<dd><a href="index.html#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package io provides basic interfaces to I/O primitives.
Its primary job is to wrap existing implementations of such primitives,
such as those in package os, into shared public interfaces that
abstract the functionality, plus some other related primitives.
<p>Because these interfaces and primitives wrap lower-level operations with
various implementations, unless otherwise informed clients should not
assume they are safe for parallel execution.

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="index.html#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="index.html#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="index.html#Copy">func Copy(dst Writer, src Reader) (written int64, err error)</a></dd>
			
				
				<dd><a href="index.html#CopyBuffer">func CopyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error)</a></dd>
			
				
				<dd><a href="index.html#CopyN">func CopyN(dst Writer, src Reader, n int64) (written int64, err error)</a></dd>
			
				
				<dd><a href="index.html#Pipe">func Pipe() (*PipeReader, *PipeWriter)</a></dd>
			
				
				<dd><a href="index.html#ReadAll">func ReadAll(r Reader) ([]byte, error)</a></dd>
			
				
				<dd><a href="index.html#ReadAtLeast">func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)</a></dd>
			
				
				<dd><a href="index.html#ReadFull">func ReadFull(r Reader, buf []byte) (n int, err error)</a></dd>
			
				
				<dd><a href="index.html#WriteString">func WriteString(w Writer, s string) (n int, err error)</a></dd>
			
			
				
				<dd><a href="index.html#ByteReader">type ByteReader</a></dd>
				
				
			
				
				<dd><a href="index.html#ByteScanner">type ByteScanner</a></dd>
				
				
			
				
				<dd><a href="index.html#ByteWriter">type ByteWriter</a></dd>
				
				
			
				
				<dd><a href="index.html#Closer">type Closer</a></dd>
				
				
			
				
				<dd><a href="index.html#LimitedReader">type LimitedReader</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#LimitedReader.Read">func (l *LimitedReader) Read(p []byte) (n int, err error)</a></dd>
				
			
				
				<dd><a href="index.html#OffsetWriter">type OffsetWriter</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewOffsetWriter">func NewOffsetWriter(w WriterAt, off int64) *OffsetWriter</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#OffsetWriter.Seek">func (o *OffsetWriter) Seek(offset int64, whence int) (int64, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#OffsetWriter.Write">func (o *OffsetWriter) Write(p []byte) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#OffsetWriter.WriteAt">func (o *OffsetWriter) WriteAt(p []byte, off int64) (n int, err error)</a></dd>
				
			
				
				<dd><a href="index.html#PipeReader">type PipeReader</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PipeReader.Close">func (r *PipeReader) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PipeReader.CloseWithError">func (r *PipeReader) CloseWithError(err error) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PipeReader.Read">func (r *PipeReader) Read(data []byte) (n int, err error)</a></dd>
				
			
				
				<dd><a href="index.html#PipeWriter">type PipeWriter</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PipeWriter.Close">func (w *PipeWriter) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PipeWriter.CloseWithError">func (w *PipeWriter) CloseWithError(err error) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PipeWriter.Write">func (w *PipeWriter) Write(data []byte) (n int, err error)</a></dd>
				
			
				
				<dd><a href="index.html#ReadCloser">type ReadCloser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NopCloser">func NopCloser(r Reader) ReadCloser</a></dd>
				
				
			
				
				<dd><a href="index.html#ReadSeekCloser">type ReadSeekCloser</a></dd>
				
				
			
				
				<dd><a href="index.html#ReadSeeker">type ReadSeeker</a></dd>
				
				
			
				
				<dd><a href="index.html#ReadWriteCloser">type ReadWriteCloser</a></dd>
				
				
			
				
				<dd><a href="index.html#ReadWriteSeeker">type ReadWriteSeeker</a></dd>
				
				
			
				
				<dd><a href="index.html#ReadWriter">type ReadWriter</a></dd>
				
				
			
				
				<dd><a href="index.html#Reader">type Reader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#LimitReader">func LimitReader(r Reader, n int64) Reader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MultiReader">func MultiReader(readers ...Reader) Reader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#TeeReader">func TeeReader(r Reader, w Writer) Reader</a></dd>
				
				
			
				
				<dd><a href="index.html#ReaderAt">type ReaderAt</a></dd>
				
				
			
				
				<dd><a href="index.html#ReaderFrom">type ReaderFrom</a></dd>
				
				
			
				
				<dd><a href="index.html#RuneReader">type RuneReader</a></dd>
				
				
			
				
				<dd><a href="index.html#RuneScanner">type RuneScanner</a></dd>
				
				
			
				
				<dd><a href="index.html#SectionReader">type SectionReader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewSectionReader">func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#SectionReader.Outer">func (s *SectionReader) Outer() (r ReaderAt, off int64, n int64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#SectionReader.Read">func (s *SectionReader) Read(p []byte) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#SectionReader.ReadAt">func (s *SectionReader) ReadAt(p []byte, off int64) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#SectionReader.Seek">func (s *SectionReader) Seek(offset int64, whence int) (int64, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#SectionReader.Size">func (s *SectionReader) Size() int64</a></dd>
				
			
				
				<dd><a href="index.html#Seeker">type Seeker</a></dd>
				
				
			
				
				<dd><a href="index.html#StringWriter">type StringWriter</a></dd>
				
				
			
				
				<dd><a href="index.html#WriteCloser">type WriteCloser</a></dd>
				
				
			
				
				<dd><a href="index.html#WriteSeeker">type WriteSeeker</a></dd>
				
				
			
				
				<dd><a href="index.html#Writer">type Writer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MultiWriter">func MultiWriter(writers ...Writer) Writer</a></dd>
				
				
			
				
				<dd><a href="index.html#WriterAt">type WriterAt</a></dd>
				
				
			
				
				<dd><a href="index.html#WriterTo">type WriterTo</a></dd>
				
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="index.html#example_Copy">Copy</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_CopyBuffer">CopyBuffer</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_CopyN">CopyN</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_LimitReader">LimitReader</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_MultiReader">MultiReader</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_MultiWriter">MultiWriter</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Pipe">Pipe</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_ReadAll">ReadAll</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_ReadAtLeast">ReadAtLeast</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_ReadFull">ReadFull</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_SectionReader">SectionReader</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_SectionReader_Read">SectionReader.Read</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_SectionReader_ReadAt">SectionReader.ReadAt</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_SectionReader_Seek">SectionReader.Seek</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_SectionReader_Size">SectionReader.Size</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_TeeReader">TeeReader</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_WriteString">WriteString</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="../../src/io/io.go">io.go</a>
			
				<a href="../../src/io/multi.go">multi.go</a>
			
				<a href="../../src/io/pipe.go">pipe.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
			<h2 id="pkg-constants">Constants</h2>
			
				<p>Seek whence values.

				<pre>const (
    <span id="SeekStart">SeekStart</span>   = 0 <span class="comment">// seek relative to the origin of the file</span>
    <span id="SeekCurrent">SeekCurrent</span> = 1 <span class="comment">// seek relative to the current offset</span>
    <span id="SeekEnd">SeekEnd</span>     = 2 <span class="comment">// seek relative to the end</span>
)</pre>
			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<p>EOF is the error returned by Read when no more input is available.
(Read must return EOF itself, not an error wrapping EOF,
because callers will test for EOF using ==.)
Functions should return EOF only to signal a graceful end of input.
If the EOF occurs unexpectedly in a structured data stream,
the appropriate error is either <a href="index.html#ErrUnexpectedEOF">ErrUnexpectedEOF</a> or some other error
giving more detail.

				<pre>var <span id="EOF">EOF</span> = <a href="../errors/index.html">errors</a>.<a href="../errors/index.html#New">New</a>(&#34;EOF&#34;)</pre>
			
				<p>ErrClosedPipe is the error used for read or write operations on a closed pipe.

				<pre>var <span id="ErrClosedPipe">ErrClosedPipe</span> = <a href="../errors/index.html">errors</a>.<a href="../errors/index.html#New">New</a>(&#34;io: read/write on closed pipe&#34;)</pre>
			
				<p>ErrNoProgress is returned by some clients of a <a href="index.html#Reader">Reader</a> when
many calls to Read have failed to return any data or error,
usually the sign of a broken <a href="index.html#Reader">Reader</a> implementation.

				<pre>var <span id="ErrNoProgress">ErrNoProgress</span> = <a href="../errors/index.html">errors</a>.<a href="../errors/index.html#New">New</a>(&#34;multiple Read calls return no data or error&#34;)</pre>
			
				<p>ErrShortBuffer means that a read required a longer buffer than was provided.

				<pre>var <span id="ErrShortBuffer">ErrShortBuffer</span> = <a href="../errors/index.html">errors</a>.<a href="../errors/index.html#New">New</a>(&#34;short buffer&#34;)</pre>
			
				<p>ErrShortWrite means that a write accepted fewer bytes than requested
but failed to return an explicit error.

				<pre>var <span id="ErrShortWrite">ErrShortWrite</span> = <a href="../errors/index.html">errors</a>.<a href="../errors/index.html#New">New</a>(&#34;short write&#34;)</pre>
			
				<p>ErrUnexpectedEOF means that EOF was encountered in the
middle of reading a fixed-size block or data structure.

				<pre>var <span id="ErrUnexpectedEOF">ErrUnexpectedEOF</span> = <a href="../errors/index.html">errors</a>.<a href="../errors/index.html#New">New</a>(&#34;unexpected EOF&#34;)</pre>
			
		
		
			
			
			<h2 id="Copy">func <a href="../../src/io/io.go?s=13934:13994#L377">Copy</a>
				<a class="permalink" href="index.html#Copy">&#xb6;</a>
				
				
			</h2>
			<pre>func Copy(dst <a href="index.html#Writer">Writer</a>, src <a href="index.html#Reader">Reader</a>) (written <a href="../builtin/index.html#int64">int64</a>, err <a href="../builtin/index.html#error">error</a>)</pre>
			<p>Copy copies from src to dst until either EOF is reached
on src or an error occurs. It returns the number of bytes
copied and the first error encountered while copying, if any.
<p>A successful Copy returns err == nil, not err == EOF.
Because Copy is defined to read from src until EOF, it does
not treat an EOF from Read as an error to be reported.
<p>If src implements <a href="index.html#WriterTo">WriterTo</a>,
the copy is implemented by calling src.WriteTo(dst).
Otherwise, if dst implements <a href="index.html#ReaderFrom">ReaderFrom</a>,
the copy is implemented by calling dst.ReadFrom(src).

			<div id="example_Copy" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">r := strings.NewReader(&#34;some io.Reader stream to be read\n&#34;)

if _, err := io.Copy(os.Stdout, r); err != nil {
    log.Fatal(err)
}

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">some io.Reader stream to be read
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="CopyBuffer">func <a href="../../src/io/io.go?s=14393:14471#L388">CopyBuffer</a>
				<a class="permalink" href="index.html#CopyBuffer">&#xb6;</a>
				
				
			</h2>
			<pre>func CopyBuffer(dst <a href="index.html#Writer">Writer</a>, src <a href="index.html#Reader">Reader</a>, buf []<a href="../builtin/index.html#byte">byte</a>) (written <a href="../builtin/index.html#int64">int64</a>, err <a href="../builtin/index.html#error">error</a>)</pre>
			<p>CopyBuffer is identical to Copy except that it stages through the
provided buffer (if one is required) rather than allocating a
temporary one. If buf is nil, one is allocated; otherwise if it has
zero length, CopyBuffer panics.
<p>If either src implements <a href="index.html#WriterTo">WriterTo</a> or dst implements <a href="index.html#ReaderFrom">ReaderFrom</a>,
buf will not be used to perform the copy.

			<div id="example_CopyBuffer" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">r1 := strings.NewReader(&#34;first reader\n&#34;)
r2 := strings.NewReader(&#34;second reader\n&#34;)
buf := make([]byte, 8)

<span class="comment">// buf is used here...</span>
if _, err := io.CopyBuffer(os.Stdout, r1, buf); err != nil {
    log.Fatal(err)
}

<span class="comment">// ... reused here also. No need to allocate an extra buffer.</span>
if _, err := io.CopyBuffer(os.Stdout, r2, buf); err != nil {
    log.Fatal(err)
}

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">first reader
second reader
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="CopyN">func <a href="../../src/io/io.go?s=13113:13183#L353">CopyN</a>
				<a class="permalink" href="index.html#CopyN">&#xb6;</a>
				
				
			</h2>
			<pre>func CopyN(dst <a href="index.html#Writer">Writer</a>, src <a href="index.html#Reader">Reader</a>, n <a href="../builtin/index.html#int64">int64</a>) (written <a href="../builtin/index.html#int64">int64</a>, err <a href="../builtin/index.html#error">error</a>)</pre>
			<p>CopyN copies n bytes (or until an error) from src to dst.
It returns the number of bytes copied and the earliest
error encountered while copying.
On return, written == n if and only if err == nil.
<p>If dst implements <a href="index.html#ReaderFrom">ReaderFrom</a>, the copy is implemented using it.

			<div id="example_CopyN" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">r := strings.NewReader(&#34;some io.Reader stream to be read&#34;)

if _, err := io.CopyN(os.Stdout, r, 4); err != nil {
    log.Fatal(err)
}

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">some
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Pipe">func <a href="../../src/io/pipe.go?s=5048:5086#L185">Pipe</a>
				<a class="permalink" href="index.html#Pipe">&#xb6;</a>
				
				
			</h2>
			<pre>func Pipe() (*<a href="index.html#PipeReader">PipeReader</a>, *<a href="index.html#PipeWriter">PipeWriter</a>)</pre>
			<p>Pipe creates a synchronous in-memory pipe.
It can be used to connect code expecting an <a href="index.html#Reader">io.Reader</a>
with code expecting an <a href="index.html#Writer">io.Writer</a>.
<p>Reads and Writes on the pipe are matched one to one
except when multiple Reads are needed to consume a single Write.
That is, each Write to the <a href="index.html#PipeWriter">PipeWriter</a> blocks until it has satisfied
one or more Reads from the <a href="index.html#PipeReader">PipeReader</a> that fully consume
the written data.
The data is copied directly from the Write to the corresponding
Read (or Reads); there is no internal buffering.
<p>It is safe to call Read and Write in parallel with each other or with Close.
Parallel calls to Read and parallel calls to Write are also safe:
the individual calls will be gated sequentially.

			<div id="example_Pipe" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">r, w := io.Pipe()

go func() {
    fmt.Fprint(w, &#34;some io.Reader stream to be read\n&#34;)
    w.Close()
}()

if _, err := io.Copy(os.Stdout, r); err != nil {
    log.Fatal(err)
}

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">some io.Reader stream to be read
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="ReadAll">func <a href="../../src/io/io.go?s=21815:21853#L699">ReadAll</a>
				<a class="permalink" href="index.html#ReadAll">&#xb6;</a>
				
				
			</h2>
			<pre>func ReadAll(r <a href="index.html#Reader">Reader</a>) ([]<a href="../builtin/index.html#byte">byte</a>, <a href="../builtin/index.html#error">error</a>)</pre>
			<p>ReadAll reads from r until an error or EOF and returns the data it read.
A successful call returns err == nil, not err == EOF. Because ReadAll is
defined to read from src until EOF, it does not treat an EOF from Read
as an error to be reported.

			<div id="example_ReadAll" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">r := strings.NewReader(&#34;Go is a general-purpose language designed with systems programming in mind.&#34;)

b, err := io.ReadAll(r)
if err != nil {
    log.Fatal(err)
}

fmt.Printf(&#34;%s&#34;, b)

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">Go is a general-purpose language designed with systems programming in mind.
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="ReadAtLeast">func <a href="../../src/io/io.go?s=12004:12070#L319">ReadAtLeast</a>
				<a class="permalink" href="index.html#ReadAtLeast">&#xb6;</a>
				
				
			</h2>
			<pre>func ReadAtLeast(r <a href="index.html#Reader">Reader</a>, buf []<a href="../builtin/index.html#byte">byte</a>, min <a href="../builtin/index.html#int">int</a>) (n <a href="../builtin/index.html#int">int</a>, err <a href="../builtin/index.html#error">error</a>)</pre>
			<p>ReadAtLeast reads from r into buf until it has read at least min bytes.
It returns the number of bytes copied and an error if fewer bytes were read.
The error is EOF only if no bytes were read.
If an EOF happens after reading fewer than min bytes,
ReadAtLeast returns <a href="index.html#ErrUnexpectedEOF">ErrUnexpectedEOF</a>.
If min is greater than the length of buf, ReadAtLeast returns <a href="index.html#ErrShortBuffer">ErrShortBuffer</a>.
On return, n &gt;= min if and only if err == nil.
If r returns an error having read at least min bytes, the error is dropped.

			<div id="example_ReadAtLeast" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">r := strings.NewReader(&#34;some io.Reader stream to be read\n&#34;)

buf := make([]byte, 14)
if _, err := io.ReadAtLeast(r, buf, 4); err != nil {
    log.Fatal(err)
}
fmt.Printf(&#34;%s\n&#34;, buf)

<span class="comment">// buffer smaller than minimal read size.</span>
shortBuf := make([]byte, 3)
if _, err := io.ReadAtLeast(r, shortBuf, 4); err != nil {
    fmt.Println(&#34;error:&#34;, err)
}

<span class="comment">// minimal read size bigger than io.Reader stream</span>
longBuf := make([]byte, 64)
if _, err := io.ReadAtLeast(r, longBuf, 64); err != nil {
    fmt.Println(&#34;error:&#34;, err)
}

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">some io.Reader
error: short buffer
error: unexpected EOF
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="ReadFull">func <a href="../../src/io/io.go?s=12734:12788#L343">ReadFull</a>
				<a class="permalink" href="index.html#ReadFull">&#xb6;</a>
				
				
			</h2>
			<pre>func ReadFull(r <a href="index.html#Reader">Reader</a>, buf []<a href="../builtin/index.html#byte">byte</a>) (n <a href="../builtin/index.html#int">int</a>, err <a href="../builtin/index.html#error">error</a>)</pre>
			<p>ReadFull reads exactly len(buf) bytes from r into buf.
It returns the number of bytes copied and an error if fewer bytes were read.
The error is EOF only if no bytes were read.
If an EOF happens after reading some but not all the bytes,
ReadFull returns <a href="index.html#ErrUnexpectedEOF">ErrUnexpectedEOF</a>.
On return, n == len(buf) if and only if err == nil.
If r returns an error having read at least len(buf) bytes, the error is dropped.

			<div id="example_ReadFull" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">r := strings.NewReader(&#34;some io.Reader stream to be read\n&#34;)

buf := make([]byte, 4)
if _, err := io.ReadFull(r, buf); err != nil {
    log.Fatal(err)
}
fmt.Printf(&#34;%s\n&#34;, buf)

<span class="comment">// minimal read size bigger than io.Reader stream</span>
longBuf := make([]byte, 64)
if _, err := io.ReadFull(r, longBuf); err != nil {
    fmt.Println(&#34;error:&#34;, err)
}

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">some
error: unexpected EOF
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="WriteString">func <a href="../../src/io/io.go?s=11334:11389#L304">WriteString</a>
				<a class="permalink" href="index.html#WriteString">&#xb6;</a>
				
				
			</h2>
			<pre>func WriteString(w <a href="index.html#Writer">Writer</a>, s <a href="../builtin/index.html#string">string</a>) (n <a href="../builtin/index.html#int">int</a>, err <a href="../builtin/index.html#error">error</a>)</pre>
			<p>WriteString writes the contents of the string s to w, which accepts a slice of bytes.
If w implements <a href="index.html#StringWriter">StringWriter</a>, [StringWriter.WriteString] is invoked directly.
Otherwise, [Writer.Write] is called exactly once.

			<div id="example_WriteString" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">if _, err := io.WriteString(os.Stdout, &#34;Hello World&#34;); err != nil {
    log.Fatal(err)
}

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">Hello World
</pre>
			
		
	</div>
</div>

			

		
		
			
			
			<h2 id="ByteReader">type <a href="../../src/io/io.go?s=9445:9500#L252">ByteReader</a>
				<a class="permalink" href="index.html#ByteReader">&#xb6;</a>
				
				
			</h2>
			<p>ByteReader is the interface that wraps the ReadByte method.
<p>ReadByte reads and returns the next byte from the input or
any error encountered. If ReadByte returns an error, no input
byte was consumed, and the returned byte value is undefined.
<p>ReadByte provides an efficient interface for byte-at-time
processing. A <a href="index.html#Reader">Reader</a> that does not implement  ByteReader
can be wrapped using bufio.NewReader to add this method.

			<pre>type ByteReader interface {
    ReadByte() (<a href="../builtin/index.html#byte">byte</a>, <a href="../builtin/index.html#error">error</a>)
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="ByteScanner">type <a href="../../src/io/io.go?s=9959:10021#L264">ByteScanner</a>
				<a class="permalink" href="index.html#ByteScanner">&#xb6;</a>
				
				
			</h2>
			<p>ByteScanner is the interface that adds the UnreadByte method to the
basic ReadByte method.
<p>UnreadByte causes the next call to ReadByte to return the last byte read.
If the last operation was not a successful call to ReadByte, UnreadByte may
return an error, unread the last byte read (or the byte prior to the
last-unread byte), or (in implementations that support the <a href="index.html#Seeker">Seeker</a> interface)
seek to one byte before the current offset.

			<pre>type ByteScanner interface {
    <a href="index.html#ByteReader">ByteReader</a>
    UnreadByte() <a href="../builtin/index.html#error">error</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="ByteWriter">type <a href="../../src/io/io.go?s=10087:10141#L270">ByteWriter</a>
				<a class="permalink" href="index.html#ByteWriter">&#xb6;</a>
				
				
			</h2>
			<p>ByteWriter is the interface that wraps the WriteByte method.

			<pre>type ByteWriter interface {
    WriteByte(c <a href="../builtin/index.html#byte">byte</a>) <a href="../builtin/index.html#error">error</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Closer">type <a href="../../src/io/io.go?s=4420:4460#L97">Closer</a>
				<a class="permalink" href="index.html#Closer">&#xb6;</a>
				
				
			</h2>
			<p>Closer is the interface that wraps the basic Close method.
<p>The behavior of Close after the first call is undefined.
Specific implementations may document their own behavior.

			<pre>type Closer interface {
    Close() <a href="../builtin/index.html#error">error</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="LimitedReader">type <a href="../../src/io/io.go?s=16116:16209#L457">LimitedReader</a>
				<a class="permalink" href="index.html#LimitedReader">&#xb6;</a>
				
				
			</h2>
			<p>A LimitedReader reads from R but limits the amount of
data returned to just N bytes. Each call to Read
updates N to reflect the new amount remaining.
Read returns EOF when N &lt;= 0 or when the underlying R returns EOF.

			<pre>type LimitedReader struct {
<span id="LimitedReader.R"></span>    R <a href="index.html#Reader">Reader</a> <span class="comment">// underlying reader</span>
<span id="LimitedReader.N"></span>    N <a href="../builtin/index.html#int64">int64</a>  <span class="comment">// max bytes remaining</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="LimitedReader.Read">func (*LimitedReader) <a href="../../src/io/io.go?s=16211:16268#L462">Read</a>
					<a class="permalink" href="index.html#LimitedReader.Read">&#xb6;</a>
					
					
				</h3>
				<pre>func (l *<a href="index.html#LimitedReader">LimitedReader</a>) Read(p []<a href="../builtin/index.html#byte">byte</a>) (n <a href="../builtin/index.html#int">int</a>, err <a href="../builtin/index.html#error">error</a>)</pre>
				
				
				
				
			
		
			
			
			<h2 id="OffsetWriter">type <a href="../../src/io/io.go?s=18653:18765#L560">OffsetWriter</a>
				<a class="permalink" href="index.html#OffsetWriter">&#xb6;</a>
				
				
			</h2>
			<p>An OffsetWriter maps writes at offset base to offset base+off in the underlying writer.

			<pre>type OffsetWriter struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewOffsetWriter">func <a href="../../src/io/io.go?s=18856:18913#L568">NewOffsetWriter</a>
					<a class="permalink" href="index.html#NewOffsetWriter">&#xb6;</a>
					
					
				</h3>
				<pre>func NewOffsetWriter(w <a href="index.html#WriterAt">WriterAt</a>, off <a href="../builtin/index.html#int64">int64</a>) *<a href="index.html#OffsetWriter">OffsetWriter</a></pre>
				<p>NewOffsetWriter returns an <a href="index.html#OffsetWriter">OffsetWriter</a> that writes to w
starting at offset off.

				
				
			

			
				
				<h3 id="OffsetWriter.Seek">func (*OffsetWriter) <a href="../../src/io/io.go?s=19235:19303#L587">Seek</a>
					<a class="permalink" href="index.html#OffsetWriter.Seek">&#xb6;</a>
					
					
				</h3>
				<pre>func (o *<a href="index.html#OffsetWriter">OffsetWriter</a>) Seek(offset <a href="../builtin/index.html#int64">int64</a>, whence <a href="../builtin/index.html#int">int</a>) (<a href="../builtin/index.html#int64">int64</a>, <a href="../builtin/index.html#error">error</a>)</pre>
				
				
				
				
			
				
				<h3 id="OffsetWriter.Write">func (*OffsetWriter) <a href="../../src/io/io.go?s=18954:19011#L572">Write</a>
					<a class="permalink" href="index.html#OffsetWriter.Write">&#xb6;</a>
					
					
				</h3>
				<pre>func (o *<a href="index.html#OffsetWriter">OffsetWriter</a>) Write(p []<a href="../builtin/index.html#byte">byte</a>) (n <a href="../builtin/index.html#int">int</a>, err <a href="../builtin/index.html#error">error</a>)</pre>
				
				
				
				
			
				
				<h3 id="OffsetWriter.WriteAt">func (*OffsetWriter) <a href="../../src/io/io.go?s=19076:19146#L578">WriteAt</a>
					<a class="permalink" href="index.html#OffsetWriter.WriteAt">&#xb6;</a>
					
					
				</h3>
				<pre>func (o *<a href="index.html#OffsetWriter">OffsetWriter</a>) WriteAt(p []<a href="../builtin/index.html#byte">byte</a>, off <a href="../builtin/index.html#int64">int64</a>) (n <a href="../builtin/index.html#int">int</a>, err <a href="../builtin/index.html#error">error</a>)</pre>
				
				
				
				
			
		
			
			
			<h2 id="PipeReader">type <a href="../../src/io/pipe.go?s=2465:2495#L116">PipeReader</a>
				<a class="permalink" href="index.html#PipeReader">&#xb6;</a>
				
				
			</h2>
			<p>A PipeReader is the read half of a pipe.

			<pre>type PipeReader struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="PipeReader.Close">func (*PipeReader) <a href="../../src/io/pipe.go?s=2948:2982#L129">Close</a>
					<a class="permalink" href="index.html#PipeReader.Close">&#xb6;</a>
					
					
				</h3>
				<pre>func (r *<a href="index.html#PipeReader">PipeReader</a>) Close() <a href="../builtin/index.html#error">error</a></pre>
				<p>Close closes the reader; subsequent writes to the
write half of the pipe will return the error <a href="index.html#ErrClosedPipe">ErrClosedPipe</a>.

				
				
				
			
				
				<h3 id="PipeReader.CloseWithError">func (*PipeReader) <a href="../../src/io/pipe.go?s=3230:3282#L138">CloseWithError</a>
					<a class="permalink" href="index.html#PipeReader.CloseWithError">&#xb6;</a>
					
					
				</h3>
				<pre>func (r *<a href="index.html#PipeReader">PipeReader</a>) CloseWithError(err <a href="../builtin/index.html#error">error</a>) <a href="../builtin/index.html#error">error</a></pre>
				<p>CloseWithError closes the reader; subsequent writes
to the write half of the pipe will return the error err.
<p>CloseWithError never overwrites the previous error if it exists
and always returns nil.

				
				
				
			
				
				<h3 id="PipeReader.Read">func (*PipeReader) <a href="../../src/io/pipe.go?s=2741:2798#L123">Read</a>
					<a class="permalink" href="index.html#PipeReader.Read">&#xb6;</a>
					
					
				</h3>
				<pre>func (r *<a href="index.html#PipeReader">PipeReader</a>) Read(data []<a href="../builtin/index.html#byte">byte</a>) (n <a href="../builtin/index.html#int">int</a>, err <a href="../builtin/index.html#error">error</a>)</pre>
				<p>Read implements the standard Read interface:
it reads data from the pipe, blocking until a writer
arrives or the write end is closed.
If the write end is closed with an error, that error is
returned as err; otherwise err is EOF.

				
				
				
			
		
			
			
			<h2 id="PipeWriter">type <a href="../../src/io/pipe.go?s=3363:3401#L143">PipeWriter</a>
				<a class="permalink" href="index.html#PipeWriter">&#xb6;</a>
				
				
			</h2>
			<p>A PipeWriter is the write half of a pipe.

			<pre>type PipeWriter struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="PipeWriter.Close">func (*PipeWriter) <a href="../../src/io/pipe.go?s=3888:3922#L156">Close</a>
					<a class="permalink" href="index.html#PipeWriter.Close">&#xb6;</a>
					
					
				</h3>
				<pre>func (w *<a href="index.html#PipeWriter">PipeWriter</a>) Close() <a href="../builtin/index.html#error">error</a></pre>
				<p>Close closes the writer; subsequent reads from the
read half of the pipe will return no bytes and EOF.

				
				
				
			
				
				<h3 id="PipeWriter.CloseWithError">func (*PipeWriter) <a href="../../src/io/pipe.go?s=4208:4260#L166">CloseWithError</a>
					<a class="permalink" href="index.html#PipeWriter.CloseWithError">&#xb6;</a>
					
					
				</h3>
				<pre>func (w *<a href="index.html#PipeWriter">PipeWriter</a>) CloseWithError(err <a href="../builtin/index.html#error">error</a>) <a href="../builtin/index.html#error">error</a></pre>
				<p>CloseWithError closes the writer; subsequent reads from the
read half of the pipe will return no bytes and the error err,
or EOF if err is nil.
<p>CloseWithError never overwrites the previous error if it exists
and always returns nil.

				
				
				
			
				
				<h3 id="PipeWriter.Write">func (*PipeWriter) <a href="../../src/io/pipe.go?s=3686:3744#L150">Write</a>
					<a class="permalink" href="index.html#PipeWriter.Write">&#xb6;</a>
					
					
				</h3>
				<pre>func (w *<a href="index.html#PipeWriter">PipeWriter</a>) Write(data []<a href="../builtin/index.html#byte">byte</a>) (n <a href="../builtin/index.html#int">int</a>, err <a href="../builtin/index.html#error">error</a>)</pre>
				<p>Write implements the standard Write interface:
it writes data to the pipe, blocking until one or more readers
have consumed all the data or the read end is closed.
If the read end is closed with an error, that err is
returned as err; otherwise err is <a href="index.html#ErrClosedPipe">ErrClosedPipe</a>.

				
				
				
			
		
			
			
			<h2 id="ReadCloser">type <a href="../../src/io/io.go?s=5476:5521#L127">ReadCloser</a>
				<a class="permalink" href="index.html#ReadCloser">&#xb6;</a>
				
				
			</h2>
			<p>ReadCloser is the interface that groups the basic Read and Close methods.

			<pre>type ReadCloser interface {
    <a href="index.html#Reader">Reader</a>
    <a href="index.html#Closer">Closer</a>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NopCloser">func <a href="../../src/io/io.go?s=21141:21176#L672">NopCloser</a>
					<a class="permalink" href="index.html#NopCloser">&#xb6;</a>
					
					
				</h3>
				<pre>func NopCloser(r <a href="index.html#Reader">Reader</a>) <a href="index.html#ReadCloser">ReadCloser</a></pre>
				<p>NopCloser returns a <a href="index.html#ReadCloser">ReadCloser</a> with a no-op Close method wrapping
the provided <a href="index.html#Reader">Reader</a> r.
If r implements <a href="index.html#WriterTo">WriterTo</a>, the returned <a href="index.html#ReadCloser">ReadCloser</a> will implement <a href="index.html#WriterTo">WriterTo</a>
by forwarding calls to r.

				
				
			

			
		
			
			
			<h2 id="ReadSeekCloser">type <a href="../../src/io/io.go?s=6012:6069#L153">ReadSeekCloser</a>
				<a class="permalink" href="index.html#ReadSeekCloser">&#xb6;</a>
				
				
			</h2>
			<p>ReadSeekCloser is the interface that groups the basic Read, Seek and Close
methods.

			<pre>type ReadSeekCloser interface {
    <a href="index.html#Reader">Reader</a>
    <a href="index.html#Seeker">Seeker</a>
    <a href="index.html#Closer">Closer</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="ReadSeeker">type <a href="../../src/io/io.go?s=5875:5920#L146">ReadSeeker</a>
				<a class="permalink" href="index.html#ReadSeeker">&#xb6;</a>
				
				
			</h2>
			<p>ReadSeeker is the interface that groups the basic Read and Seek methods.

			<pre>type ReadSeeker interface {
    <a href="index.html#Reader">Reader</a>
    <a href="index.html#Seeker">Seeker</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="ReadWriteCloser">type <a href="../../src/io/io.go?s=5739:5797#L139">ReadWriteCloser</a>
				<a class="permalink" href="index.html#ReadWriteCloser">&#xb6;</a>
				
				
			</h2>
			<p>ReadWriteCloser is the interface that groups the basic Read, Write and Close methods.

			<pre>type ReadWriteCloser interface {
    <a href="index.html#Reader">Reader</a>
    <a href="index.html#Writer">Writer</a>
    <a href="index.html#Closer">Closer</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="ReadWriteSeeker">type <a href="../../src/io/io.go?s=6285:6343#L166">ReadWriteSeeker</a>
				<a class="permalink" href="index.html#ReadWriteSeeker">&#xb6;</a>
				
				
			</h2>
			<p>ReadWriteSeeker is the interface that groups the basic Read, Write and Seek methods.

			<pre>type ReadWriteSeeker interface {
    <a href="index.html#Reader">Reader</a>
    <a href="index.html#Writer">Writer</a>
    <a href="index.html#Seeker">Seeker</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="ReadWriter">type <a href="../../src/io/io.go?s=5352:5397#L121">ReadWriter</a>
				<a class="permalink" href="index.html#ReadWriter">&#xb6;</a>
				
				
			</h2>
			<p>ReadWriter is the interface that groups the basic Read and Write methods.

			<pre>type ReadWriter interface {
    <a href="index.html#Reader">Reader</a>
    <a href="index.html#Writer">Writer</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Reader">type <a href="../../src/io/io.go?s=3680:3740#L76">Reader</a>
				<a class="permalink" href="index.html#Reader">&#xb6;</a>
				
				
			</h2>
			<p>Reader is the interface that wraps the basic Read method.
<p>Read reads up to len(p) bytes into p. It returns the number of bytes
read (0 &lt;= n &lt;= len(p)) and any error encountered. Even if Read
returns n &lt; len(p), it may use all of p as scratch space during the call.
If some data is available but not len(p) bytes, Read conventionally
returns what is available instead of waiting for more.
<p>When Read encounters an error or end-of-file condition after
successfully reading n &gt; 0 bytes, it returns the number of
bytes read. It may return the (non-nil) error from the same call
or return the error (and n == 0) from a subsequent call.
An instance of this general case is that a Reader returning
a non-zero number of bytes at the end of the input stream may
return either err == EOF or err == nil. The next Read should
return 0, EOF.
<p>Callers should always process the n &gt; 0 bytes returned before
considering the error err. Doing so correctly handles I/O errors
that happen after reading some bytes and also both of the
allowed EOF behaviors.
<p>If len(p) == 0, Read should always return n == 0. It may return a
non-nil error if some error condition is known, such as EOF.
<p>Implementations of Read are discouraged from returning a
zero byte count with a nil error, except when len(p) == 0.
Callers should treat a return of 0 and nil as indicating that
nothing happened; in particular it does not indicate EOF.
<p>Implementations must not retain p.

			<pre>type Reader interface {
    Read(p []<a href="../builtin/index.html#byte">byte</a>) (n <a href="../builtin/index.html#int">int</a>, err <a href="../builtin/index.html#error">error</a>)
}</pre>

			

			

			
			
			

			
				
				<h3 id="LimitReader">func <a href="../../src/io/io.go?s=15811:15853#L451">LimitReader</a>
					<a class="permalink" href="index.html#LimitReader">&#xb6;</a>
					
					
				</h3>
				<pre>func LimitReader(r <a href="index.html#Reader">Reader</a>, n <a href="../builtin/index.html#int64">int64</a>) <a href="index.html#Reader">Reader</a></pre>
				<p>LimitReader returns a Reader that reads from r
but stops with EOF after n bytes.
The underlying implementation is a *LimitedReader.

				<div id="example_LimitReader" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">r := strings.NewReader(&#34;some io.Reader stream to be read\n&#34;)
lr := io.LimitReader(r, 4)

if _, err := io.Copy(os.Stdout, lr); err != nil {
    log.Fatal(err)
}

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">some
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="MultiReader">func <a href="../../src/io/multi.go?s=1942:1984#L63">MultiReader</a>
					<a class="permalink" href="index.html#MultiReader">&#xb6;</a>
					
					
				</h3>
				<pre>func MultiReader(readers ...<a href="index.html#Reader">Reader</a>) <a href="index.html#Reader">Reader</a></pre>
				<p>MultiReader returns a Reader that&apos;s the logical concatenation of
the provided input readers. They&apos;re read sequentially. Once all
inputs have returned EOF, Read will return EOF.  If any of the readers
return a non-nil, non-EOF error, Read will return that error.

				<div id="example_MultiReader" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">r1 := strings.NewReader(&#34;first reader &#34;)
r2 := strings.NewReader(&#34;second reader &#34;)
r3 := strings.NewReader(&#34;third reader\n&#34;)
r := io.MultiReader(r1, r2, r3)

if _, err := io.Copy(os.Stdout, r); err != nil {
    log.Fatal(err)
}

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">first reader second reader third reader
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="TeeReader">func <a href="../../src/io/io.go?s=19840:19881#L608">TeeReader</a>
					<a class="permalink" href="index.html#TeeReader">&#xb6;</a>
					
					
				</h3>
				<pre>func TeeReader(r <a href="index.html#Reader">Reader</a>, w <a href="index.html#Writer">Writer</a>) <a href="index.html#Reader">Reader</a></pre>
				<p>TeeReader returns a <a href="index.html#Reader">Reader</a> that writes to w what it reads from r.
All reads from r performed through it are matched with
corresponding writes to w. There is no internal buffering -
the write must complete before the read completes.
Any error encountered while writing is reported as a read error.

				<div id="example_TeeReader" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">var r io.Reader = strings.NewReader(&#34;some io.Reader stream to be read\n&#34;)

r = io.TeeReader(r, os.Stdout)

<span class="comment">// Everything read from r will be copied to stdout.</span>
if _, err := io.ReadAll(r); err != nil {
    log.Fatal(err)
}

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">some io.Reader stream to be read
</pre>
			
		
	</div>
</div>

				
			

			
		
			
			
			<h2 id="ReaderAt">type <a href="../../src/io/io.go?s=8194:8269#L220">ReaderAt</a>
				<a class="permalink" href="index.html#ReaderAt">&#xb6;</a>
				
				
			</h2>
			<p>ReaderAt is the interface that wraps the basic ReadAt method.
<p>ReadAt reads len(p) bytes into p starting at offset off in the
underlying input source. It returns the number of bytes
read (0 &lt;= n &lt;= len(p)) and any error encountered.
<p>When ReadAt returns n &lt; len(p), it returns a non-nil error
explaining why more bytes were not returned. In this respect,
ReadAt is stricter than Read.
<p>Even if ReadAt returns n &lt; len(p), it may use all of p as scratch
space during the call. If some data is available but not len(p) bytes,
ReadAt blocks until either all the data is available or an error occurs.
In this respect ReadAt is different from Read.
<p>If the n = len(p) bytes returned by ReadAt are at the end of the
input source, ReadAt may return either err == EOF or err == nil.
<p>If ReadAt is reading from an input source with a seek offset,
ReadAt should not affect nor be affected by the underlying
seek offset.
<p>Clients of ReadAt can execute parallel ReadAt calls on the
same input source.
<p>Implementations must not retain p.

			<pre>type ReaderAt interface {
    ReadAt(p []<a href="../builtin/index.html#byte">byte</a>, off <a href="../builtin/index.html#int64">int64</a>) (n <a href="../builtin/index.html#int">int</a>, err <a href="../builtin/index.html#error">error</a>)
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="ReaderFrom">type <a href="../../src/io/io.go?s=6640:6710#L179">ReaderFrom</a>
				<a class="permalink" href="index.html#ReaderFrom">&#xb6;</a>
				
				
			</h2>
			<p>ReaderFrom is the interface that wraps the ReadFrom method.
<p>ReadFrom reads data from r until EOF or error.
The return value n is the number of bytes read.
Any error except EOF encountered during the read is also returned.
<p>The <a href="index.html#Copy">Copy</a> function uses <a href="index.html#ReaderFrom">ReaderFrom</a> if available.

			<pre>type ReaderFrom interface {
    ReadFrom(r <a href="index.html#Reader">Reader</a>) (n <a href="../builtin/index.html#int64">int64</a>, err <a href="../builtin/index.html#error">error</a>)
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="RuneReader">type <a href="../../src/io/io.go?s=10359:10430#L279">RuneReader</a>
				<a class="permalink" href="index.html#RuneReader">&#xb6;</a>
				
				
			</h2>
			<p>RuneReader is the interface that wraps the ReadRune method.
<p>ReadRune reads a single encoded Unicode character
and returns the rune and its size in bytes. If no character is
available, err will be set.

			<pre>type RuneReader interface {
    ReadRune() (r <a href="../builtin/index.html#rune">rune</a>, size <a href="../builtin/index.html#int">int</a>, err <a href="../builtin/index.html#error">error</a>)
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="RuneScanner">type <a href="../../src/io/io.go?s=10902:10964#L291">RuneScanner</a>
				<a class="permalink" href="index.html#RuneScanner">&#xb6;</a>
				
				
			</h2>
			<p>RuneScanner is the interface that adds the UnreadRune method to the
basic ReadRune method.
<p>UnreadRune causes the next call to ReadRune to return the last rune read.
If the last operation was not a successful call to ReadRune, UnreadRune may
return an error, unread the last rune read (or the rune prior to the
last-unread rune), or (in implementations that support the <a href="index.html#Seeker">Seeker</a> interface)
seek to the start of the rune before the current offset.

			<pre>type RuneScanner interface {
    <a href="index.html#RuneReader">RuneReader</a>
    UnreadRune() <a href="../builtin/index.html#error">error</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="SectionReader">type <a href="../../src/io/io.go?s=16972:17180#L491">SectionReader</a>
				<a class="permalink" href="index.html#SectionReader">&#xb6;</a>
				
				
			</h2>
			<p>SectionReader implements Read, Seek, and ReadAt on a section
of an underlying <a href="index.html#ReaderAt">ReaderAt</a>.

			<pre>type SectionReader struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_SectionReader" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">r := strings.NewReader(&#34;some io.Reader stream to be read\n&#34;)
s := io.NewSectionReader(r, 5, 17)

if _, err := io.Copy(os.Stdout, s); err != nil {
    log.Fatal(err)
}

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">io.Reader stream
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewSectionReader">func <a href="../../src/io/io.go?s=16523:16591#L476">NewSectionReader</a>
					<a class="permalink" href="index.html#NewSectionReader">&#xb6;</a>
					
					
				</h3>
				<pre>func NewSectionReader(r <a href="index.html#ReaderAt">ReaderAt</a>, off <a href="../builtin/index.html#int64">int64</a>, n <a href="../builtin/index.html#int64">int64</a>) *<a href="index.html#SectionReader">SectionReader</a></pre>
				<p>NewSectionReader returns a <a href="index.html#SectionReader">SectionReader</a> that reads from r
starting at offset off and stops with EOF after n bytes.

				
				
			

			
				
				<h3 id="SectionReader.Outer">func (*SectionReader) <a href="../../src/io/io.go?s=18467:18531#L555">Outer</a>
					<a class="permalink" href="index.html#SectionReader.Outer">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#SectionReader">SectionReader</a>) Outer() (r <a href="index.html#ReaderAt">ReaderAt</a>, off <a href="../builtin/index.html#int64">int64</a>, n <a href="../builtin/index.html#int64">int64</a>)</pre>
				<p>Outer returns the underlying <a href="index.html#ReaderAt">ReaderAt</a> and offsets for the section.
<p>The returned values are the same that were passed to <a href="index.html#NewSectionReader">NewSectionReader</a>
when the <a href="index.html#SectionReader">SectionReader</a> was created.

				
				
				
			
				
				<h3 id="SectionReader.Read">func (*SectionReader) <a href="../../src/io/io.go?s=17182:17239#L499">Read</a>
					<a class="permalink" href="index.html#SectionReader.Read">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#SectionReader">SectionReader</a>) Read(p []<a href="../builtin/index.html#byte">byte</a>) (n <a href="../builtin/index.html#int">int</a>, err <a href="../builtin/index.html#error">error</a>)</pre>
				
				
				<div id="example_SectionReader_Read" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">r := strings.NewReader(&#34;some io.Reader stream to be read\n&#34;)
s := io.NewSectionReader(r, 5, 17)

buf := make([]byte, 9)
if _, err := s.Read(buf); err != nil {
    log.Fatal(err)
}

fmt.Printf(&#34;%s\n&#34;, buf)

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">io.Reader
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="SectionReader.ReadAt">func (*SectionReader) <a href="../../src/io/io.go?s=17843:17913#L532">ReadAt</a>
					<a class="permalink" href="index.html#SectionReader.ReadAt">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#SectionReader">SectionReader</a>) ReadAt(p []<a href="../builtin/index.html#byte">byte</a>, off <a href="../builtin/index.html#int64">int64</a>) (n <a href="../builtin/index.html#int">int</a>, err <a href="../builtin/index.html#error">error</a>)</pre>
				
				
				<div id="example_SectionReader_ReadAt" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">r := strings.NewReader(&#34;some io.Reader stream to be read\n&#34;)
s := io.NewSectionReader(r, 5, 17)

buf := make([]byte, 6)
if _, err := s.ReadAt(buf, 10); err != nil {
    log.Fatal(err)
}

fmt.Printf(&#34;%s\n&#34;, buf)

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">stream
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="SectionReader.Seek">func (*SectionReader) <a href="../../src/io/io.go?s=17516:17585#L514">Seek</a>
					<a class="permalink" href="index.html#SectionReader.Seek">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#SectionReader">SectionReader</a>) Seek(offset <a href="../builtin/index.html#int64">int64</a>, whence <a href="../builtin/index.html#int">int</a>) (<a href="../builtin/index.html#int64">int64</a>, <a href="../builtin/index.html#error">error</a>)</pre>
				
				
				<div id="example_SectionReader_Seek" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">r := strings.NewReader(&#34;some io.Reader stream to be read\n&#34;)
s := io.NewSectionReader(r, 5, 17)

if _, err := s.Seek(10, io.SeekStart); err != nil {
    log.Fatal(err)
}

if _, err := io.Copy(os.Stdout, s); err != nil {
    log.Fatal(err)
}

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">stream
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="SectionReader.Size">func (*SectionReader) <a href="../../src/io/io.go?s=18210:18246#L549">Size</a>
					<a class="permalink" href="index.html#SectionReader.Size">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="index.html#SectionReader">SectionReader</a>) Size() <a href="../builtin/index.html#int64">int64</a></pre>
				<p>Size returns the size of the section in bytes.

				
				<div id="example_SectionReader_Size" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">r := strings.NewReader(&#34;some io.Reader stream to be read\n&#34;)
s := io.NewSectionReader(r, 5, 17)

fmt.Println(s.Size())

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">17
</pre>
			
		
	</div>
</div>

				
			
		
			
			
			<h2 id="Seeker">type <a href="../../src/io/io.go?s=5201:5273#L116">Seeker</a>
				<a class="permalink" href="index.html#Seeker">&#xb6;</a>
				
				
			</h2>
			<p>Seeker is the interface that wraps the basic Seek method.
<p>Seek sets the offset for the next Read or Write to offset,
interpreted according to whence:
<a href="index.html#SeekStart">SeekStart</a> means relative to the start of the file,
<a href="index.html#SeekCurrent">SeekCurrent</a> means relative to the current offset, and
<a href="index.html#SeekEnd">SeekEnd</a> means relative to the end
(for example, offset = -2 specifies the penultimate byte of the file).
Seek returns the new offset relative to the start of the
file or an error, if any.
<p>Seeking to an offset before the start of the file is an error.
Seeking to any positive offset may be allowed, but if the new offset exceeds
the size of the underlying object the behavior of subsequent I/O operations
is implementation-dependent.

			<pre>type Seeker interface {
    Seek(offset <a href="../builtin/index.html#int64">int64</a>, whence <a href="../builtin/index.html#int">int</a>) (<a href="../builtin/index.html#int64">int64</a>, <a href="../builtin/index.html#error">error</a>)
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="StringWriter">type <a href="../../src/io/io.go?s=11034:11107#L297">StringWriter</a>
				<a class="permalink" href="index.html#StringWriter">&#xb6;</a>
				
				
			</h2>
			<p>StringWriter is the interface that wraps the WriteString method.

			<pre>type StringWriter interface {
    WriteString(s <a href="../builtin/index.html#string">string</a>) (n <a href="../builtin/index.html#int">int</a>, err <a href="../builtin/index.html#error">error</a>)
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="WriteCloser">type <a href="../../src/io/io.go?s=5602:5648#L133">WriteCloser</a>
				<a class="permalink" href="index.html#WriteCloser">&#xb6;</a>
				
				
			</h2>
			<p>WriteCloser is the interface that groups the basic Write and Close methods.

			<pre>type WriteCloser interface {
    <a href="index.html#Writer">Writer</a>
    <a href="index.html#Closer">Closer</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="WriteSeeker">type <a href="../../src/io/io.go?s=6149:6195#L160">WriteSeeker</a>
				<a class="permalink" href="index.html#WriteSeeker">&#xb6;</a>
				
				
			</h2>
			<p>WriteSeeker is the interface that groups the basic Write and Seek methods.

			<pre>type WriteSeeker interface {
    <a href="index.html#Writer">Writer</a>
    <a href="index.html#Seeker">Seeker</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Writer">type <a href="../../src/io/io.go?s=4171:4232#L89">Writer</a>
				<a class="permalink" href="index.html#Writer">&#xb6;</a>
				
				
			</h2>
			<p>Writer is the interface that wraps the basic Write method.
<p>Write writes len(p) bytes from p to the underlying data stream.
It returns the number of bytes written from p (0 &lt;= n &lt;= len(p))
and any error encountered that caused the write to stop early.
Write must return a non-nil error if it returns n &lt; len(p).
Write must not modify the slice data, even temporarily.
<p>Implementations must not retain p.

			<pre>type Writer interface {
    Write(p []<a href="../builtin/index.html#byte">byte</a>) (n <a href="../builtin/index.html#int">int</a>, err <a href="../builtin/index.html#error">error</a>)
}</pre>

			

			
				<p>Discard is a <a href="index.html#Writer">Writer</a> on which all Write calls succeed
without doing anything.

				<pre>var <span id="Discard">Discard</span> <a href="index.html#Writer">Writer</a> = discard{}</pre>
			

			
			
			

			
				
				<h3 id="MultiWriter">func <a href="../../src/io/multi.go?s=3119:3161#L117">MultiWriter</a>
					<a class="permalink" href="index.html#MultiWriter">&#xb6;</a>
					
					
				</h3>
				<pre>func MultiWriter(writers ...<a href="index.html#Writer">Writer</a>) <a href="index.html#Writer">Writer</a></pre>
				<p>MultiWriter creates a writer that duplicates its writes to all the
provided writers, similar to the Unix tee(1) command.
<p>Each write is written to each listed writer, one at a time.
If a listed writer returns an error, that overall write operation
stops and returns the error; it does not continue down the list.

				<div id="example_MultiWriter" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">r := strings.NewReader(&#34;some io.Reader stream to be read\n&#34;)

var buf1, buf2 strings.Builder
w := io.MultiWriter(&amp;buf1, &amp;buf2)

if _, err := io.Copy(w, r); err != nil {
    log.Fatal(err)
}

fmt.Print(buf1.String())
fmt.Print(buf2.String())

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">some io.Reader stream to be read
some io.Reader stream to be read
</pre>
			
		
	</div>
</div>

				
			

			
		
			
			
			<h2 id="WriterAt">type <a href="../../src/io/io.go?s=8924:9000#L239">WriterAt</a>
				<a class="permalink" href="index.html#WriterAt">&#xb6;</a>
				
				
			</h2>
			<p>WriterAt is the interface that wraps the basic WriteAt method.
<p>WriteAt writes len(p) bytes from p to the underlying data stream
at offset off. It returns the number of bytes written from p (0 &lt;= n &lt;= len(p))
and any error encountered that caused the write to stop early.
WriteAt must return a non-nil error if it returns n &lt; len(p).
<p>If WriteAt is writing to a destination with a seek offset,
WriteAt should not affect nor be affected by the underlying
seek offset.
<p>Clients of WriteAt can execute parallel WriteAt calls on the same
destination if the ranges do not overlap.
<p>Implementations must not retain p.

			<pre>type WriterAt interface {
    WriteAt(p []<a href="../builtin/index.html#byte">byte</a>, off <a href="../builtin/index.html#int64">int64</a>) (n <a href="../builtin/index.html#int">int</a>, err <a href="../builtin/index.html#error">error</a>)
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="WriterTo">type <a href="../../src/io/io.go?s=7030:7097#L190">WriterTo</a>
				<a class="permalink" href="index.html#WriterTo">&#xb6;</a>
				
				
			</h2>
			<p>WriterTo is the interface that wraps the WriteTo method.
<p>WriteTo writes data to w until there&apos;s no more data to write or
when an error occurs. The return value n is the number of bytes
written. Any error encountered during the write is also returned.
<p>The Copy function uses WriterTo if available.

			<pre>type WriterTo interface {
    WriteTo(w <a href="index.html#Writer">Writer</a>) (n <a href="../builtin/index.html#int64">int64</a>, err <a href="../builtin/index.html#error">error</a>)
}</pre>

			

			

			
			
			

			

			
		
	

	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	<div class="pkg-dir">
		<table>
			<tr>
				<th class="pkg-name">Name</th>
				<th class="pkg-synopsis">Synopsis</th>
			</tr>

			
			<tr>
				<td colspan="2"><a href="../../index.html">..</a></td>
			</tr>
			

			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="fs/index.html">fs</a>
					</td>
				
					<td class="pkg-synopsis">
						Package fs defines basic interfaces to a file system.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="ioutil/index.html">ioutil</a>
					</td>
				
					<td class="pkg-synopsis">
						Package ioutil implements some I/O utility functions.
					</td>
				</tr>
			
		</table>
	</div>



<div id="footer">
Build version go1.22.2.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:8080/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
