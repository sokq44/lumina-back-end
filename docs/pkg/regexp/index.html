<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>regexp - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="../../lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="../../lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.22.2";</script>
<script src="../../lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="../../index.html">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="../../index.html">GoDoc</a></div>
<a href="index.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:8080/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package regexp
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "regexp"</code></dd>
			</dl>
			<dl>
			<dd><a href="index.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="index.html#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="index.html#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
				<dd><a href="index.html#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package regexp implements regular expression search.
<p>The syntax of the regular expressions accepted is the same
general syntax used by Perl, Python, and other languages.
More precisely, it is the syntax accepted by RE2 and described at
<a href="https://golang.org/s/re2syntax">https://golang.org/s/re2syntax</a>, except for \C.
For an overview of the syntax, see the <a href="http://localhost:8080/regexp/syntax">regexp/syntax</a> package.
<p>The regexp implementation provided by this package is
guaranteed to run in time linear in the size of the input.
(This is a property not guaranteed by most open source
implementations of regular expressions.) For more information
about this property, see
<pre>https://swtch.com/~rsc/regexp/regexp1.html
</pre>
<p>or any book about automata theory.
<p>All characters are UTF-8-encoded code points.
Following <a href="http://localhost:8080/unicode/utf8#DecodeRune">utf8.DecodeRune</a>, each byte of an invalid UTF-8 sequence
is treated as if it encoded utf8.RuneError (U+FFFD).
<p>There are 16 methods of <a href="index.html#Regexp">Regexp</a> that match a regular expression and identify
the matched text. Their names are matched by this regular expression:
<pre>Find(All)?(String)?(Submatch)?(Index)?
</pre>
<p>If &apos;All&apos; is present, the routine matches successive non-overlapping
matches of the entire expression. Empty matches abutting a preceding
match are ignored. The return value is a slice containing the successive
return values of the corresponding non-&apos;All&apos; routine. These routines take
an extra integer argument, n. If n &gt;= 0, the function returns at most n
matches/submatches; otherwise, it returns all of them.
<p>If &apos;String&apos; is present, the argument is a string; otherwise it is a slice
of bytes; return values are adjusted as appropriate.
<p>If &apos;Submatch&apos; is present, the return value is a slice identifying the
successive submatches of the expression. Submatches are matches of
parenthesized subexpressions (also known as capturing groups) within the
regular expression, numbered from left to right in order of opening
parenthesis. Submatch 0 is the match of the entire expression, submatch 1 is
the match of the first parenthesized subexpression, and so on.
<p>If &apos;Index&apos; is present, matches and submatches are identified by byte index
pairs within the input string: result[2*n:2*n+2] identifies the indexes of
the nth submatch. The pair for n==0 identifies the match of the entire
expression. If &apos;Index&apos; is not present, the match is identified by the text
of the match/submatch. If an index is negative or text is nil, it means that
subexpression did not match any string in the input. For &apos;String&apos; versions
an empty string means either no match or an empty match.
<p>There is also a subset of the methods that can be applied to text read
from a RuneReader:
<pre>MatchReader, FindReaderIndex, FindReaderSubmatchIndex
</pre>
<p>This set may grow. Note that regular expression matches may need to
examine text beyond the text returned by a match, so the methods that
match text from a RuneReader may read arbitrarily far into the input
before returning.
<p>(There are a few other methods that do not match this pattern.)

				<div id="example_" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// Compile the expression once, usually at init time.</span>
<span class="comment">// Use raw strings to avoid having to quote the backslashes.</span>
var validID = regexp.MustCompile(`^[a-z]+\[[0-9]+\]$`)

fmt.Println(validID.MatchString(&#34;adam[23]&#34;))
fmt.Println(validID.MatchString(&#34;eve[7]&#34;))
fmt.Println(validID.MatchString(&#34;Job[48]&#34;))
fmt.Println(validID.MatchString(&#34;snakey&#34;))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true
true
false
false
</pre>
			
		
	</div>
</div>

			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="index.html#Match">func Match(pattern string, b []byte) (matched bool, err error)</a></dd>
			
				
				<dd><a href="index.html#MatchReader">func MatchReader(pattern string, r io.RuneReader) (matched bool, err error)</a></dd>
			
				
				<dd><a href="index.html#MatchString">func MatchString(pattern string, s string) (matched bool, err error)</a></dd>
			
				
				<dd><a href="index.html#QuoteMeta">func QuoteMeta(s string) string</a></dd>
			
			
				
				<dd><a href="index.html#Regexp">type Regexp</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Compile">func Compile(expr string) (*Regexp, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#CompilePOSIX">func CompilePOSIX(expr string) (*Regexp, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MustCompile">func MustCompile(str string) *Regexp</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#MustCompilePOSIX">func MustCompilePOSIX(str string) *Regexp</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.Copy">func (re *Regexp) Copy() *Regexp</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.Expand">func (re *Regexp) Expand(dst []byte, template []byte, src []byte, match []int) []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.ExpandString">func (re *Regexp) ExpandString(dst []byte, template string, src string, match []int) []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.Find">func (re *Regexp) Find(b []byte) []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.FindAll">func (re *Regexp) FindAll(b []byte, n int) [][]byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.FindAllIndex">func (re *Regexp) FindAllIndex(b []byte, n int) [][]int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.FindAllString">func (re *Regexp) FindAllString(s string, n int) []string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.FindAllStringIndex">func (re *Regexp) FindAllStringIndex(s string, n int) [][]int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.FindAllStringSubmatch">func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.FindAllStringSubmatchIndex">func (re *Regexp) FindAllStringSubmatchIndex(s string, n int) [][]int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.FindAllSubmatch">func (re *Regexp) FindAllSubmatch(b []byte, n int) [][][]byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.FindAllSubmatchIndex">func (re *Regexp) FindAllSubmatchIndex(b []byte, n int) [][]int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.FindIndex">func (re *Regexp) FindIndex(b []byte) (loc []int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.FindReaderIndex">func (re *Regexp) FindReaderIndex(r io.RuneReader) (loc []int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.FindReaderSubmatchIndex">func (re *Regexp) FindReaderSubmatchIndex(r io.RuneReader) []int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.FindString">func (re *Regexp) FindString(s string) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.FindStringIndex">func (re *Regexp) FindStringIndex(s string) (loc []int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.FindStringSubmatch">func (re *Regexp) FindStringSubmatch(s string) []string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.FindStringSubmatchIndex">func (re *Regexp) FindStringSubmatchIndex(s string) []int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.FindSubmatch">func (re *Regexp) FindSubmatch(b []byte) [][]byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.FindSubmatchIndex">func (re *Regexp) FindSubmatchIndex(b []byte) []int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.LiteralPrefix">func (re *Regexp) LiteralPrefix() (prefix string, complete bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.Longest">func (re *Regexp) Longest()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.MarshalText">func (re *Regexp) MarshalText() ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.Match">func (re *Regexp) Match(b []byte) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.MatchReader">func (re *Regexp) MatchReader(r io.RuneReader) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.MatchString">func (re *Regexp) MatchString(s string) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.NumSubexp">func (re *Regexp) NumSubexp() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.ReplaceAll">func (re *Regexp) ReplaceAll(src, repl []byte) []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.ReplaceAllFunc">func (re *Regexp) ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.ReplaceAllLiteral">func (re *Regexp) ReplaceAllLiteral(src, repl []byte) []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.ReplaceAllLiteralString">func (re *Regexp) ReplaceAllLiteralString(src, repl string) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.ReplaceAllString">func (re *Regexp) ReplaceAllString(src, repl string) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.ReplaceAllStringFunc">func (re *Regexp) ReplaceAllStringFunc(src string, repl func(string) string) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.Split">func (re *Regexp) Split(s string, n int) []string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.String">func (re *Regexp) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.SubexpIndex">func (re *Regexp) SubexpIndex(name string) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.SubexpNames">func (re *Regexp) SubexpNames() []string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Regexp.UnmarshalText">func (re *Regexp) UnmarshalText(text []byte) error</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="index.html#example_">Package</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Match">Match</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_MatchString">MatchString</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_QuoteMeta">QuoteMeta</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_Expand">Regexp.Expand</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_ExpandString">Regexp.ExpandString</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_Find">Regexp.Find</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_FindAll">Regexp.FindAll</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_FindAllIndex">Regexp.FindAllIndex</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_FindAllString">Regexp.FindAllString</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_FindAllStringSubmatch">Regexp.FindAllStringSubmatch</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_FindAllStringSubmatchIndex">Regexp.FindAllStringSubmatchIndex</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_FindAllSubmatch">Regexp.FindAllSubmatch</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_FindAllSubmatchIndex">Regexp.FindAllSubmatchIndex</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_FindIndex">Regexp.FindIndex</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_FindString">Regexp.FindString</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_FindStringIndex">Regexp.FindStringIndex</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_FindStringSubmatch">Regexp.FindStringSubmatch</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_FindSubmatch">Regexp.FindSubmatch</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_FindSubmatchIndex">Regexp.FindSubmatchIndex</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_Longest">Regexp.Longest</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_Match">Regexp.Match</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_MatchString">Regexp.MatchString</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_NumSubexp">Regexp.NumSubexp</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_ReplaceAll">Regexp.ReplaceAll</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_ReplaceAllLiteralString">Regexp.ReplaceAllLiteralString</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_ReplaceAllString">Regexp.ReplaceAllString</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_ReplaceAllStringFunc">Regexp.ReplaceAllStringFunc</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_Split">Regexp.Split</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_SubexpIndex">Regexp.SubexpIndex</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Regexp_SubexpNames">Regexp.SubexpNames</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="../../src/regexp/backtrack.go">backtrack.go</a>
			
				<a href="../../src/regexp/exec.go">exec.go</a>
			
				<a href="../../src/regexp/onepass.go">onepass.go</a>
			
				<a href="../../src/regexp/regexp.go">regexp.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
		
		
			
			
			<h2 id="Match">func <a href="../../src/regexp/regexp.go?s=17555:17617#L555">Match</a>
				<a class="permalink" href="index.html#Match">&#xb6;</a>
				
				
			</h2>
			<pre>func Match(pattern <a href="../builtin/index.html#string">string</a>, b []<a href="../builtin/index.html#byte">byte</a>) (matched <a href="../builtin/index.html#bool">bool</a>, err <a href="../builtin/index.html#error">error</a>)</pre>
			<p>Match reports whether the byte slice b
contains any match of the regular expression pattern.
More complicated queries need to use <a href="index.html#Compile">Compile</a> and the full <a href="index.html#Regexp">Regexp</a> interface.

			<div id="example_Match" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">matched, err := regexp.Match(`foo.*`, []byte(`seafood`))
fmt.Println(matched, err)
matched, err = regexp.Match(`bar.*`, []byte(`seafood`))
fmt.Println(matched, err)
matched, err = regexp.Match(`a(b`, []byte(`seafood`))
fmt.Println(matched, err)

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true &lt;nil&gt;
false &lt;nil&gt;
false error parsing regexp: missing closing ): `a(b`
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="MatchReader">func <a href="../../src/regexp/regexp.go?s=16834:16909#L533">MatchReader</a>
				<a class="permalink" href="index.html#MatchReader">&#xb6;</a>
				
				
			</h2>
			<pre>func MatchReader(pattern <a href="../builtin/index.html#string">string</a>, r <a href="../io/index.html">io</a>.<a href="../io/index.html#RuneReader">RuneReader</a>) (matched <a href="../builtin/index.html#bool">bool</a>, err <a href="../builtin/index.html#error">error</a>)</pre>
			<p>MatchReader reports whether the text returned by the RuneReader
contains any match of the regular expression pattern.
More complicated queries need to use <a href="index.html#Compile">Compile</a> and the full <a href="index.html#Regexp">Regexp</a> interface.

			
			

		
			
			
			<h2 id="MatchString">func <a href="../../src/regexp/regexp.go?s=17199:17267#L544">MatchString</a>
				<a class="permalink" href="index.html#MatchString">&#xb6;</a>
				
				
			</h2>
			<pre>func MatchString(pattern <a href="../builtin/index.html#string">string</a>, s <a href="../builtin/index.html#string">string</a>) (matched <a href="../builtin/index.html#bool">bool</a>, err <a href="../builtin/index.html#error">error</a>)</pre>
			<p>MatchString reports whether the string s
contains any match of the regular expression pattern.
More complicated queries need to use <a href="index.html#Compile">Compile</a> and the full <a href="index.html#Regexp">Regexp</a> interface.

			<div id="example_MatchString" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">matched, err := regexp.MatchString(`foo.*`, &#34;seafood&#34;)
fmt.Println(matched, err)
matched, err = regexp.MatchString(`bar.*`, &#34;seafood&#34;)
fmt.Println(matched, err)
matched, err = regexp.MatchString(`a(b`, &#34;seafood&#34;)
fmt.Println(matched, err)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true &lt;nil&gt;
false &lt;nil&gt;
false error parsing regexp: missing closing ): `a(b`
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="QuoteMeta">func <a href="../../src/regexp/regexp.go?s=22734:22765#L716">QuoteMeta</a>
				<a class="permalink" href="index.html#QuoteMeta">&#xb6;</a>
				
				
			</h2>
			<pre>func QuoteMeta(s <a href="../builtin/index.html#string">string</a>) <a href="../builtin/index.html#string">string</a></pre>
			<p>QuoteMeta returns a string that escapes all regular expression metacharacters
inside the argument text; the returned string is a regular expression matching
the literal text.

			<div id="example_QuoteMeta" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Println(regexp.QuoteMeta(`Escaping symbols like: .+*?()|[]{}^$`))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">Escaping symbols like: \.\+\*\?\(\)\|\[\]\{\}\^\$
</pre>
			
		
	</div>
</div>

			

		
		
			
			
			<h2 id="Regexp">type <a href="../../src/regexp/regexp.go?s=3586:4559#L74">Regexp</a>
				<a class="permalink" href="index.html#Regexp">&#xb6;</a>
				
				
			</h2>
			<p>Regexp is the representation of a compiled regular expression.
A Regexp is safe for concurrent use by multiple goroutines,
except for configuration methods, such as <a href="index.html#Regexp.Longest">Regexp.Longest</a>.

			<pre>type Regexp struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="Compile">func <a href="../../src/regexp/regexp.go?s=5824:5866#L124">Compile</a>
					<a class="permalink" href="index.html#Compile">&#xb6;</a>
					
					
				</h3>
				<pre>func Compile(expr <a href="../builtin/index.html#string">string</a>) (*<a href="index.html#Regexp">Regexp</a>, <a href="../builtin/index.html#error">error</a>)</pre>
				<p>Compile parses a regular expression and returns, if successful,
a <a href="index.html#Regexp">Regexp</a> object that can be used to match against text.
<p>When matching against text, the regexp returns a match that
begins as early as possible in the input (leftmost), and among those
it chooses the one that a backtracking search would have found first.
This so-called leftmost-first matching is the same semantics
that Perl, Python, and other implementations use, although this
package implements it without the expense of backtracking.
For POSIX leftmost-longest matching, see <a href="index.html#CompilePOSIX">CompilePOSIX</a>.

				
				
			
				
				<h3 id="CompilePOSIX">func <a href="../../src/regexp/regexp.go?s=6988:7035#L147">CompilePOSIX</a>
					<a class="permalink" href="index.html#CompilePOSIX">&#xb6;</a>
					
					
				</h3>
				<pre>func CompilePOSIX(expr <a href="../builtin/index.html#string">string</a>) (*<a href="index.html#Regexp">Regexp</a>, <a href="../builtin/index.html#error">error</a>)</pre>
				<p>CompilePOSIX is like <a href="index.html#Compile">Compile</a> but restricts the regular expression
to POSIX ERE (egrep) syntax and changes the match semantics to
leftmost-longest.
<p>That is, when matching against text, the regexp returns a match that
begins as early as possible in the input (leftmost), and among those
it chooses a match that is as long as possible.
This so-called leftmost-longest matching is the same semantics
that early regular expression implementations used and that POSIX
specifies.
<p>However, there can be multiple leftmost-longest matches, with different
submatch choices, and here this package diverges from POSIX.
Among the possible leftmost-longest matches, this package chooses
the one that a backtracking search would have found first, while POSIX
specifies that the match be chosen to maximize the length of the first
subexpression, then the second, and so on from left to right.
The POSIX rule is computationally prohibitive and not even well-defined.
See <a href="https://swtch.com/~rsc/regexp/regexp2.html#posix">https://swtch.com/~rsc/regexp/regexp2.html#posix</a> for details.

				
				
			
				
				<h3 id="MustCompile">func <a href="../../src/regexp/regexp.go?s=11002:11038#L304">MustCompile</a>
					<a class="permalink" href="index.html#MustCompile">&#xb6;</a>
					
					
				</h3>
				<pre>func MustCompile(str <a href="../builtin/index.html#string">string</a>) *<a href="index.html#Regexp">Regexp</a></pre>
				<p>MustCompile is like <a href="index.html#Compile">Compile</a> but panics if the expression cannot be parsed.
It simplifies safe initialization of global variables holding compiled regular
expressions.

				
				
			
				
				<h3 id="MustCompilePOSIX">func <a href="../../src/regexp/regexp.go?s=11359:11400#L315">MustCompilePOSIX</a>
					<a class="permalink" href="index.html#MustCompilePOSIX">&#xb6;</a>
					
					
				</h3>
				<pre>func MustCompilePOSIX(str <a href="../builtin/index.html#string">string</a>) *<a href="index.html#Regexp">Regexp</a></pre>
				<p>MustCompilePOSIX is like <a href="index.html#CompilePOSIX">CompilePOSIX</a> but panics if the expression cannot be parsed.
It simplifies safe initialization of global variables holding compiled regular
expressions.

				
				
			

			
				
				<h3 id="Regexp.Copy">func (*Regexp) <a href="../../src/regexp/regexp.go?s=5169:5201#L109">Copy</a>
					<a class="permalink" href="index.html#Regexp.Copy">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) Copy() *<a href="index.html#Regexp">Regexp</a></pre>
				<p>Copy returns a new <a href="index.html#Regexp">Regexp</a> object copied from re.
Calling <a href="index.html#Regexp.Longest">Regexp.Longest</a> on one copy does not affect another.
<p>Deprecated: In earlier releases, when using a <a href="index.html#Regexp">Regexp</a> in multiple goroutines,
giving each goroutine its own copy helped to avoid lock contention.
As of Go 1.12, using Copy is no longer necessary to avoid lock contention.
Copy may still be appropriate if the reason for its use is to make
two copies with different <a href="index.html#Regexp.Longest">Regexp.Longest</a> settings.

				
				
				
			
				
				<h3 id="Regexp.Expand">func (*Regexp) <a href="../../src/regexp/regexp.go?s=28307:28392#L909">Expand</a>
					<a class="permalink" href="index.html#Regexp.Expand">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) Expand(dst []<a href="../builtin/index.html#byte">byte</a>, template []<a href="../builtin/index.html#byte">byte</a>, src []<a href="../builtin/index.html#byte">byte</a>, match []<a href="../builtin/index.html#int">int</a>) []<a href="../builtin/index.html#byte">byte</a></pre>
				<p>Expand appends template to dst and returns the result; during the
append, Expand replaces variables in the template with corresponding
matches drawn from src. The match slice should have been returned by
<a href="index.html#Regexp.FindSubmatchIndex">Regexp.FindSubmatchIndex</a>.
<p>In the template, a variable is denoted by a substring of the form
$name or ${name}, where name is a non-empty sequence of letters,
digits, and underscores. A purely numeric name like $1 refers to
the submatch with the corresponding index; other names refer to
capturing parentheses named with the (?P&lt;name&gt;...) syntax. A
reference to an out of range or unmatched index or a name that is not
present in the regular expression is replaced with an empty slice.
<p>In the $name form, name is taken to be as long as possible: $1x is
equivalent to ${1x}, not ${1}x, and, $10 is equivalent to ${10}, not ${1}0.
<p>To insert a literal $ in the output, use $$ in the template.

				
				<div id="example_Regexp_Expand" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">content := []byte(`
    # comment line
    option1: value1
    option2: value2

    # another comment line
    option3: value3
`)

<span class="comment">// Regex pattern captures &#34;key: value&#34; pair from the content.</span>
pattern := regexp.MustCompile(`(?m)(?P&lt;key&gt;\w+):\s+(?P&lt;value&gt;\w+)$`)

<span class="comment">// Template to convert &#34;key: value&#34; to &#34;key=value&#34; by</span>
<span class="comment">// referencing the values captured by the regex pattern.</span>
template := []byte(&#34;$key=$value\n&#34;)

result := []byte{}

<span class="comment">// For each match of the regex in the content.</span>
for _, submatches := range pattern.FindAllSubmatchIndex(content, -1) {
    <span class="comment">// Apply the captured submatches to the template and append the output</span>
    <span class="comment">// to the result.</span>
    result = pattern.Expand(result, template, content, submatches)
}
fmt.Println(string(result))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">option1=value1
option2=value2
option3=value3
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.ExpandString">func (*Regexp) <a href="../../src/regexp/regexp.go?s=28640:28731#L916">ExpandString</a>
					<a class="permalink" href="index.html#Regexp.ExpandString">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) ExpandString(dst []<a href="../builtin/index.html#byte">byte</a>, template <a href="../builtin/index.html#string">string</a>, src <a href="../builtin/index.html#string">string</a>, match []<a href="../builtin/index.html#int">int</a>) []<a href="../builtin/index.html#byte">byte</a></pre>
				<p>ExpandString is like <a href="index.html#Regexp.Expand">Regexp.Expand</a> but the template and source are strings.
It appends to and returns a byte slice in order to give the calling
code control over allocation.

				
				<div id="example_Regexp_ExpandString" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">content := `
    # comment line
    option1: value1
    option2: value2

    # another comment line
    option3: value3
`

<span class="comment">// Regex pattern captures &#34;key: value&#34; pair from the content.</span>
pattern := regexp.MustCompile(`(?m)(?P&lt;key&gt;\w+):\s+(?P&lt;value&gt;\w+)$`)

<span class="comment">// Template to convert &#34;key: value&#34; to &#34;key=value&#34; by</span>
<span class="comment">// referencing the values captured by the regex pattern.</span>
template := &#34;$key=$value\n&#34;

result := []byte{}

<span class="comment">// For each match of the regex in the content.</span>
for _, submatches := range pattern.FindAllStringSubmatchIndex(content, -1) {
    <span class="comment">// Apply the captured submatches to the template and append the output</span>
    <span class="comment">// to the result.</span>
    result = pattern.ExpandString(result, template, content, submatches)
}
fmt.Println(string(result))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">option1=value1
option2=value2
option3=value3
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.Find">func (*Regexp) <a href="../../src/regexp/regexp.go?s=24845:24884#L812">Find</a>
					<a class="permalink" href="index.html#Regexp.Find">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) Find(b []<a href="../builtin/index.html#byte">byte</a>) []<a href="../builtin/index.html#byte">byte</a></pre>
				<p>Find returns a slice holding the text of the leftmost match in b of the regular expression.
A return value of nil indicates no match.

				
				<div id="example_Regexp_Find" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">re := regexp.MustCompile(`foo.?`)
fmt.Printf(&#34;%q\n&#34;, re.Find([]byte(`seafood fool`)))

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">&#34;food&#34;
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.FindAll">func (*Regexp) <a href="../../src/regexp/regexp.go?s=33167:33218#L1071">FindAll</a>
					<a class="permalink" href="index.html#Regexp.FindAll">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) FindAll(b []<a href="../builtin/index.html#byte">byte</a>, n <a href="../builtin/index.html#int">int</a>) [][]<a href="../builtin/index.html#byte">byte</a></pre>
				<p>FindAll is the &apos;All&apos; version of Find; it returns a slice of all successive
matches of the expression, as defined by the &apos;All&apos; description in the
package comment.
A return value of nil indicates no match.

				
				<div id="example_Regexp_FindAll" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">re := regexp.MustCompile(`foo.?`)
fmt.Printf(&#34;%q\n&#34;, re.FindAll([]byte(`seafood fool`), -1))

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[&#34;food&#34; &#34;fool&#34;]
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.FindAllIndex">func (*Regexp) <a href="../../src/regexp/regexp.go?s=33699:33754#L1089">FindAllIndex</a>
					<a class="permalink" href="index.html#Regexp.FindAllIndex">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) FindAllIndex(b []<a href="../builtin/index.html#byte">byte</a>, n <a href="../builtin/index.html#int">int</a>) [][]<a href="../builtin/index.html#int">int</a></pre>
				<p>FindAllIndex is the &apos;All&apos; version of <a href="index.html#Regexp.FindIndex">Regexp.FindIndex</a>; it returns a slice of all
successive matches of the expression, as defined by the &apos;All&apos; description
in the package comment.
A return value of nil indicates no match.

				
				<div id="example_Regexp_FindAllIndex" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">content := []byte(&#34;London&#34;)
re := regexp.MustCompile(`o.`)
fmt.Println(re.FindAllIndex(content, 1))
fmt.Println(re.FindAllIndex(content, -1))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[[1 3]]
[[1 3] [4 6]]
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.FindAllString">func (*Regexp) <a href="../../src/regexp/regexp.go?s=34216:34273#L1107">FindAllString</a>
					<a class="permalink" href="index.html#Regexp.FindAllString">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) FindAllString(s <a href="../builtin/index.html#string">string</a>, n <a href="../builtin/index.html#int">int</a>) []<a href="../builtin/index.html#string">string</a></pre>
				<p>FindAllString is the &apos;All&apos; version of <a href="index.html#Regexp.FindString">Regexp.FindString</a>; it returns a slice of all
successive matches of the expression, as defined by the &apos;All&apos; description
in the package comment.
A return value of nil indicates no match.

				
				<div id="example_Regexp_FindAllString" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">re := regexp.MustCompile(`a.`)
fmt.Println(re.FindAllString(&#34;paranormal&#34;, -1))
fmt.Println(re.FindAllString(&#34;paranormal&#34;, 2))
fmt.Println(re.FindAllString(&#34;graal&#34;, -1))
fmt.Println(re.FindAllString(&#34;none&#34;, -1))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[ar an al]
[ar an]
[aa]
[]
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.FindAllStringIndex">func (*Regexp) <a href="../../src/regexp/regexp.go?s=34758:34819#L1125">FindAllStringIndex</a>
					<a class="permalink" href="index.html#Regexp.FindAllStringIndex">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) FindAllStringIndex(s <a href="../builtin/index.html#string">string</a>, n <a href="../builtin/index.html#int">int</a>) [][]<a href="../builtin/index.html#int">int</a></pre>
				<p>FindAllStringIndex is the &apos;All&apos; version of <a href="index.html#Regexp.FindStringIndex">Regexp.FindStringIndex</a>; it returns a
slice of all successive matches of the expression, as defined by the &apos;All&apos;
description in the package comment.
A return value of nil indicates no match.

				
				
				
			
				
				<h3 id="Regexp.FindAllStringSubmatch">func (*Regexp) <a href="../../src/regexp/regexp.go?s=36513:36580#L1185">FindAllStringSubmatch</a>
					<a class="permalink" href="index.html#Regexp.FindAllStringSubmatch">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) FindAllStringSubmatch(s <a href="../builtin/index.html#string">string</a>, n <a href="../builtin/index.html#int">int</a>) [][]<a href="../builtin/index.html#string">string</a></pre>
				<p>FindAllStringSubmatch is the &apos;All&apos; version of <a href="index.html#Regexp.FindStringSubmatch">Regexp.FindStringSubmatch</a>; it
returns a slice of all successive matches of the expression, as defined by
the &apos;All&apos; description in the package comment.
A return value of nil indicates no match.

				
				<div id="example_Regexp_FindAllStringSubmatch" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">re := regexp.MustCompile(`a(x*)b`)
fmt.Printf(&#34;%q\n&#34;, re.FindAllStringSubmatch(&#34;-ab-&#34;, -1))
fmt.Printf(&#34;%q\n&#34;, re.FindAllStringSubmatch(&#34;-axxb-&#34;, -1))
fmt.Printf(&#34;%q\n&#34;, re.FindAllStringSubmatch(&#34;-ab-axb-&#34;, -1))
fmt.Printf(&#34;%q\n&#34;, re.FindAllStringSubmatch(&#34;-axxb-ab-&#34;, -1))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[[&#34;ab&#34; &#34;&#34;]]
[[&#34;axxb&#34; &#34;xx&#34;]]
[[&#34;ab&#34; &#34;&#34;] [&#34;axb&#34; &#34;x&#34;]]
[[&#34;axxb&#34; &#34;xx&#34;] [&#34;ab&#34; &#34;&#34;]]
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.FindAllStringSubmatchIndex">func (*Regexp) <a href="../../src/regexp/regexp.go?s=37213:37282#L1210">FindAllStringSubmatchIndex</a>
					<a class="permalink" href="index.html#Regexp.FindAllStringSubmatchIndex">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) FindAllStringSubmatchIndex(s <a href="../builtin/index.html#string">string</a>, n <a href="../builtin/index.html#int">int</a>) [][]<a href="../builtin/index.html#int">int</a></pre>
				<p>FindAllStringSubmatchIndex is the &apos;All&apos; version of
<a href="index.html#Regexp.FindStringSubmatchIndex">Regexp.FindStringSubmatchIndex</a>; it returns a slice of all successive matches of
the expression, as defined by the &apos;All&apos; description in the package
comment.
A return value of nil indicates no match.

				
				<div id="example_Regexp_FindAllStringSubmatchIndex" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">re := regexp.MustCompile(`a(x*)b`)
<span class="comment">// Indices:</span>
<span class="comment">//    01234567   012345678</span>
<span class="comment">//    -ab-axb-   -axxb-ab-</span>
fmt.Println(re.FindAllStringSubmatchIndex(&#34;-ab-&#34;, -1))
fmt.Println(re.FindAllStringSubmatchIndex(&#34;-axxb-&#34;, -1))
fmt.Println(re.FindAllStringSubmatchIndex(&#34;-ab-axb-&#34;, -1))
fmt.Println(re.FindAllStringSubmatchIndex(&#34;-axxb-ab-&#34;, -1))
fmt.Println(re.FindAllStringSubmatchIndex(&#34;-foo-&#34;, -1))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[[1 3 2 2]]
[[1 5 2 4]]
[[1 3 2 2] [4 7 5 6]]
[[1 5 2 4] [6 8 7 7]]
[]
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.FindAllSubmatch">func (*Regexp) <a href="../../src/regexp/regexp.go?s=35286:35347#L1143">FindAllSubmatch</a>
					<a class="permalink" href="index.html#Regexp.FindAllSubmatch">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) FindAllSubmatch(b []<a href="../builtin/index.html#byte">byte</a>, n <a href="../builtin/index.html#int">int</a>) [][][]<a href="../builtin/index.html#byte">byte</a></pre>
				<p>FindAllSubmatch is the &apos;All&apos; version of <a href="index.html#Regexp.FindSubmatch">Regexp.FindSubmatch</a>; it returns a slice
of all successive matches of the expression, as defined by the &apos;All&apos;
description in the package comment.
A return value of nil indicates no match.

				
				<div id="example_Regexp_FindAllSubmatch" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">re := regexp.MustCompile(`foo(.?)`)
fmt.Printf(&#34;%q\n&#34;, re.FindAllSubmatch([]byte(`seafood fool`), -1))

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[[&#34;food&#34; &#34;d&#34;] [&#34;fool&#34; &#34;l&#34;]]
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.FindAllSubmatchIndex">func (*Regexp) <a href="../../src/regexp/regexp.go?s=35977:36040#L1167">FindAllSubmatchIndex</a>
					<a class="permalink" href="index.html#Regexp.FindAllSubmatchIndex">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) FindAllSubmatchIndex(b []<a href="../builtin/index.html#byte">byte</a>, n <a href="../builtin/index.html#int">int</a>) [][]<a href="../builtin/index.html#int">int</a></pre>
				<p>FindAllSubmatchIndex is the &apos;All&apos; version of <a href="index.html#Regexp.FindSubmatchIndex">Regexp.FindSubmatchIndex</a>; it returns
a slice of all successive matches of the expression, as defined by the
&apos;All&apos; description in the package comment.
A return value of nil indicates no match.

				
				<div id="example_Regexp_FindAllSubmatchIndex" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">content := []byte(`
    # comment line
    option1: value1
    option2: value2
`)
<span class="comment">// Regex pattern captures &#34;key: value&#34; pair from the content.</span>
pattern := regexp.MustCompile(`(?m)(?P&lt;key&gt;\w+):\s+(?P&lt;value&gt;\w+)$`)
allIndexes := pattern.FindAllSubmatchIndex(content, -1)
for _, loc := range allIndexes {
    fmt.Println(loc)
    fmt.Println(string(content[loc[0]:loc[1]]))
    fmt.Println(string(content[loc[2]:loc[3]]))
    fmt.Println(string(content[loc[4]:loc[5]]))
}
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[18 33 18 25 27 33]
option1: value1
option1
value1
[35 50 35 42 44 50]
option2: value2
option2
value2
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.FindIndex">func (*Regexp) <a href="../../src/regexp/regexp.go?s=25236:25285#L825">FindIndex</a>
					<a class="permalink" href="index.html#Regexp.FindIndex">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) FindIndex(b []<a href="../builtin/index.html#byte">byte</a>) (loc []<a href="../builtin/index.html#int">int</a>)</pre>
				<p>FindIndex returns a two-element slice of integers defining the location of
the leftmost match in b of the regular expression. The match itself is at
b[loc[0]:loc[1]].
A return value of nil indicates no match.

				
				<div id="example_Regexp_FindIndex" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">content := []byte(`
    # comment line
    option1: value1
    option2: value2
`)
<span class="comment">// Regex pattern captures &#34;key: value&#34; pair from the content.</span>
pattern := regexp.MustCompile(`(?m)(?P&lt;key&gt;\w+):\s+(?P&lt;value&gt;\w+)$`)

loc := pattern.FindIndex(content)
fmt.Println(loc)
fmt.Println(string(content[loc[0]:loc[1]]))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[18 33]
option1: value1
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.FindReaderIndex">func (*Regexp) <a href="../../src/regexp/regexp.go?s=26604:26666#L864">FindReaderIndex</a>
					<a class="permalink" href="index.html#Regexp.FindReaderIndex">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) FindReaderIndex(r <a href="../io/index.html">io</a>.<a href="../io/index.html#RuneReader">RuneReader</a>) (loc []<a href="../builtin/index.html#int">int</a>)</pre>
				<p>FindReaderIndex returns a two-element slice of integers defining the
location of the leftmost match of the regular expression in text read from
the <a href="http://localhost:8080/io#RuneReader">io.RuneReader</a>. The match text was found in the input stream at
byte offset loc[0] through loc[1]-1.
A return value of nil indicates no match.

				
				
				
			
				
				<h3 id="Regexp.FindReaderSubmatchIndex">func (*Regexp) <a href="../../src/regexp/regexp.go?s=32733:32797#L1061">FindReaderSubmatchIndex</a>
					<a class="permalink" href="index.html#Regexp.FindReaderSubmatchIndex">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) FindReaderSubmatchIndex(r <a href="../io/index.html">io</a>.<a href="../io/index.html#RuneReader">RuneReader</a>) []<a href="../builtin/index.html#int">int</a></pre>
				<p>FindReaderSubmatchIndex returns a slice holding the index pairs
identifying the leftmost match of the regular expression of text read by
the <a href="http://localhost:8080/io#RuneReader">io.RuneReader</a>, and the matches, if any, of its subexpressions, as defined
by the &apos;Submatch&apos; and &apos;Index&apos; descriptions in the package comment. A
return value of nil indicates no match.

				
				
				
			
				
				<h3 id="Regexp.FindString">func (*Regexp) <a href="../../src/regexp/regexp.go?s=25749:25794#L838">FindString</a>
					<a class="permalink" href="index.html#Regexp.FindString">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) FindString(s <a href="../builtin/index.html#string">string</a>) <a href="../builtin/index.html#string">string</a></pre>
				<p>FindString returns a string holding the text of the leftmost match in s of the regular
expression. If there is no match, the return value is an empty string,
but it will also be empty if the regular expression successfully matches
an empty string. Use <a href="index.html#Regexp.FindStringIndex">Regexp.FindStringIndex</a> or <a href="index.html#Regexp.FindStringSubmatch">Regexp.FindStringSubmatch</a> if it is
necessary to distinguish these cases.

				
				<div id="example_Regexp_FindString" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">re := regexp.MustCompile(`foo.?`)
fmt.Printf(&#34;%q\n&#34;, re.FindString(&#34;seafood fool&#34;))
fmt.Printf(&#34;%q\n&#34;, re.FindString(&#34;meat&#34;))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">&#34;food&#34;
&#34;&#34;
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.FindStringIndex">func (*Regexp) <a href="../../src/regexp/regexp.go?s=26147:26202#L851">FindStringIndex</a>
					<a class="permalink" href="index.html#Regexp.FindStringIndex">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) FindStringIndex(s <a href="../builtin/index.html#string">string</a>) (loc []<a href="../builtin/index.html#int">int</a>)</pre>
				<p>FindStringIndex returns a two-element slice of integers defining the
location of the leftmost match in s of the regular expression. The match
itself is at s[loc[0]:loc[1]].
A return value of nil indicates no match.

				
				<div id="example_Regexp_FindStringIndex" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">re := regexp.MustCompile(`ab?`)
fmt.Println(re.FindStringIndex(&#34;tablett&#34;))
fmt.Println(re.FindStringIndex(&#34;foo&#34;) == nil)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[1 3]
true
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.FindStringSubmatch">func (*Regexp) <a href="../../src/regexp/regexp.go?s=31634:31689#L1032">FindStringSubmatch</a>
					<a class="permalink" href="index.html#Regexp.FindStringSubmatch">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) FindStringSubmatch(s <a href="../builtin/index.html#string">string</a>) []<a href="../builtin/index.html#string">string</a></pre>
				<p>FindStringSubmatch returns a slice of strings holding the text of the
leftmost match of the regular expression in s and the matches, if any, of
its subexpressions, as defined by the &apos;Submatch&apos; description in the
package comment.
A return value of nil indicates no match.

				
				<div id="example_Regexp_FindStringSubmatch" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">re := regexp.MustCompile(`a(x*)b(y|z)c`)
fmt.Printf(&#34;%q\n&#34;, re.FindStringSubmatch(&#34;-axxxbyc-&#34;))
fmt.Printf(&#34;%q\n&#34;, re.FindStringSubmatch(&#34;-abzc-&#34;))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[&#34;axxxbyc&#34; &#34;xxx&#34; &#34;y&#34;]
[&#34;abzc&#34; &#34;&#34; &#34;z&#34;]
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.FindStringSubmatchIndex">func (*Regexp) <a href="../../src/regexp/regexp.go?s=32263:32320#L1052">FindStringSubmatchIndex</a>
					<a class="permalink" href="index.html#Regexp.FindStringSubmatchIndex">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) FindStringSubmatchIndex(s <a href="../builtin/index.html#string">string</a>) []<a href="../builtin/index.html#int">int</a></pre>
				<p>FindStringSubmatchIndex returns a slice holding the index pairs
identifying the leftmost match of the regular expression in s and the
matches, if any, of its subexpressions, as defined by the &apos;Submatch&apos; and
&apos;Index&apos; descriptions in the package comment.
A return value of nil indicates no match.

				
				
				
			
				
				<h3 id="Regexp.FindSubmatch">func (*Regexp) <a href="../../src/regexp/regexp.go?s=27040:27089#L877">FindSubmatch</a>
					<a class="permalink" href="index.html#Regexp.FindSubmatch">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) FindSubmatch(b []<a href="../builtin/index.html#byte">byte</a>) [][]<a href="../builtin/index.html#byte">byte</a></pre>
				<p>FindSubmatch returns a slice of slices holding the text of the leftmost
match of the regular expression in b and the matches, if any, of its
subexpressions, as defined by the &apos;Submatch&apos; descriptions in the package
comment.
A return value of nil indicates no match.

				
				<div id="example_Regexp_FindSubmatch" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">re := regexp.MustCompile(`foo(.?)`)
fmt.Printf(&#34;%q\n&#34;, re.FindSubmatch([]byte(`seafood fool`)))

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[&#34;food&#34; &#34;d&#34;]
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.FindSubmatchIndex">func (*Regexp) <a href="../../src/regexp/regexp.go?s=31226:31277#L1023">FindSubmatchIndex</a>
					<a class="permalink" href="index.html#Regexp.FindSubmatchIndex">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) FindSubmatchIndex(b []<a href="../builtin/index.html#byte">byte</a>) []<a href="../builtin/index.html#int">int</a></pre>
				<p>FindSubmatchIndex returns a slice holding the index pairs identifying the
leftmost match of the regular expression in b and the matches, if any, of
its subexpressions, as defined by the &apos;Submatch&apos; and &apos;Index&apos; descriptions
in the package comment.
A return value of nil indicates no match.

				
				<div id="example_Regexp_FindSubmatchIndex" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">re := regexp.MustCompile(`a(x*)b`)
<span class="comment">// Indices:</span>
<span class="comment">//    01234567   012345678</span>
<span class="comment">//    -ab-axb-   -axxb-ab-</span>
fmt.Println(re.FindSubmatchIndex([]byte(&#34;-ab-&#34;)))
fmt.Println(re.FindSubmatchIndex([]byte(&#34;-axxb-&#34;)))
fmt.Println(re.FindSubmatchIndex([]byte(&#34;-ab-axb-&#34;)))
fmt.Println(re.FindSubmatchIndex([]byte(&#34;-axxb-ab-&#34;)))
fmt.Println(re.FindSubmatchIndex([]byte(&#34;-foo-&#34;)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[1 3 2 2]
[1 5 2 4]
[1 3 2 2]
[1 5 2 4]
[]
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.LiteralPrefix">func (*Regexp) <a href="../../src/regexp/regexp.go?s=15961:16025#L508">LiteralPrefix</a>
					<a class="permalink" href="index.html#Regexp.LiteralPrefix">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) LiteralPrefix() (prefix <a href="../builtin/index.html#string">string</a>, complete <a href="../builtin/index.html#bool">bool</a>)</pre>
				<p>LiteralPrefix returns a literal string that must begin any match
of the regular expression re. It returns the boolean true if the
literal string comprises the entire regular expression.

				
				
				
			
				
				<h3 id="Regexp.Longest">func (*Regexp) <a href="../../src/regexp/regexp.go?s=7445:7472#L157">Longest</a>
					<a class="permalink" href="index.html#Regexp.Longest">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) Longest()</pre>
				<p>Longest makes future searches prefer the leftmost-longest match.
That is, when matching against text, the regexp returns a match that
begins as early as possible in the input (leftmost), and among those
it chooses a match that is as long as possible.
This method modifies the <a href="index.html#Regexp">Regexp</a> and may not be called concurrently
with any other methods.

				
				<div id="example_Regexp_Longest" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">re := regexp.MustCompile(`a(|b)`)
fmt.Println(re.FindString(&#34;ab&#34;))
re.Longest()
fmt.Println(re.FindString(&#34;ab&#34;))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">a
ab
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.MarshalText">func (*Regexp) <a href="../../src/regexp/regexp.go?s=39086:39133#L1281">MarshalText</a>
					<a class="permalink" href="index.html#Regexp.MarshalText">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) MarshalText() ([]<a href="../builtin/index.html#byte">byte</a>, <a href="../builtin/index.html#error">error</a>)</pre>
				<p>MarshalText implements <a href="http://localhost:8080/encoding#TextMarshaler">encoding.TextMarshaler</a>. The output
matches that of calling the <a href="index.html#Regexp.String">Regexp.String</a> method.
<p>Note that the output is lossy in some cases: This method does not indicate
POSIX regular expressions (i.e. those compiled by calling <a href="index.html#CompilePOSIX">CompilePOSIX</a>), or
those for which the <a href="index.html#Regexp.Longest">Regexp.Longest</a> method has been called.

				
				
				
			
				
				<h3 id="Regexp.Match">func (*Regexp) <a href="../../src/regexp/regexp.go?s=16552:16590#L526">Match</a>
					<a class="permalink" href="index.html#Regexp.Match">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) Match(b []<a href="../builtin/index.html#byte">byte</a>) <a href="../builtin/index.html#bool">bool</a></pre>
				<p>Match reports whether the byte slice b
contains any match of the regular expression re.

				
				<div id="example_Regexp_Match" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">re := regexp.MustCompile(`foo.?`)
fmt.Println(re.Match([]byte(`seafood fool`)))
fmt.Println(re.Match([]byte(`something else`)))

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true
false
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.MatchReader">func (*Regexp) <a href="../../src/regexp/regexp.go?s=16192:16243#L514">MatchReader</a>
					<a class="permalink" href="index.html#Regexp.MatchReader">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) MatchReader(r <a href="../io/index.html">io</a>.<a href="../io/index.html#RuneReader">RuneReader</a>) <a href="../builtin/index.html#bool">bool</a></pre>
				<p>MatchReader reports whether the text returned by the <a href="http://localhost:8080/io#RuneReader">io.RuneReader</a>
contains any match of the regular expression re.

				
				
				
			
				
				<h3 id="Regexp.MatchString">func (*Regexp) <a href="../../src/regexp/regexp.go?s=16376:16420#L520">MatchString</a>
					<a class="permalink" href="index.html#Regexp.MatchString">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) MatchString(s <a href="../builtin/index.html#string">string</a>) <a href="../builtin/index.html#bool">bool</a></pre>
				<p>MatchString reports whether the string s
contains any match of the regular expression re.

				
				<div id="example_Regexp_MatchString" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">re := regexp.MustCompile(`(gopher){2}`)
fmt.Println(re.MatchString(&#34;gopher&#34;))
fmt.Println(re.MatchString(&#34;gophergopher&#34;))
fmt.Println(re.MatchString(&#34;gophergophergopher&#34;))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">false
true
true
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.NumSubexp">func (*Regexp) <a href="../../src/regexp/regexp.go?s=11739:11772#L331">NumSubexp</a>
					<a class="permalink" href="index.html#Regexp.NumSubexp">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) NumSubexp() <a href="../builtin/index.html#int">int</a></pre>
				<p>NumSubexp returns the number of parenthesized subexpressions in this <a href="index.html#Regexp">Regexp</a>.

				
				<div id="example_Regexp_NumSubexp" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">re0 := regexp.MustCompile(`a.`)
fmt.Printf(&#34;%d\n&#34;, re0.NumSubexp())

re := regexp.MustCompile(`(.*)((a)b)(.*)a`)
fmt.Println(re.NumSubexp())
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">0
4
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.ReplaceAll">func (*Regexp) <a href="../../src/regexp/regexp.go?s=20986:21039#L665">ReplaceAll</a>
					<a class="permalink" href="index.html#Regexp.ReplaceAll">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) ReplaceAll(src, repl []<a href="../builtin/index.html#byte">byte</a>) []<a href="../builtin/index.html#byte">byte</a></pre>
				<p>ReplaceAll returns a copy of src, replacing matches of the <a href="index.html#Regexp">Regexp</a>
with the replacement text repl.
Inside repl, $ signs are interpreted as in <a href="index.html#Regexp.Expand">Regexp.Expand</a>.

				
				<div id="example_Regexp_ReplaceAll" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">re := regexp.MustCompile(`a(x*)b`)
fmt.Printf(&#34;%s\n&#34;, re.ReplaceAll([]byte(&#34;-ab-axxb-&#34;), []byte(&#34;T&#34;)))
fmt.Printf(&#34;%s\n&#34;, re.ReplaceAll([]byte(&#34;-ab-axxb-&#34;), []byte(&#34;$1&#34;)))
fmt.Printf(&#34;%s\n&#34;, re.ReplaceAll([]byte(&#34;-ab-axxb-&#34;), []byte(&#34;$1W&#34;)))
fmt.Printf(&#34;%s\n&#34;, re.ReplaceAll([]byte(&#34;-ab-axxb-&#34;), []byte(&#34;${1}W&#34;)))

re2 := regexp.MustCompile(`a(?P&lt;1W&gt;x*)b`)
fmt.Printf(&#34;%s\n&#34;, re2.ReplaceAll([]byte(&#34;-ab-axxb-&#34;), []byte(&#34;$1W&#34;)))
fmt.Printf(&#34;%s\n&#34;, re2.ReplaceAll([]byte(&#34;-ab-axxb-&#34;), []byte(&#34;${1}W&#34;)))

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">-T-T-
--xx-
---
-W-xxW-
--xx-
-W-xxW-
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.ReplaceAllFunc">func (*Regexp) <a href="../../src/regexp/regexp.go?s=21960:22037#L693">ReplaceAllFunc</a>
					<a class="permalink" href="index.html#Regexp.ReplaceAllFunc">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) ReplaceAllFunc(src []<a href="../builtin/index.html#byte">byte</a>, repl func([]<a href="../builtin/index.html#byte">byte</a>) []<a href="../builtin/index.html#byte">byte</a>) []<a href="../builtin/index.html#byte">byte</a></pre>
				<p>ReplaceAllFunc returns a copy of src in which all matches of the
<a href="index.html#Regexp">Regexp</a> have been replaced by the return value of function repl applied
to the matched byte slice. The replacement returned by repl is substituted
directly, without using <a href="index.html#Regexp.Expand">Regexp.Expand</a>.

				
				
				
			
				
				<h3 id="Regexp.ReplaceAllLiteral">func (*Regexp) <a href="../../src/regexp/regexp.go?s=21521:21581#L683">ReplaceAllLiteral</a>
					<a class="permalink" href="index.html#Regexp.ReplaceAllLiteral">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) ReplaceAllLiteral(src, repl []<a href="../builtin/index.html#byte">byte</a>) []<a href="../builtin/index.html#byte">byte</a></pre>
				<p>ReplaceAllLiteral returns a copy of src, replacing matches of the <a href="index.html#Regexp">Regexp</a>
with the replacement bytes repl. The replacement repl is substituted directly,
without using <a href="index.html#Regexp.Expand">Regexp.Expand</a>.

				
				
				
			
				
				<h3 id="Regexp.ReplaceAllLiteralString">func (*Regexp) <a href="../../src/regexp/regexp.go?s=18375:18441#L580">ReplaceAllLiteralString</a>
					<a class="permalink" href="index.html#Regexp.ReplaceAllLiteralString">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) ReplaceAllLiteralString(src, repl <a href="../builtin/index.html#string">string</a>) <a href="../builtin/index.html#string">string</a></pre>
				<p>ReplaceAllLiteralString returns a copy of src, replacing matches of the <a href="index.html#Regexp">Regexp</a>
with the replacement string repl. The replacement repl is substituted directly,
without using <a href="index.html#Regexp.Expand">Regexp.Expand</a>.

				
				<div id="example_Regexp_ReplaceAllLiteralString" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">re := regexp.MustCompile(`a(x*)b`)
fmt.Println(re.ReplaceAllLiteralString(&#34;-ab-axxb-&#34;, &#34;T&#34;))
fmt.Println(re.ReplaceAllLiteralString(&#34;-ab-axxb-&#34;, &#34;$1&#34;))
fmt.Println(re.ReplaceAllLiteralString(&#34;-ab-axxb-&#34;, &#34;${1}&#34;))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">-T-T-
-$1-$1-
-${1}-${1}-
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.ReplaceAllString">func (*Regexp) <a href="../../src/regexp/regexp.go?s=17894:17953#L566">ReplaceAllString</a>
					<a class="permalink" href="index.html#Regexp.ReplaceAllString">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) ReplaceAllString(src, repl <a href="../builtin/index.html#string">string</a>) <a href="../builtin/index.html#string">string</a></pre>
				<p>ReplaceAllString returns a copy of src, replacing matches of the <a href="index.html#Regexp">Regexp</a>
with the replacement string repl.
Inside repl, $ signs are interpreted as in <a href="index.html#Regexp.Expand">Regexp.Expand</a>.

				
				<div id="example_Regexp_ReplaceAllString" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">re := regexp.MustCompile(`a(x*)b`)
fmt.Println(re.ReplaceAllString(&#34;-ab-axxb-&#34;, &#34;T&#34;))
fmt.Println(re.ReplaceAllString(&#34;-ab-axxb-&#34;, &#34;$1&#34;))
fmt.Println(re.ReplaceAllString(&#34;-ab-axxb-&#34;, &#34;$1W&#34;))
fmt.Println(re.ReplaceAllString(&#34;-ab-axxb-&#34;, &#34;${1}W&#34;))

re2 := regexp.MustCompile(`a(?P&lt;1W&gt;x*)b`)
fmt.Printf(&#34;%s\n&#34;, re2.ReplaceAllString(&#34;-ab-axxb-&#34;, &#34;$1W&#34;))
fmt.Println(re.ReplaceAllString(&#34;-ab-axxb-&#34;, &#34;${1}W&#34;))

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">-T-T-
--xx-
---
-W-xxW-
--xx-
-W-xxW-
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.ReplaceAllStringFunc">func (*Regexp) <a href="../../src/regexp/regexp.go?s=18834:18917#L590">ReplaceAllStringFunc</a>
					<a class="permalink" href="index.html#Regexp.ReplaceAllStringFunc">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) ReplaceAllStringFunc(src <a href="../builtin/index.html#string">string</a>, repl func(<a href="../builtin/index.html#string">string</a>) <a href="../builtin/index.html#string">string</a>) <a href="../builtin/index.html#string">string</a></pre>
				<p>ReplaceAllStringFunc returns a copy of src in which all matches of the
<a href="index.html#Regexp">Regexp</a> have been replaced by the return value of function repl applied
to the matched substring. The replacement returned by repl is substituted
directly, without using <a href="index.html#Regexp.Expand">Regexp.Expand</a>.

				
				<div id="example_Regexp_ReplaceAllStringFunc" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">re := regexp.MustCompile(`[^aeiou]`)
fmt.Println(re.ReplaceAllStringFunc(&#34;seafood fool&#34;, strings.ToUpper))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">SeaFooD FooL
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.Split">func (*Regexp) <a href="../../src/regexp/regexp.go?s=38223:38272#L1241">Split</a>
					<a class="permalink" href="index.html#Regexp.Split">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) Split(s <a href="../builtin/index.html#string">string</a>, n <a href="../builtin/index.html#int">int</a>) []<a href="../builtin/index.html#string">string</a></pre>
				<p>Split slices s into substrings separated by the expression and returns a slice of
the substrings between those expression matches.
<p>The slice returned by this method consists of all the substrings of s
not contained in the slice returned by <a href="index.html#Regexp.FindAllString">Regexp.FindAllString</a>. When called on an expression
that contains no metacharacters, it is equivalent to <a href="http://localhost:8080/strings#SplitN">strings.SplitN</a>.
<p>Example:
<pre>s := regexp.MustCompile(&quot;a*&quot;).Split(&quot;abaabaccadaaae&quot;, 5)
// s: [&quot;&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;cadaaae&quot;]
</pre>
<p>The count determines the number of substrings to return:
<pre>n &gt; 0: at most n substrings; the last substring will be the unsplit remainder.
n == 0: the result is nil (zero substrings)
n &lt; 0: all substrings
</pre>

				
				<div id="example_Regexp_Split" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">a := regexp.MustCompile(`a`)
fmt.Println(a.Split(&#34;banana&#34;, -1))
fmt.Println(a.Split(&#34;banana&#34;, 0))
fmt.Println(a.Split(&#34;banana&#34;, 1))
fmt.Println(a.Split(&#34;banana&#34;, 2))
zp := regexp.MustCompile(`z+`)
fmt.Println(zp.Split(&#34;pizza&#34;, -1))
fmt.Println(zp.Split(&#34;pizza&#34;, 0))
fmt.Println(zp.Split(&#34;pizza&#34;, 1))
fmt.Println(zp.Split(&#34;pizza&#34;, 2))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[b n n ]
[]
[banana]
[b nana]
[pi a]
[]
[pizza]
[pi a]
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.String">func (*Regexp) <a href="../../src/regexp/regexp.go?s=4635:4668#L97">String</a>
					<a class="permalink" href="index.html#Regexp.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) String() <a href="../builtin/index.html#string">string</a></pre>
				<p>String returns the source text used to compile the regular expression.

				
				
				
			
				
				<h3 id="Regexp.SubexpIndex">func (*Regexp) <a href="../../src/regexp/regexp.go?s=12607:12653#L351">SubexpIndex</a>
					<a class="permalink" href="index.html#Regexp.SubexpIndex">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) SubexpIndex(name <a href="../builtin/index.html#string">string</a>) <a href="../builtin/index.html#int">int</a></pre>
				<p>SubexpIndex returns the index of the first subexpression with the given name,
or -1 if there is no subexpression with that name.
<p>Note that multiple subexpressions can be written using the same name, as in
(?P&lt;bob&gt;a+)(?P&lt;bob&gt;b+), which declares two subexpressions named &quot;bob&quot;.
In this case, SubexpIndex returns the index of the leftmost such subexpression
in the regular expression.

				
				<div id="example_Regexp_SubexpIndex" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">re := regexp.MustCompile(`(?P&lt;first&gt;[a-zA-Z]+) (?P&lt;last&gt;[a-zA-Z]+)`)
fmt.Println(re.MatchString(&#34;Alan Turing&#34;))
matches := re.FindStringSubmatch(&#34;Alan Turing&#34;)
lastIndex := re.SubexpIndex(&#34;last&#34;)
fmt.Printf(&#34;last =&gt; %d\n&#34;, lastIndex)
fmt.Println(matches[lastIndex])
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true
last =&gt; 2
Turing
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.SubexpNames">func (*Regexp) <a href="../../src/regexp/regexp.go?s=12135:12175#L340">SubexpNames</a>
					<a class="permalink" href="index.html#Regexp.SubexpNames">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) SubexpNames() []<a href="../builtin/index.html#string">string</a></pre>
				<p>SubexpNames returns the names of the parenthesized subexpressions
in this <a href="index.html#Regexp">Regexp</a>. The name for the first sub-expression is names[1],
so that if m is a match slice, the name for m[i] is SubexpNames()[i].
Since the Regexp as a whole cannot be named, names[0] is always
the empty string. The slice should not be modified.

				
				<div id="example_Regexp_SubexpNames" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">re := regexp.MustCompile(`(?P&lt;first&gt;[a-zA-Z]+) (?P&lt;last&gt;[a-zA-Z]+)`)
fmt.Println(re.MatchString(&#34;Alan Turing&#34;))
fmt.Printf(&#34;%q\n&#34;, re.SubexpNames())
reversed := fmt.Sprintf(&#34;${%s} ${%s}&#34;, re.SubexpNames()[2], re.SubexpNames()[1])
fmt.Println(reversed)
fmt.Println(re.ReplaceAllString(&#34;Alan Turing&#34;, reversed))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true
[&#34;&#34; &#34;first&#34; &#34;last&#34;]
${last} ${first}
Turing Alan
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Regexp.UnmarshalText">func (*Regexp) <a href="../../src/regexp/regexp.go?s=39273:39323#L1287">UnmarshalText</a>
					<a class="permalink" href="index.html#Regexp.UnmarshalText">&#xb6;</a>
					
					
				</h3>
				<pre>func (re *<a href="index.html#Regexp">Regexp</a>) UnmarshalText(text []<a href="../builtin/index.html#byte">byte</a>) <a href="../builtin/index.html#error">error</a></pre>
				<p>UnmarshalText implements <a href="http://localhost:8080/encoding#TextUnmarshaler">encoding.TextUnmarshaler</a> by calling
<a href="index.html#Compile">Compile</a> on the encoded value.

				
				
				
			
		
	

	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	<div class="pkg-dir">
		<table>
			<tr>
				<th class="pkg-name">Name</th>
				<th class="pkg-synopsis">Synopsis</th>
			</tr>

			
			<tr>
				<td colspan="2"><a href="../../index.html">..</a></td>
			</tr>
			

			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="syntax/index.html">syntax</a>
					</td>
				
					<td class="pkg-synopsis">
						Package syntax parses regular expressions into parse trees and compiles parse trees into programs.
					</td>
				</tr>
			
		</table>
	</div>



<div id="footer">
Build version go1.22.2.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:8080/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
