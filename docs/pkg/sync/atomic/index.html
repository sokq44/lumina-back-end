<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>atomic - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="../../../lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="../../../lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.22.2";</script>
<script src="../../../lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="../../../index.html">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="../../../index.html">GoDoc</a></div>
<a href="index.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:8080/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package atomic
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "sync/atomic"</code></dd>
			</dl>
			<dl>
			<dd><a href="index.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="index.html#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="index.html#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package atomic provides low-level atomic memory primitives
useful for implementing synchronization algorithms.
<p>These functions require great care to be used correctly.
Except for special, low-level applications, synchronization is better
done with channels or the facilities of the <a href="http://localhost:8080/sync">sync</a> package.
Share memory by communicating;
don&apos;t communicate by sharing memory.
<p>The swap operation, implemented by the SwapT functions, is the atomic
equivalent of:
<pre>old = *addr
*addr = new
return old
</pre>
<p>The compare-and-swap operation, implemented by the CompareAndSwapT
functions, is the atomic equivalent of:
<pre>if *addr == old {
	*addr = new
	return true
}
return false
</pre>
<p>The add operation, implemented by the AddT functions, is the atomic
equivalent of:
<pre>*addr += delta
return *addr
</pre>
<p>The load and store operations, implemented by the LoadT and StoreT
functions, are the atomic equivalents of &quot;return *addr&quot; and
&quot;*addr = val&quot;.
<p>In the terminology of the Go memory model, if the effect of
an atomic operation A is observed by atomic operation B,
then A “synchronizes before” B.
Additionally, all the atomic operations executed in a program
behave as though executed in some sequentially consistent order.
This definition provides the same semantics as
C++&apos;s sequentially consistent atomics and Java&apos;s volatile variables.

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="index.html#AddInt32">func AddInt32(addr *int32, delta int32) (new int32)</a></dd>
			
				
				<dd><a href="index.html#AddInt64">func AddInt64(addr *int64, delta int64) (new int64)</a></dd>
			
				
				<dd><a href="index.html#AddUint32">func AddUint32(addr *uint32, delta uint32) (new uint32)</a></dd>
			
				
				<dd><a href="index.html#AddUint64">func AddUint64(addr *uint64, delta uint64) (new uint64)</a></dd>
			
				
				<dd><a href="index.html#AddUintptr">func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</a></dd>
			
				
				<dd><a href="index.html#CompareAndSwapInt32">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)</a></dd>
			
				
				<dd><a href="index.html#CompareAndSwapInt64">func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)</a></dd>
			
				
				<dd><a href="index.html#CompareAndSwapPointer">func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</a></dd>
			
				
				<dd><a href="index.html#CompareAndSwapUint32">func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)</a></dd>
			
				
				<dd><a href="index.html#CompareAndSwapUint64">func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)</a></dd>
			
				
				<dd><a href="index.html#CompareAndSwapUintptr">func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)</a></dd>
			
				
				<dd><a href="index.html#LoadInt32">func LoadInt32(addr *int32) (val int32)</a></dd>
			
				
				<dd><a href="index.html#LoadInt64">func LoadInt64(addr *int64) (val int64)</a></dd>
			
				
				<dd><a href="index.html#LoadPointer">func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</a></dd>
			
				
				<dd><a href="index.html#LoadUint32">func LoadUint32(addr *uint32) (val uint32)</a></dd>
			
				
				<dd><a href="index.html#LoadUint64">func LoadUint64(addr *uint64) (val uint64)</a></dd>
			
				
				<dd><a href="index.html#LoadUintptr">func LoadUintptr(addr *uintptr) (val uintptr)</a></dd>
			
				
				<dd><a href="index.html#StoreInt32">func StoreInt32(addr *int32, val int32)</a></dd>
			
				
				<dd><a href="index.html#StoreInt64">func StoreInt64(addr *int64, val int64)</a></dd>
			
				
				<dd><a href="index.html#StorePointer">func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</a></dd>
			
				
				<dd><a href="index.html#StoreUint32">func StoreUint32(addr *uint32, val uint32)</a></dd>
			
				
				<dd><a href="index.html#StoreUint64">func StoreUint64(addr *uint64, val uint64)</a></dd>
			
				
				<dd><a href="index.html#StoreUintptr">func StoreUintptr(addr *uintptr, val uintptr)</a></dd>
			
				
				<dd><a href="index.html#SwapInt32">func SwapInt32(addr *int32, new int32) (old int32)</a></dd>
			
				
				<dd><a href="index.html#SwapInt64">func SwapInt64(addr *int64, new int64) (old int64)</a></dd>
			
				
				<dd><a href="index.html#SwapPointer">func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</a></dd>
			
				
				<dd><a href="index.html#SwapUint32">func SwapUint32(addr *uint32, new uint32) (old uint32)</a></dd>
			
				
				<dd><a href="index.html#SwapUint64">func SwapUint64(addr *uint64, new uint64) (old uint64)</a></dd>
			
				
				<dd><a href="index.html#SwapUintptr">func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)</a></dd>
			
			
				
				<dd><a href="index.html#Bool">type Bool</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Bool.CompareAndSwap">func (x *Bool) CompareAndSwap(old, new bool) (swapped bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Bool.Load">func (x *Bool) Load() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Bool.Store">func (x *Bool) Store(val bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Bool.Swap">func (x *Bool) Swap(new bool) (old bool)</a></dd>
				
			
				
				<dd><a href="index.html#Int32">type Int32</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Int32.Add">func (x *Int32) Add(delta int32) (new int32)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Int32.CompareAndSwap">func (x *Int32) CompareAndSwap(old, new int32) (swapped bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Int32.Load">func (x *Int32) Load() int32</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Int32.Store">func (x *Int32) Store(val int32)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Int32.Swap">func (x *Int32) Swap(new int32) (old int32)</a></dd>
				
			
				
				<dd><a href="index.html#Int64">type Int64</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Int64.Add">func (x *Int64) Add(delta int64) (new int64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Int64.CompareAndSwap">func (x *Int64) CompareAndSwap(old, new int64) (swapped bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Int64.Load">func (x *Int64) Load() int64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Int64.Store">func (x *Int64) Store(val int64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Int64.Swap">func (x *Int64) Swap(new int64) (old int64)</a></dd>
				
			
				
				<dd><a href="index.html#Pointer">type Pointer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Pointer.CompareAndSwap">func (x *Pointer[T]) CompareAndSwap(old, new *T) (swapped bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Pointer.Load">func (x *Pointer[T]) Load() *T</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Pointer.Store">func (x *Pointer[T]) Store(val *T)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Pointer.Swap">func (x *Pointer[T]) Swap(new *T) (old *T)</a></dd>
				
			
				
				<dd><a href="index.html#Uint32">type Uint32</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uint32.Add">func (x *Uint32) Add(delta uint32) (new uint32)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uint32.CompareAndSwap">func (x *Uint32) CompareAndSwap(old, new uint32) (swapped bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uint32.Load">func (x *Uint32) Load() uint32</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uint32.Store">func (x *Uint32) Store(val uint32)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uint32.Swap">func (x *Uint32) Swap(new uint32) (old uint32)</a></dd>
				
			
				
				<dd><a href="index.html#Uint64">type Uint64</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uint64.Add">func (x *Uint64) Add(delta uint64) (new uint64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uint64.CompareAndSwap">func (x *Uint64) CompareAndSwap(old, new uint64) (swapped bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uint64.Load">func (x *Uint64) Load() uint64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uint64.Store">func (x *Uint64) Store(val uint64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uint64.Swap">func (x *Uint64) Swap(new uint64) (old uint64)</a></dd>
				
			
				
				<dd><a href="index.html#Uintptr">type Uintptr</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uintptr.Add">func (x *Uintptr) Add(delta uintptr) (new uintptr)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uintptr.CompareAndSwap">func (x *Uintptr) CompareAndSwap(old, new uintptr) (swapped bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uintptr.Load">func (x *Uintptr) Load() uintptr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uintptr.Store">func (x *Uintptr) Store(val uintptr)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Uintptr.Swap">func (x *Uintptr) Swap(new uintptr) (old uintptr)</a></dd>
				
			
				
				<dd><a href="index.html#Value">type Value</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Value.CompareAndSwap">func (v *Value) CompareAndSwap(old, new any) (swapped bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Value.Load">func (v *Value) Load() (val any)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Value.Store">func (v *Value) Store(val any)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Value.Swap">func (v *Value) Swap(new any) (old any)</a></dd>
				
			
			
				
				<dd><a href="index.html#pkg-note-BUG">Bugs</a></dd>
				
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="index.html#example_Value_config">Value (Config)</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Value_readMostly">Value (ReadMostly)</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="../../../src/sync/atomic/doc.go">doc.go</a>
			
				<a href="../../../src/sync/atomic/type.go">type.go</a>
			
				<a href="../../../src/sync/atomic/value.go">value.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
		
		
			
			
			<h2 id="AddInt32">func <a href="../../../src/sync/atomic/doc.go?s=5573:5624#L108">AddInt32</a>
				<a class="permalink" href="index.html#AddInt32">&#xb6;</a>
				
				
			</h2>
			<pre>func AddInt32(addr *<a href="../../builtin/index.html#int32">int32</a>, delta <a href="../../builtin/index.html#int32">int32</a>) (new <a href="../../builtin/index.html#int32">int32</a>)</pre>
			<p>AddInt32 atomically adds delta to *addr and returns the new value.
Consider using the more ergonomic and less error-prone <a href="index.html#Int32.Add">Int32.Add</a> instead.

			
			

		
			
			
			<h2 id="AddInt64">func <a href="../../../src/sync/atomic/doc.go?s=6208:6259#L119">AddInt64</a>
				<a class="permalink" href="index.html#AddInt64">&#xb6;</a>
				
				
			</h2>
			<pre>func AddInt64(addr *<a href="../../builtin/index.html#int64">int64</a>, delta <a href="../../builtin/index.html#int64">int64</a>) (new <a href="../../builtin/index.html#int64">int64</a>)</pre>
			<p>AddInt64 atomically adds delta to *addr and returns the new value.
Consider using the more ergonomic and less error-prone <a href="index.html#Int64.Add">Int64.Add</a> instead
(particularly if you target 32-bit platforms; see the bugs section).

			
			

		
			
			
			<h2 id="AddUint32">func <a href="../../../src/sync/atomic/doc.go?s=5931:5986#L114">AddUint32</a>
				<a class="permalink" href="index.html#AddUint32">&#xb6;</a>
				
				
			</h2>
			<pre>func AddUint32(addr *<a href="../../builtin/index.html#uint32">uint32</a>, delta <a href="../../builtin/index.html#uint32">uint32</a>) (new <a href="../../builtin/index.html#uint32">uint32</a>)</pre>
			<p>AddUint32 atomically adds delta to *addr and returns the new value.
To subtract a signed positive constant value c from x, do AddUint32(&amp;x, ^uint32(c-1)).
In particular, to decrement x, do AddUint32(&amp;x, ^uint32(0)).
Consider using the more ergonomic and less error-prone <a href="index.html#Uint32.Add">Uint32.Add</a> instead.

			
			

		
			
			
			<h2 id="AddUint64">func <a href="../../../src/sync/atomic/doc.go?s=6637:6692#L126">AddUint64</a>
				<a class="permalink" href="index.html#AddUint64">&#xb6;</a>
				
				
			</h2>
			<pre>func AddUint64(addr *<a href="../../builtin/index.html#uint64">uint64</a>, delta <a href="../../builtin/index.html#uint64">uint64</a>) (new <a href="../../builtin/index.html#uint64">uint64</a>)</pre>
			<p>AddUint64 atomically adds delta to *addr and returns the new value.
To subtract a signed positive constant value c from x, do AddUint64(&amp;x, ^uint64(c-1)).
In particular, to decrement x, do AddUint64(&amp;x, ^uint64(0)).
Consider using the more ergonomic and less error-prone <a href="index.html#Uint64.Add">Uint64.Add</a> instead
(particularly if you target 32-bit platforms; see the bugs section).

			
			

		
			
			
			<h2 id="AddUintptr">func <a href="../../../src/sync/atomic/doc.go?s=6847:6906#L130">AddUintptr</a>
				<a class="permalink" href="index.html#AddUintptr">&#xb6;</a>
				
				
			</h2>
			<pre>func AddUintptr(addr *<a href="../../builtin/index.html#uintptr">uintptr</a>, delta <a href="../../builtin/index.html#uintptr">uintptr</a>) (new <a href="../../builtin/index.html#uintptr">uintptr</a>)</pre>
			<p>AddUintptr atomically adds delta to *addr and returns the new value.
Consider using the more ergonomic and less error-prone <a href="index.html#Uintptr.Add">Uintptr.Add</a> instead.

			
			

		
			
			
			<h2 id="CompareAndSwapInt32">func <a href="../../../src/sync/atomic/doc.go?s=3944:4012#L82">CompareAndSwapInt32</a>
				<a class="permalink" href="index.html#CompareAndSwapInt32">&#xb6;</a>
				
				
			</h2>
			<pre>func CompareAndSwapInt32(addr *<a href="../../builtin/index.html#int32">int32</a>, old, new <a href="../../builtin/index.html#int32">int32</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
			<p>CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value.
Consider using the more ergonomic and less error-prone <a href="index.html#Int32.CompareAndSwap">Int32.CompareAndSwap</a> instead.

			
			

		
			
			
			<h2 id="CompareAndSwapInt64">func <a href="../../../src/sync/atomic/doc.go?s=4258:4326#L87">CompareAndSwapInt64</a>
				<a class="permalink" href="index.html#CompareAndSwapInt64">&#xb6;</a>
				
				
			</h2>
			<pre>func CompareAndSwapInt64(addr *<a href="../../builtin/index.html#int64">int64</a>, old, new <a href="../../builtin/index.html#int64">int64</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
			<p>CompareAndSwapInt64 executes the compare-and-swap operation for an int64 value.
Consider using the more ergonomic and less error-prone <a href="index.html#Int64.CompareAndSwap">Int64.CompareAndSwap</a> instead
(particularly if you target 32-bit platforms; see the bugs section).

			
			

		
			
			
			<h2 id="CompareAndSwapPointer">func <a href="../../../src/sync/atomic/doc.go?s=5334:5422#L104">CompareAndSwapPointer</a>
				<a class="permalink" href="index.html#CompareAndSwapPointer">&#xb6;</a>
				
				
			</h2>
			<pre>func CompareAndSwapPointer(addr *<a href="../../unsafe/index.html">unsafe</a>.<a href="../../unsafe/index.html#Pointer">Pointer</a>, old, new <a href="../../unsafe/index.html">unsafe</a>.<a href="../../unsafe/index.html#Pointer">Pointer</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
			<p>CompareAndSwapPointer executes the compare-and-swap operation for a unsafe.Pointer value.
Consider using the more ergonomic and less error-prone <a href="index.html#Pointer.CompareAndSwap">Pointer.CompareAndSwap</a> instead.

			
			

		
			
			
			<h2 id="CompareAndSwapUint32">func <a href="../../../src/sync/atomic/doc.go?s=4503:4574#L91">CompareAndSwapUint32</a>
				<a class="permalink" href="index.html#CompareAndSwapUint32">&#xb6;</a>
				
				
			</h2>
			<pre>func CompareAndSwapUint32(addr *<a href="../../builtin/index.html#uint32">uint32</a>, old, new <a href="../../builtin/index.html#uint32">uint32</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
			<p>CompareAndSwapUint32 executes the compare-and-swap operation for a uint32 value.
Consider using the more ergonomic and less error-prone <a href="index.html#Uint32.CompareAndSwap">Uint32.CompareAndSwap</a> instead.

			
			

		
			
			
			<h2 id="CompareAndSwapUint64">func <a href="../../../src/sync/atomic/doc.go?s=4822:4893#L96">CompareAndSwapUint64</a>
				<a class="permalink" href="index.html#CompareAndSwapUint64">&#xb6;</a>
				
				
			</h2>
			<pre>func CompareAndSwapUint64(addr *<a href="../../builtin/index.html#uint64">uint64</a>, old, new <a href="../../builtin/index.html#uint64">uint64</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
			<p>CompareAndSwapUint64 executes the compare-and-swap operation for a uint64 value.
Consider using the more ergonomic and less error-prone <a href="index.html#Uint64.CompareAndSwap">Uint64.CompareAndSwap</a> instead
(particularly if you target 32-bit platforms; see the bugs section).

			
			

		
			
			
			<h2 id="CompareAndSwapUintptr">func <a href="../../../src/sync/atomic/doc.go?s=5073:5147#L100">CompareAndSwapUintptr</a>
				<a class="permalink" href="index.html#CompareAndSwapUintptr">&#xb6;</a>
				
				
			</h2>
			<pre>func CompareAndSwapUintptr(addr *<a href="../../builtin/index.html#uintptr">uintptr</a>, old, new <a href="../../builtin/index.html#uintptr">uintptr</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
			<p>CompareAndSwapUintptr executes the compare-and-swap operation for a uintptr value.
Consider using the more ergonomic and less error-prone <a href="index.html#Uintptr.CompareAndSwap">Uintptr.CompareAndSwap</a> instead.

			
			

		
			
			
			<h2 id="LoadInt32">func <a href="../../../src/sync/atomic/doc.go?s=7025:7064#L134">LoadInt32</a>
				<a class="permalink" href="index.html#LoadInt32">&#xb6;</a>
				
				
			</h2>
			<pre>func LoadInt32(addr *<a href="../../builtin/index.html#int32">int32</a>) (val <a href="../../builtin/index.html#int32">int32</a>)</pre>
			<p>LoadInt32 atomically loads *addr.
Consider using the more ergonomic and less error-prone <a href="index.html#Int32.Load">Int32.Load</a> instead.

			
			

		
			
			
			<h2 id="LoadInt64">func <a href="../../../src/sync/atomic/doc.go?s=7254:7293#L139">LoadInt64</a>
				<a class="permalink" href="index.html#LoadInt64">&#xb6;</a>
				
				
			</h2>
			<pre>func LoadInt64(addr *<a href="../../builtin/index.html#int64">int64</a>) (val <a href="../../builtin/index.html#int64">int64</a>)</pre>
			<p>LoadInt64 atomically loads *addr.
Consider using the more ergonomic and less error-prone <a href="index.html#Int64.Load">Int64.Load</a> instead
(particularly if you target 32-bit platforms; see the bugs section).

			
			

		
			
			
			<h2 id="LoadPointer">func <a href="../../../src/sync/atomic/doc.go?s=7981:8040#L156">LoadPointer</a>
				<a class="permalink" href="index.html#LoadPointer">&#xb6;</a>
				
				
			</h2>
			<pre>func LoadPointer(addr *<a href="../../unsafe/index.html">unsafe</a>.<a href="../../unsafe/index.html#Pointer">Pointer</a>) (val <a href="../../unsafe/index.html">unsafe</a>.<a href="../../unsafe/index.html#Pointer">Pointer</a>)</pre>
			<p>LoadPointer atomically loads *addr.
Consider using the more ergonomic and less error-prone <a href="index.html#Pointer.Load">Pointer.Load</a> instead.

			
			

		
			
			
			<h2 id="LoadUint32">func <a href="../../../src/sync/atomic/doc.go?s=7414:7456#L143">LoadUint32</a>
				<a class="permalink" href="index.html#LoadUint32">&#xb6;</a>
				
				
			</h2>
			<pre>func LoadUint32(addr *<a href="../../builtin/index.html#uint32">uint32</a>) (val <a href="../../builtin/index.html#uint32">uint32</a>)</pre>
			<p>LoadUint32 atomically loads *addr.
Consider using the more ergonomic and less error-prone <a href="index.html#Uint32.Load">Uint32.Load</a> instead.

			
			

		
			
			
			<h2 id="LoadUint64">func <a href="../../../src/sync/atomic/doc.go?s=7648:7690#L148">LoadUint64</a>
				<a class="permalink" href="index.html#LoadUint64">&#xb6;</a>
				
				
			</h2>
			<pre>func LoadUint64(addr *<a href="../../builtin/index.html#uint64">uint64</a>) (val <a href="../../builtin/index.html#uint64">uint64</a>)</pre>
			<p>LoadUint64 atomically loads *addr.
Consider using the more ergonomic and less error-prone <a href="index.html#Uint64.Load">Uint64.Load</a> instead
(particularly if you target 32-bit platforms; see the bugs section).

			
			

		
			
			
			<h2 id="LoadUintptr">func <a href="../../../src/sync/atomic/doc.go?s=7813:7858#L152">LoadUintptr</a>
				<a class="permalink" href="index.html#LoadUintptr">&#xb6;</a>
				
				
			</h2>
			<pre>func LoadUintptr(addr *<a href="../../builtin/index.html#uintptr">uintptr</a>) (val <a href="../../builtin/index.html#uintptr">uintptr</a>)</pre>
			<p>LoadUintptr atomically loads *addr.
Consider using the more ergonomic and less error-prone <a href="index.html#Uintptr.Load">Uintptr.Load</a> instead.

			
			

		
			
			
			<h2 id="StoreInt32">func <a href="../../../src/sync/atomic/doc.go?s=8171:8210#L160">StoreInt32</a>
				<a class="permalink" href="index.html#StoreInt32">&#xb6;</a>
				
				
			</h2>
			<pre>func StoreInt32(addr *<a href="../../builtin/index.html#int32">int32</a>, val <a href="../../builtin/index.html#int32">int32</a>)</pre>
			<p>StoreInt32 atomically stores val into *addr.
Consider using the more ergonomic and less error-prone <a href="index.html#Int32.Store">Int32.Store</a> instead.

			
			

		
			
			
			<h2 id="StoreInt64">func <a href="../../../src/sync/atomic/doc.go?s=8412:8451#L165">StoreInt64</a>
				<a class="permalink" href="index.html#StoreInt64">&#xb6;</a>
				
				
			</h2>
			<pre>func StoreInt64(addr *<a href="../../builtin/index.html#int64">int64</a>, val <a href="../../builtin/index.html#int64">int64</a>)</pre>
			<p>StoreInt64 atomically stores val into *addr.
Consider using the more ergonomic and less error-prone <a href="index.html#Int64.Store">Int64.Store</a> instead
(particularly if you target 32-bit platforms; see the bugs section).

			
			

		
			
			
			<h2 id="StorePointer">func <a href="../../../src/sync/atomic/doc.go?s=9187:9246#L182">StorePointer</a>
				<a class="permalink" href="index.html#StorePointer">&#xb6;</a>
				
				
			</h2>
			<pre>func StorePointer(addr *<a href="../../unsafe/index.html">unsafe</a>.<a href="../../unsafe/index.html#Pointer">Pointer</a>, val <a href="../../unsafe/index.html">unsafe</a>.<a href="../../unsafe/index.html#Pointer">Pointer</a>)</pre>
			<p>StorePointer atomically stores val into *addr.
Consider using the more ergonomic and less error-prone <a href="index.html#Pointer.Store">Pointer.Store</a> instead.

			
			

		
			
			
			<h2 id="StoreUint32">func <a href="../../../src/sync/atomic/doc.go?s=8584:8626#L169">StoreUint32</a>
				<a class="permalink" href="index.html#StoreUint32">&#xb6;</a>
				
				
			</h2>
			<pre>func StoreUint32(addr *<a href="../../builtin/index.html#uint32">uint32</a>, val <a href="../../builtin/index.html#uint32">uint32</a>)</pre>
			<p>StoreUint32 atomically stores val into *addr.
Consider using the more ergonomic and less error-prone <a href="index.html#Uint32.Store">Uint32.Store</a> instead.

			
			

		
			
			
			<h2 id="StoreUint64">func <a href="../../../src/sync/atomic/doc.go?s=8830:8872#L174">StoreUint64</a>
				<a class="permalink" href="index.html#StoreUint64">&#xb6;</a>
				
				
			</h2>
			<pre>func StoreUint64(addr *<a href="../../builtin/index.html#uint64">uint64</a>, val <a href="../../builtin/index.html#uint64">uint64</a>)</pre>
			<p>StoreUint64 atomically stores val into *addr.
Consider using the more ergonomic and less error-prone <a href="index.html#Uint64.Store">Uint64.Store</a> instead
(particularly if you target 32-bit platforms; see the bugs section).

			
			

		
			
			
			<h2 id="StoreUintptr">func <a href="../../../src/sync/atomic/doc.go?s=9007:9052#L178">StoreUintptr</a>
				<a class="permalink" href="index.html#StoreUintptr">&#xb6;</a>
				
				
			</h2>
			<pre>func StoreUintptr(addr *<a href="../../builtin/index.html#uintptr">uintptr</a>, val <a href="../../builtin/index.html#uintptr">uintptr</a>)</pre>
			<p>StoreUintptr atomically stores val into *addr.
Consider using the more ergonomic and less error-prone <a href="index.html#Uintptr.Store">Uintptr.Store</a> instead.

			
			

		
			
			
			<h2 id="SwapInt32">func <a href="../../../src/sync/atomic/doc.go?s=2440:2490#L56">SwapInt32</a>
				<a class="permalink" href="index.html#SwapInt32">&#xb6;</a>
				
				
			</h2>
			<pre>func SwapInt32(addr *<a href="../../builtin/index.html#int32">int32</a>, new <a href="../../builtin/index.html#int32">int32</a>) (old <a href="../../builtin/index.html#int32">int32</a>)</pre>
			<p>SwapInt32 atomically stores new into *addr and returns the previous *addr value.
Consider using the more ergonomic and less error-prone <a href="index.html#Int32.Swap">Int32.Swap</a> instead.

			
			

		
			
			
			<h2 id="SwapInt64">func <a href="../../../src/sync/atomic/doc.go?s=2727:2777#L61">SwapInt64</a>
				<a class="permalink" href="index.html#SwapInt64">&#xb6;</a>
				
				
			</h2>
			<pre>func SwapInt64(addr *<a href="../../builtin/index.html#int64">int64</a>, new <a href="../../builtin/index.html#int64">int64</a>) (old <a href="../../builtin/index.html#int64">int64</a>)</pre>
			<p>SwapInt64 atomically stores new into *addr and returns the previous *addr value.
Consider using the more ergonomic and less error-prone <a href="index.html#Int64.Swap">Int64.Swap</a> instead
(particularly if you target 32-bit platforms; see the bugs section).

			
			

		
			
			
			<h2 id="SwapPointer">func <a href="../../../src/sync/atomic/doc.go?s=3690:3769#L78">SwapPointer</a>
				<a class="permalink" href="index.html#SwapPointer">&#xb6;</a>
				
				
			</h2>
			<pre>func SwapPointer(addr *<a href="../../unsafe/index.html">unsafe</a>.<a href="../../unsafe/index.html#Pointer">Pointer</a>, new <a href="../../unsafe/index.html">unsafe</a>.<a href="../../unsafe/index.html#Pointer">Pointer</a>) (old <a href="../../unsafe/index.html">unsafe</a>.<a href="../../unsafe/index.html#Pointer">Pointer</a>)</pre>
			<p>SwapPointer atomically stores new into *addr and returns the previous *addr value.
Consider using the more ergonomic and less error-prone <a href="index.html#Pointer.Swap">Pointer.Swap</a> instead.

			
			

		
			
			
			<h2 id="SwapUint32">func <a href="../../../src/sync/atomic/doc.go?s=2945:2999#L65">SwapUint32</a>
				<a class="permalink" href="index.html#SwapUint32">&#xb6;</a>
				
				
			</h2>
			<pre>func SwapUint32(addr *<a href="../../builtin/index.html#uint32">uint32</a>, new <a href="../../builtin/index.html#uint32">uint32</a>) (old <a href="../../builtin/index.html#uint32">uint32</a>)</pre>
			<p>SwapUint32 atomically stores new into *addr and returns the previous *addr value.
Consider using the more ergonomic and less error-prone <a href="index.html#Uint32.Swap">Uint32.Swap</a> instead.

			
			

		
			
			
			<h2 id="SwapUint64">func <a href="../../../src/sync/atomic/doc.go?s=3238:3292#L70">SwapUint64</a>
				<a class="permalink" href="index.html#SwapUint64">&#xb6;</a>
				
				
			</h2>
			<pre>func SwapUint64(addr *<a href="../../builtin/index.html#uint64">uint64</a>, new <a href="../../builtin/index.html#uint64">uint64</a>) (old <a href="../../builtin/index.html#uint64">uint64</a>)</pre>
			<p>SwapUint64 atomically stores new into *addr and returns the previous *addr value.
Consider using the more ergonomic and less error-prone <a href="index.html#Uint64.Swap">Uint64.Swap</a> instead
(particularly if you target 32-bit platforms; see the bugs section).

			
			

		
			
			
			<h2 id="SwapUintptr">func <a href="../../../src/sync/atomic/doc.go?s=3462:3520#L74">SwapUintptr</a>
				<a class="permalink" href="index.html#SwapUintptr">&#xb6;</a>
				
				
			</h2>
			<pre>func SwapUintptr(addr *<a href="../../builtin/index.html#uintptr">uintptr</a>, new <a href="../../builtin/index.html#uintptr">uintptr</a>) (old <a href="../../builtin/index.html#uintptr">uintptr</a>)</pre>
			<p>SwapUintptr atomically stores new into *addr and returns the previous *addr value.
Consider using the more ergonomic and less error-prone <a href="index.html#Uintptr.Swap">Uintptr.Swap</a> instead.

			
			

		
		
			
			
			<h2 id="Bool">type <a href="../../../src/sync/atomic/type.go?s=259:299#L1">Bool</a>
				<a class="permalink" href="index.html#Bool">&#xb6;</a>
				
				
			</h2>
			<p>A Bool is an atomic boolean value.
The zero value is false.

			<pre>type Bool struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Bool.CompareAndSwap">func (*Bool) <a href="../../../src/sync/atomic/type.go?s=762:821#L16">CompareAndSwap</a>
					<a class="permalink" href="index.html#Bool.CompareAndSwap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Bool">Bool</a>) CompareAndSwap(old, new <a href="../../builtin/index.html#bool">bool</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
				<p>CompareAndSwap executes the compare-and-swap operation for the boolean value x.

				
				
				
			
				
				<h3 id="Bool.Load">func (*Bool) <a href="../../../src/sync/atomic/type.go?s=361:387#L7">Load</a>
					<a class="permalink" href="index.html#Bool.Load">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Bool">Bool</a>) Load() <a href="../../builtin/index.html#bool">bool</a></pre>
				<p>Load atomically loads and returns the value stored in x.

				
				
				
			
				
				<h3 id="Bool.Store">func (*Bool) <a href="../../../src/sync/atomic/type.go?s=461:491#L10">Store</a>
					<a class="permalink" href="index.html#Bool.Store">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Bool">Bool</a>) Store(val <a href="../../builtin/index.html#bool">bool</a>)</pre>
				<p>Store atomically stores val into x.

				
				
				
			
				
				<h3 id="Bool.Swap">func (*Bool) <a href="../../../src/sync/atomic/type.go?s=594:634#L13">Swap</a>
					<a class="permalink" href="index.html#Bool.Swap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Bool">Bool</a>) Swap(new <a href="../../builtin/index.html#bool">bool</a>) (old <a href="../../builtin/index.html#bool">bool</a>)</pre>
				<p>Swap atomically stores new into x and returns the previous value.

				
				
				
			
		
			
			
			<h2 id="Int32">type <a href="../../../src/sync/atomic/type.go?s=2164:2204#L58">Int32</a>
				<a class="permalink" href="index.html#Int32">&#xb6;</a>
				
				
			</h2>
			<p>An Int32 is an atomic int32. The zero value is zero.

			<pre>type Int32 struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Int32.Add">func (*Int32) <a href="../../../src/sync/atomic/type.go?s=2805:2849#L78">Add</a>
					<a class="permalink" href="index.html#Int32.Add">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Int32">Int32</a>) Add(delta <a href="../../builtin/index.html#int32">int32</a>) (new <a href="../../builtin/index.html#int32">int32</a>)</pre>
				<p>Add atomically adds delta to x and returns the new value.

				
				
				
			
				
				<h3 id="Int32.CompareAndSwap">func (*Int32) <a href="../../../src/sync/atomic/type.go?s=2633:2694#L73">CompareAndSwap</a>
					<a class="permalink" href="index.html#Int32.CompareAndSwap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Int32">Int32</a>) CompareAndSwap(old, new <a href="../../builtin/index.html#int32">int32</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
				<p>CompareAndSwap executes the compare-and-swap operation for x.

				
				
				
			
				
				<h3 id="Int32.Load">func (*Int32) <a href="../../../src/sync/atomic/type.go?s=2266:2294#L64">Load</a>
					<a class="permalink" href="index.html#Int32.Load">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Int32">Int32</a>) Load() <a href="../../builtin/index.html#int32">int32</a></pre>
				<p>Load atomically loads and returns the value stored in x.

				
				
				
			
				
				<h3 id="Int32.Store">func (*Int32) <a href="../../../src/sync/atomic/type.go?s=2362:2394#L67">Store</a>
					<a class="permalink" href="index.html#Int32.Store">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Int32">Int32</a>) Store(val <a href="../../builtin/index.html#int32">int32</a>)</pre>
				<p>Store atomically stores val into x.

				
				
				
			
				
				<h3 id="Int32.Swap">func (*Int32) <a href="../../../src/sync/atomic/type.go?s=2491:2534#L70">Swap</a>
					<a class="permalink" href="index.html#Int32.Swap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Int32">Int32</a>) Swap(new <a href="../../builtin/index.html#int32">int32</a>) (old <a href="../../builtin/index.html#int32">int32</a>)</pre>
				<p>Swap atomically stores new into x and returns the previous value.

				
				
				
			
		
			
			
			<h2 id="Int64">type <a href="../../../src/sync/atomic/type.go?s=2940:2991#L81">Int64</a>
				<a class="permalink" href="index.html#Int64">&#xb6;</a>
				
				
			</h2>
			<p>An Int64 is an atomic int64. The zero value is zero.

			<pre>type Int64 struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Int64.Add">func (*Int64) <a href="../../../src/sync/atomic/type.go?s=3592:3636#L102">Add</a>
					<a class="permalink" href="index.html#Int64.Add">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Int64">Int64</a>) Add(delta <a href="../../builtin/index.html#int64">int64</a>) (new <a href="../../builtin/index.html#int64">int64</a>)</pre>
				<p>Add atomically adds delta to x and returns the new value.

				
				
				
			
				
				<h3 id="Int64.CompareAndSwap">func (*Int64) <a href="../../../src/sync/atomic/type.go?s=3420:3481#L97">CompareAndSwap</a>
					<a class="permalink" href="index.html#Int64.CompareAndSwap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Int64">Int64</a>) CompareAndSwap(old, new <a href="../../builtin/index.html#int64">int64</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
				<p>CompareAndSwap executes the compare-and-swap operation for x.

				
				
				
			
				
				<h3 id="Int64.Load">func (*Int64) <a href="../../../src/sync/atomic/type.go?s=3053:3081#L88">Load</a>
					<a class="permalink" href="index.html#Int64.Load">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Int64">Int64</a>) Load() <a href="../../builtin/index.html#int64">int64</a></pre>
				<p>Load atomically loads and returns the value stored in x.

				
				
				
			
				
				<h3 id="Int64.Store">func (*Int64) <a href="../../../src/sync/atomic/type.go?s=3149:3181#L91">Store</a>
					<a class="permalink" href="index.html#Int64.Store">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Int64">Int64</a>) Store(val <a href="../../builtin/index.html#int64">int64</a>)</pre>
				<p>Store atomically stores val into x.

				
				
				
			
				
				<h3 id="Int64.Swap">func (*Int64) <a href="../../../src/sync/atomic/type.go?s=3278:3321#L94">Swap</a>
					<a class="permalink" href="index.html#Int64.Swap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Int64">Int64</a>) Swap(new <a href="../../builtin/index.html#int64">int64</a>) (old <a href="../../builtin/index.html#int64">int64</a>)</pre>
				<p>Swap atomically stores new into x and returns the previous value.

				
				
				
			
		
			
			
			<h2 id="Pointer">type <a href="../../../src/sync/atomic/type.go?s=1223:1479#L33">Pointer</a>
				<a class="permalink" href="index.html#Pointer">&#xb6;</a>
				
				
			</h2>
			<p>A Pointer is an atomic pointer of type *T. The zero value is a nil *T.

			<pre>type Pointer[T <a href="../../builtin/index.html#any">any</a>] struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Pointer.CompareAndSwap">func (*Pointer[T]) <a href="../../../src/sync/atomic/type.go?s=1961:2024#L53">CompareAndSwap</a>
					<a class="permalink" href="index.html#Pointer.CompareAndSwap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Pointer">Pointer</a>[T]) CompareAndSwap(old, new *T) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
				<p>CompareAndSwap executes the compare-and-swap operation for x.

				
				
				
			
				
				<h3 id="Pointer.Load">func (*Pointer[T]) <a href="../../../src/sync/atomic/type.go?s=1541:1571#L44">Load</a>
					<a class="permalink" href="index.html#Pointer.Load">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Pointer">Pointer</a>[T]) Load() *T</pre>
				<p>Load atomically loads and returns the value stored in x.

				
				
				
			
				
				<h3 id="Pointer.Store">func (*Pointer[T]) <a href="../../../src/sync/atomic/type.go?s=1647:1681#L47">Store</a>
					<a class="permalink" href="index.html#Pointer.Store">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Pointer">Pointer</a>[T]) Store(val *T)</pre>
				<p>Store atomically stores val into x.

				
				
				
			
				
				<h3 id="Pointer.Swap">func (*Pointer[T]) <a href="../../../src/sync/atomic/type.go?s=1796:1838#L50">Swap</a>
					<a class="permalink" href="index.html#Pointer.Swap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Pointer">Pointer</a>[T]) Swap(new *T) (old *T)</pre>
				<p>Swap atomically stores new into x and returns the previous value.

				
				
				
			
		
			
			
			<h2 id="Uint32">type <a href="../../../src/sync/atomic/type.go?s=3728:3770#L105">Uint32</a>
				<a class="permalink" href="index.html#Uint32">&#xb6;</a>
				
				
			</h2>
			<p>A Uint32 is an atomic uint32. The zero value is zero.

			<pre>type Uint32 struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Uint32.Add">func (*Uint32) <a href="../../../src/sync/atomic/type.go?s=4384:4431#L125">Add</a>
					<a class="permalink" href="index.html#Uint32.Add">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uint32">Uint32</a>) Add(delta <a href="../../builtin/index.html#uint32">uint32</a>) (new <a href="../../builtin/index.html#uint32">uint32</a>)</pre>
				<p>Add atomically adds delta to x and returns the new value.

				
				
				
			
				
				<h3 id="Uint32.CompareAndSwap">func (*Uint32) <a href="../../../src/sync/atomic/type.go?s=4209:4272#L120">CompareAndSwap</a>
					<a class="permalink" href="index.html#Uint32.CompareAndSwap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uint32">Uint32</a>) CompareAndSwap(old, new <a href="../../builtin/index.html#uint32">uint32</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
				<p>CompareAndSwap executes the compare-and-swap operation for x.

				
				
				
			
				
				<h3 id="Uint32.Load">func (*Uint32) <a href="../../../src/sync/atomic/type.go?s=3832:3862#L111">Load</a>
					<a class="permalink" href="index.html#Uint32.Load">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uint32">Uint32</a>) Load() <a href="../../builtin/index.html#uint32">uint32</a></pre>
				<p>Load atomically loads and returns the value stored in x.

				
				
				
			
				
				<h3 id="Uint32.Store">func (*Uint32) <a href="../../../src/sync/atomic/type.go?s=3931:3965#L114">Store</a>
					<a class="permalink" href="index.html#Uint32.Store">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uint32">Uint32</a>) Store(val <a href="../../builtin/index.html#uint32">uint32</a>)</pre>
				<p>Store atomically stores val into x.

				
				
				
			
				
				<h3 id="Uint32.Swap">func (*Uint32) <a href="../../../src/sync/atomic/type.go?s=4063:4109#L117">Swap</a>
					<a class="permalink" href="index.html#Uint32.Swap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uint32">Uint32</a>) Swap(new <a href="../../builtin/index.html#uint32">uint32</a>) (old <a href="../../builtin/index.html#uint32">uint32</a>)</pre>
				<p>Swap atomically stores new into x and returns the previous value.

				
				
				
			
		
			
			
			<h2 id="Uint64">type <a href="../../../src/sync/atomic/type.go?s=4524:4577#L128">Uint64</a>
				<a class="permalink" href="index.html#Uint64">&#xb6;</a>
				
				
			</h2>
			<p>A Uint64 is an atomic uint64. The zero value is zero.

			<pre>type Uint64 struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Uint64.Add">func (*Uint64) <a href="../../../src/sync/atomic/type.go?s=5191:5238#L149">Add</a>
					<a class="permalink" href="index.html#Uint64.Add">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uint64">Uint64</a>) Add(delta <a href="../../builtin/index.html#uint64">uint64</a>) (new <a href="../../builtin/index.html#uint64">uint64</a>)</pre>
				<p>Add atomically adds delta to x and returns the new value.

				
				
				
			
				
				<h3 id="Uint64.CompareAndSwap">func (*Uint64) <a href="../../../src/sync/atomic/type.go?s=5016:5079#L144">CompareAndSwap</a>
					<a class="permalink" href="index.html#Uint64.CompareAndSwap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uint64">Uint64</a>) CompareAndSwap(old, new <a href="../../builtin/index.html#uint64">uint64</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
				<p>CompareAndSwap executes the compare-and-swap operation for x.

				
				
				
			
				
				<h3 id="Uint64.Load">func (*Uint64) <a href="../../../src/sync/atomic/type.go?s=4639:4669#L135">Load</a>
					<a class="permalink" href="index.html#Uint64.Load">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uint64">Uint64</a>) Load() <a href="../../builtin/index.html#uint64">uint64</a></pre>
				<p>Load atomically loads and returns the value stored in x.

				
				
				
			
				
				<h3 id="Uint64.Store">func (*Uint64) <a href="../../../src/sync/atomic/type.go?s=4738:4772#L138">Store</a>
					<a class="permalink" href="index.html#Uint64.Store">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uint64">Uint64</a>) Store(val <a href="../../builtin/index.html#uint64">uint64</a>)</pre>
				<p>Store atomically stores val into x.

				
				
				
			
				
				<h3 id="Uint64.Swap">func (*Uint64) <a href="../../../src/sync/atomic/type.go?s=4870:4916#L141">Swap</a>
					<a class="permalink" href="index.html#Uint64.Swap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uint64">Uint64</a>) Swap(new <a href="../../builtin/index.html#uint64">uint64</a>) (old <a href="../../builtin/index.html#uint64">uint64</a>)</pre>
				<p>Swap atomically stores new into x and returns the previous value.

				
				
				
			
		
			
			
			<h2 id="Uintptr">type <a href="../../../src/sync/atomic/type.go?s=5333:5377#L152">Uintptr</a>
				<a class="permalink" href="index.html#Uintptr">&#xb6;</a>
				
				
			</h2>
			<p>A Uintptr is an atomic uintptr. The zero value is zero.

			<pre>type Uintptr struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Uintptr.Add">func (*Uintptr) <a href="../../../src/sync/atomic/type.go?s=6004:6054#L172">Add</a>
					<a class="permalink" href="index.html#Uintptr.Add">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uintptr">Uintptr</a>) Add(delta <a href="../../builtin/index.html#uintptr">uintptr</a>) (new <a href="../../builtin/index.html#uintptr">uintptr</a>)</pre>
				<p>Add atomically adds delta to x and returns the new value.

				
				
				
			
				
				<h3 id="Uintptr.CompareAndSwap">func (*Uintptr) <a href="../../../src/sync/atomic/type.go?s=5826:5891#L167">CompareAndSwap</a>
					<a class="permalink" href="index.html#Uintptr.CompareAndSwap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uintptr">Uintptr</a>) CompareAndSwap(old, new <a href="../../builtin/index.html#uintptr">uintptr</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
				<p>CompareAndSwap executes the compare-and-swap operation for x.

				
				
				
			
				
				<h3 id="Uintptr.Load">func (*Uintptr) <a href="../../../src/sync/atomic/type.go?s=5439:5471#L158">Load</a>
					<a class="permalink" href="index.html#Uintptr.Load">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uintptr">Uintptr</a>) Load() <a href="../../builtin/index.html#uintptr">uintptr</a></pre>
				<p>Load atomically loads and returns the value stored in x.

				
				
				
			
				
				<h3 id="Uintptr.Store">func (*Uintptr) <a href="../../../src/sync/atomic/type.go?s=5541:5577#L161">Store</a>
					<a class="permalink" href="index.html#Uintptr.Store">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uintptr">Uintptr</a>) Store(val <a href="../../builtin/index.html#uintptr">uintptr</a>)</pre>
				<p>Store atomically stores val into x.

				
				
				
			
				
				<h3 id="Uintptr.Swap">func (*Uintptr) <a href="../../../src/sync/atomic/type.go?s=5676:5725#L164">Swap</a>
					<a class="permalink" href="index.html#Uintptr.Swap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="index.html#Uintptr">Uintptr</a>) Swap(new <a href="../../builtin/index.html#uintptr">uintptr</a>) (old <a href="../../builtin/index.html#uintptr">uintptr</a>)</pre>
				<p>Swap atomically stores new into x and returns the previous value.

				
				
				
			
		
			
			
			<h2 id="Value">type <a href="../../../src/sync/atomic/value.go?s=436:464#L6">Value</a>
				<a class="permalink" href="index.html#Value">&#xb6;</a>
				
				
			</h2>
			<p>A Value provides an atomic load and store of a consistently typed value.
The zero value for a Value returns nil from Load.
Once Store has been called, a Value must not be copied.
<p>A Value must not be copied after first use.

			<pre>type Value struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_Value_config" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (Config)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (Config)</span></p>
		<p>The following example shows how to use Value for periodic program config updates
and propagation of the changes to worker goroutines.
</p>
		
		
			<p>Code:</p>
			<pre class="code">
var config atomic.Value <span class="comment">// holds current server configuration</span>
<span class="comment">// Create initial config value and store into config.</span>
config.Store(loadConfig())
go func() {
    <span class="comment">// Reload config every 10 seconds</span>
    <span class="comment">// and update config value with the new version.</span>
    for {
        time.Sleep(10 * time.Second)
        config.Store(loadConfig())
    }
}()
<span class="comment">// Create worker goroutines that handle incoming requests</span>
<span class="comment">// using the latest config value.</span>
for i := 0; i &lt; 10; i++ {
    go func() {
        for r := range requests() {
            c := config.Load()
            <span class="comment">// Handle request r using config c.</span>
            _, _ = r, c
        }
    }()
}
</pre>
			
		
	</div>
</div>
<div id="example_Value_readMostly" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (ReadMostly)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (ReadMostly)</span></p>
		<p>The following example shows how to maintain a scalable frequently read,
but infrequently updated data structure using copy-on-write idiom.
</p>
		
		
			<p>Code:</p>
			<pre class="code">
type Map map[string]string
var m atomic.Value
m.Store(make(Map))
var mu sync.Mutex <span class="comment">// used only by writers</span>
<span class="comment">// read function can be used to read the data without further synchronization</span>
read := func(key string) (val string) {
    m1 := m.Load().(Map)
    return m1[key]
}
<span class="comment">// insert function can be used to update the data without further synchronization</span>
insert := func(key, val string) {
    mu.Lock() <span class="comment">// synchronize with other potential writers</span>
    defer mu.Unlock()
    m1 := m.Load().(Map) <span class="comment">// load current value of the data structure</span>
    m2 := make(Map)      <span class="comment">// create a new value</span>
    for k, v := range m1 {
        m2[k] = v <span class="comment">// copy all data from the current object to the new one</span>
    }
    m2[key] = val <span class="comment">// do the update that we need</span>
    m.Store(m2)   <span class="comment">// atomically replace the current object with the new one</span>
    <span class="comment">// At this point all new readers start working with the new version.</span>
    <span class="comment">// The old version will be garbage collected once the existing readers</span>
    <span class="comment">// (if any) are done with it.</span>
}
_, _ = read, insert
</pre>
			
		
	</div>
</div>

			
			

			

			
				
				<h3 id="Value.CompareAndSwap">func (*Value) <a href="../../../src/sync/atomic/value.go?s=4077:4136#L125">CompareAndSwap</a>
					<a class="permalink" href="index.html#Value.CompareAndSwap">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Value">Value</a>) CompareAndSwap(old, new <a href="../../builtin/index.html#any">any</a>) (swapped <a href="../../builtin/index.html#bool">bool</a>)</pre>
				<p>CompareAndSwap executes the compare-and-swap operation for the Value.
<p>All calls to CompareAndSwap for a given Value must use values of the same
concrete type. CompareAndSwap of an inconsistent type panics, as does
CompareAndSwap(old, nil).

				
				
				
			
				
				<h3 id="Value.Load">func (*Value) <a href="../../../src/sync/atomic/value.go?s=715:747#L18">Load</a>
					<a class="permalink" href="index.html#Value.Load">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Value">Value</a>) Load() (val <a href="../../builtin/index.html#any">any</a>)</pre>
				<p>Load returns the value set by the most recent Store.
It returns nil if there has been no call to Store for this Value.

				
				
				
			
				
				<h3 id="Value.Store">func (*Value) <a href="../../../src/sync/atomic/value.go?s=1276:1306#L37">Store</a>
					<a class="permalink" href="index.html#Value.Store">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Value">Value</a>) Store(val <a href="../../builtin/index.html#any">any</a>)</pre>
				<p>Store sets the value of the Value v to val.
All calls to Store for a given Value must use values of the same concrete type.
Store of an inconsistent type panics, as does Store(nil).

				
				
				
			
				
				<h3 id="Value.Swap">func (*Value) <a href="../../../src/sync/atomic/value.go?s=2602:2641#L80">Swap</a>
					<a class="permalink" href="index.html#Value.Swap">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#Value">Value</a>) Swap(new <a href="../../builtin/index.html#any">any</a>) (old <a href="../../builtin/index.html#any">any</a>)</pre>
				<p>Swap stores new into Value and returns the previous value. It returns nil if
the Value is empty.
<p>All calls to Swap for a given Value must use values of the same concrete
type. Swap of an inconsistent type panics, as does Swap(nil).

				
				
				
			
		
	

	
		
			<h2 id="pkg-note-BUG">Bugs</h2>
			<ul style="list-style: none; padding: 0;">
			
			<li><a href="../../../src/sync/atomic/doc.go?s=1625:2274#L43" style="float: left;">&#x261e;</a> <p>On 386, the 64-bit functions use instructions unavailable before the Pentium MMX.
<p>On non-Linux ARM, the 64-bit functions use instructions unavailable before the ARMv6k core.
<p>On ARM, 386, and 32-bit MIPS, it is the caller&apos;s responsibility to arrange
for 64-bit alignment of 64-bit words accessed atomically via the primitive
atomic functions (types <a href="index.html#Int64">Int64</a> and <a href="index.html#Uint64">Uint64</a> are automatically aligned).
The first word in an allocated struct, array, or slice; in a global
variable; or in a local variable (because the subject of all atomic operations
will escape to the heap) can be relied upon to be 64-bit aligned.
</li>
			
			</ul>
		
	







<div id="footer">
Build version go1.22.2.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:8080/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
