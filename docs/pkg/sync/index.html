<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>sync - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="../../lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="../../lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.22.2";</script>
<script src="../../lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="../../index.html">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="../../index.html">GoDoc</a></div>
<a href="index.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:8080/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package sync
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "sync"</code></dd>
			</dl>
			<dl>
			<dd><a href="index.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="index.html#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="index.html#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
				<dd><a href="index.html#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package sync provides basic synchronization primitives such as mutual
exclusion locks. Other than the Once and WaitGroup types, most are intended
for use by low-level library routines. Higher-level synchronization is
better done via channels and communication.
<p>Values containing the types defined in this package should not be copied.

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="index.html#OnceFunc">func OnceFunc(f func()) func()</a></dd>
			
				
				<dd><a href="index.html#OnceValue">func OnceValue[T any](f func() T) func() T</a></dd>
			
				
				<dd><a href="index.html#OnceValues">func OnceValues[T1, T2 any](f func() (T1, T2)) func() (T1, T2)</a></dd>
			
			
				
				<dd><a href="index.html#Cond">type Cond</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewCond">func NewCond(l Locker) *Cond</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Cond.Broadcast">func (c *Cond) Broadcast()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Cond.Signal">func (c *Cond) Signal()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Cond.Wait">func (c *Cond) Wait()</a></dd>
				
			
				
				<dd><a href="index.html#Locker">type Locker</a></dd>
				
				
			
				
				<dd><a href="index.html#Map">type Map</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Map.CompareAndDelete">func (m *Map) CompareAndDelete(key, old any) (deleted bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Map.CompareAndSwap">func (m *Map) CompareAndSwap(key, old, new any) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Map.Delete">func (m *Map) Delete(key any)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Map.Load">func (m *Map) Load(key any) (value any, ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Map.LoadAndDelete">func (m *Map) LoadAndDelete(key any) (value any, loaded bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Map.LoadOrStore">func (m *Map) LoadOrStore(key, value any) (actual any, loaded bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Map.Range">func (m *Map) Range(f func(key, value any) bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Map.Store">func (m *Map) Store(key, value any)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Map.Swap">func (m *Map) Swap(key, value any) (previous any, loaded bool)</a></dd>
				
			
				
				<dd><a href="index.html#Mutex">type Mutex</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Mutex.Lock">func (m *Mutex) Lock()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Mutex.TryLock">func (m *Mutex) TryLock() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Mutex.Unlock">func (m *Mutex) Unlock()</a></dd>
				
			
				
				<dd><a href="index.html#Once">type Once</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Once.Do">func (o *Once) Do(f func())</a></dd>
				
			
				
				<dd><a href="index.html#Pool">type Pool</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Pool.Get">func (p *Pool) Get() any</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Pool.Put">func (p *Pool) Put(x any)</a></dd>
				
			
				
				<dd><a href="index.html#RWMutex">type RWMutex</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RWMutex.Lock">func (rw *RWMutex) Lock()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RWMutex.RLock">func (rw *RWMutex) RLock()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RWMutex.RLocker">func (rw *RWMutex) RLocker() Locker</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RWMutex.RUnlock">func (rw *RWMutex) RUnlock()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RWMutex.TryLock">func (rw *RWMutex) TryLock() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RWMutex.TryRLock">func (rw *RWMutex) TryRLock() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RWMutex.Unlock">func (rw *RWMutex) Unlock()</a></dd>
				
			
				
				<dd><a href="index.html#WaitGroup">type WaitGroup</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#WaitGroup.Add">func (wg *WaitGroup) Add(delta int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#WaitGroup.Done">func (wg *WaitGroup) Done()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#WaitGroup.Wait">func (wg *WaitGroup) Wait()</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="index.html#example_Once">Once</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Pool">Pool</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_WaitGroup">WaitGroup</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="../../src/sync/cond.go">cond.go</a>
			
				<a href="../../src/sync/map.go">map.go</a>
			
				<a href="../../src/sync/mutex.go">mutex.go</a>
			
				<a href="../../src/sync/once.go">once.go</a>
			
				<a href="../../src/sync/oncefunc.go">oncefunc.go</a>
			
				<a href="../../src/sync/pool.go">pool.go</a>
			
				<a href="../../src/sync/poolqueue.go">poolqueue.go</a>
			
				<a href="../../src/sync/runtime.go">runtime.go</a>
			
				<a href="../../src/sync/runtime2.go">runtime2.go</a>
			
				<a href="../../src/sync/rwmutex.go">rwmutex.go</a>
			
				<a href="../../src/sync/waitgroup.go">waitgroup.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
		
		
			
			
			<h2 id="OnceFunc">func <a href="../../src/sync/oncefunc.go?s=371:401#L1">OnceFunc</a>
				<a class="permalink" href="index.html#OnceFunc">&#xb6;</a>
				
				
			</h2>
			<pre>func OnceFunc(f func()) func()</pre>
			<p>OnceFunc returns a function that invokes f only once. The returned function
may be called concurrently.
<p>If f panics, the returned function will panic with the same value on every call.

			
			

		
			
			
			<h2 id="OnceValue">func <a href="../../src/sync/oncefunc.go?s=1131:1173#L33">OnceValue</a>
				<a class="permalink" href="index.html#OnceValue">&#xb6;</a>
				
				
			</h2>
			<pre>func OnceValue[T <a href="../builtin/index.html#any">any</a>](f func() T) func() T</pre>
			<p>OnceValue returns a function that invokes f only once and returns the value
returned by f. The returned function may be called concurrently.
<p>If f panics, the returned function will panic with the same value on every call.

			
			

		
			
			
			<h2 id="OnceValues">func <a href="../../src/sync/oncefunc.go?s=1689:1751#L64">OnceValues</a>
				<a class="permalink" href="index.html#OnceValues">&#xb6;</a>
				
				
			</h2>
			<pre>func OnceValues[T1, T2 <a href="../builtin/index.html#any">any</a>](f func() (T1, T2)) func() (T1, T2)</pre>
			<p>OnceValues returns a function that invokes f only once and returns the values
returned by f. The returned function may be called concurrently.
<p>If f panics, the returned function will panic with the same value on every call.

			
			

		
		
			
			
			<h2 id="Cond">type <a href="../../src/sync/cond.go?s=1313:1457#L26">Cond</a>
				<a class="permalink" href="index.html#Cond">&#xb6;</a>
				
				
			</h2>
			<p>Cond implements a condition variable, a rendezvous point
for goroutines waiting for or announcing the occurrence
of an event.
<p>Each Cond has an associated Locker L (often a *Mutex or *RWMutex),
which must be held when changing the condition and
when calling the Wait method.
<p>A Cond must not be copied after first use.
<p>In the terminology of the Go memory model, Cond arranges that
a call to Broadcast or Signal “synchronizes before” any Wait call
that it unblocks.
<p>For many simple use cases, users will be better off using channels than a
Cond (Broadcast corresponds to closing a channel, and Signal corresponds to
sending on a channel).
<p>For more on replacements for sync.Cond, see <a href="https://blogtitle.github.io/categories/concurrency/">Roberto Clapis&apos;s series on
advanced concurrency patterns</a>, as well as <a href="https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view">Bryan Mills&apos;s talk on concurrency
patterns</a>.

			<pre>type Cond struct {

<span id="Cond.L"></span>    <span class="comment">// L is held while observing or changing the condition</span>
    L <a href="index.html#Locker">Locker</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewCond">func <a href="../../src/sync/cond.go?s=1504:1532#L37">NewCond</a>
					<a class="permalink" href="index.html#NewCond">&#xb6;</a>
					
					
				</h3>
				<pre>func NewCond(l <a href="index.html#Locker">Locker</a>) *<a href="index.html#Cond">Cond</a></pre>
				<p>NewCond returns a new Cond with Locker l.

				
				
			

			
				
				<h3 id="Cond.Broadcast">func (*Cond) <a href="../../src/sync/cond.go?s=2764:2790#L80">Broadcast</a>
					<a class="permalink" href="index.html#Cond.Broadcast">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Cond">Cond</a>) Broadcast()</pre>
				<p>Broadcast wakes all goroutines waiting on c.
<p>It is allowed but not required for the caller to hold c.L
during the call.

				
				
				
			
				
				<h3 id="Cond.Signal">func (*Cond) <a href="../../src/sync/cond.go?s=2544:2567#L71">Signal</a>
					<a class="permalink" href="index.html#Cond.Signal">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Cond">Cond</a>) Signal()</pre>
				<p>Signal wakes one goroutine waiting on c, if there is any.
<p>It is allowed but not required for the caller to hold c.L
during the call.
<p>Signal() does not affect goroutine scheduling priority; if other goroutines
are attempting to lock c.L, they may be awoken before a &quot;waiting&quot; goroutine.

				
				
				
			
				
				<h3 id="Cond.Wait">func (*Cond) <a href="../../src/sync/cond.go?s=2088:2109#L56">Wait</a>
					<a class="permalink" href="index.html#Cond.Wait">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Cond">Cond</a>) Wait()</pre>
				<p>Wait atomically unlocks c.L and suspends execution
of the calling goroutine. After later resuming execution,
Wait locks c.L before returning. Unlike in other systems,
Wait cannot return unless awoken by Broadcast or Signal.
<p>Because c.L is not locked while Wait is waiting, the caller
typically cannot assume that the condition is true when
Wait returns. Instead, the caller should Wait in a loop:
<pre>c.L.Lock()
for !condition() {
    c.Wait()
}
... make use of condition ...
c.L.Unlock()
</pre>

				
				
				
			
		
			
			
			<h2 id="Locker">type <a href="../../src/sync/mutex.go?s=1218:1261#L30">Locker</a>
				<a class="permalink" href="index.html#Locker">&#xb6;</a>
				
				
			</h2>
			<p>A Locker represents an object that can be locked and unlocked.

			<pre>type Locker interface {
    Lock()
    Unlock()
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Map">type <a href="../../src/sync/map.go?s=1750:3189#L25">Map</a>
				<a class="permalink" href="index.html#Map">&#xb6;</a>
				
				
			</h2>
			<p>Map is like a Go map[any]any but is safe for concurrent use
by multiple goroutines without additional locking or coordination.
Loads, stores, and deletes run in amortized constant time.
<p>The Map type is specialized. Most code should use a plain Go map instead,
with separate locking or coordination, for better type safety and to make it
easier to maintain other invariants along with the map content.
<p>The Map type is optimized for two common use cases: (1) when the entry for a given
key is only ever written once but read many times, as in caches that only grow,
or (2) when multiple goroutines read, write, and overwrite entries for disjoint
sets of keys. In these two cases, use of a Map may significantly reduce lock
contention compared to a Go map paired with a separate Mutex or RWMutex.
<p>The zero Map is empty and ready for use. A Map must not be copied after first use.
<p>In the terminology of the Go memory model, Map arranges that a write operation
“synchronizes before” any read operation that observes the effect of the write, where
read and write operations are defined as follows.
Load, LoadAndDelete, LoadOrStore, Swap, CompareAndSwap, and CompareAndDelete
are read operations; Delete, LoadAndDelete, Store, and Swap are write operations;
LoadOrStore is a write operation when it returns loaded set to false;
CompareAndSwap is a write operation when it returns swapped set to true;
and CompareAndDelete is a write operation when it returns deleted set to true.

			<pre>type Map struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Map.CompareAndDelete">func (*Map) <a href="../../src/sync/map.go?s=12427:12486#L396">CompareAndDelete</a>
					<a class="permalink" href="index.html#Map.CompareAndDelete">&#xb6;</a>
					
					
				</h3>
				<pre>func (m *<a href="index.html#Map">Map</a>) CompareAndDelete(key, old <a href="../builtin/index.html#any">any</a>) (deleted <a href="../builtin/index.html#bool">bool</a>)</pre>
				<p>CompareAndDelete deletes the entry for key if its value is equal to old.
The old value must be of a comparable type.
<p>If there is no current value for key in the map, CompareAndDelete
returns false (even if the old value is the nil interface value).

				
				
				
			
				
				<h3 id="Map.CompareAndSwap">func (*Map) <a href="../../src/sync/map.go?s=11353:11405#L364">CompareAndSwap</a>
					<a class="permalink" href="index.html#Map.CompareAndSwap">&#xb6;</a>
					
					
				</h3>
				<pre>func (m *<a href="index.html#Map">Map</a>) CompareAndSwap(key, old, new <a href="../builtin/index.html#any">any</a>) <a href="../builtin/index.html#bool">bool</a></pre>
				<p>CompareAndSwap swaps the old and new values for key
if the value stored in the map is equal to old.
The old value must be of a comparable type.

				
				
				
			
				
				<h3 id="Map.Delete">func (*Map) <a href="../../src/sync/map.go?s=9499:9528#L286">Delete</a>
					<a class="permalink" href="index.html#Map.Delete">&#xb6;</a>
					
					
				</h3>
				<pre>func (m *<a href="index.html#Map">Map</a>) Delete(key <a href="../builtin/index.html#any">any</a>)</pre>
				<p>Delete deletes the value for a key.

				
				
				
			
				
				<h3 id="Map.Load">func (*Map) <a href="../../src/sync/map.go?s=4791:4839#L110">Load</a>
					<a class="permalink" href="index.html#Map.Load">&#xb6;</a>
					
					
				</h3>
				<pre>func (m *<a href="index.html#Map">Map</a>) Load(key <a href="../builtin/index.html#any">any</a>) (value <a href="../builtin/index.html#any">any</a>, ok <a href="../builtin/index.html#bool">bool</a>)</pre>
				<p>Load returns the value stored in the map for a key, or nil if no
value is present.
The ok result indicates whether value was found in the map.

				
				
				
			
				
				<h3 id="Map.LoadAndDelete">func (*Map) <a href="../../src/sync/map.go?s=8930:8991#L262">LoadAndDelete</a>
					<a class="permalink" href="index.html#Map.LoadAndDelete">&#xb6;</a>
					
					
				</h3>
				<pre>func (m *<a href="index.html#Map">Map</a>) LoadAndDelete(key <a href="../builtin/index.html#any">any</a>) (value <a href="../builtin/index.html#any">any</a>, loaded <a href="../builtin/index.html#bool">bool</a>)</pre>
				<p>LoadAndDelete deletes the value for a key, returning the previous value if any.
The loaded result reports whether the key was present.

				
				
				
			
				
				<h3 id="Map.LoadOrStore">func (*Map) <a href="../../src/sync/map.go?s=7150:7217#L193">LoadOrStore</a>
					<a class="permalink" href="index.html#Map.LoadOrStore">&#xb6;</a>
					
					
				</h3>
				<pre>func (m *<a href="index.html#Map">Map</a>) LoadOrStore(key, value <a href="../builtin/index.html#any">any</a>) (actual <a href="../builtin/index.html#any">any</a>, loaded <a href="../builtin/index.html#bool">bool</a>)</pre>
				<p>LoadOrStore returns the existing value for the key if present.
Otherwise, it stores and returns the given value.
The loaded result is true if the value was loaded, false if stored.

				
				
				
			
				
				<h3 id="Map.Range">func (*Map) <a href="../../src/sync/map.go?s=13892:13940#L439">Range</a>
					<a class="permalink" href="index.html#Map.Range">&#xb6;</a>
					
					
				</h3>
				<pre>func (m *<a href="index.html#Map">Map</a>) Range(f func(key, value <a href="../builtin/index.html#any">any</a>) <a href="../builtin/index.html#bool">bool</a>)</pre>
				<p>Range calls f sequentially for each key and value present in the map.
If f returns false, range stops the iteration.
<p>Range does not necessarily correspond to any consistent snapshot of the Map&apos;s
contents: no key will be visited more than once, but if the value for any key
is stored or deleted concurrently (including by f), Range may reflect any
mapping for that key from any point during the Range call. Range does not
block other methods on the receiver; even f itself may call any method on m.
<p>Range may be O(N) with the number of elements in the map even if f returns
false after a constant number of calls.

				
				
				
			
				
				<h3 id="Map.Store">func (*Map) <a href="../../src/sync/map.go?s=5659:5694#L144">Store</a>
					<a class="permalink" href="index.html#Map.Store">&#xb6;</a>
					
					
				</h3>
				<pre>func (m *<a href="index.html#Map">Map</a>) Store(key, value <a href="../builtin/index.html#any">any</a>)</pre>
				<p>Store sets the value for a key.

				
				
				
			
				
				<h3 id="Map.Swap">func (*Map) <a href="../../src/sync/map.go?s=10209:10271#L320">Swap</a>
					<a class="permalink" href="index.html#Map.Swap">&#xb6;</a>
					
					
				</h3>
				<pre>func (m *<a href="index.html#Map">Map</a>) Swap(key, value <a href="../builtin/index.html#any">any</a>) (previous <a href="../builtin/index.html#any">any</a>, loaded <a href="../builtin/index.html#bool">bool</a>)</pre>
				<p>Swap swaps the value for a key and returns the previous value if any.
The loaded result reports whether the key was present.

				
				
				
			
		
			
			
			<h2 id="Mutex">type <a href="../../src/sync/mutex.go?s=1102:1150#L24">Mutex</a>
				<a class="permalink" href="index.html#Mutex">&#xb6;</a>
				
				
			</h2>
			<p>A Mutex is a mutual exclusion lock.
The zero value for a Mutex is an unlocked mutex.
<p>A Mutex must not be copied after first use.
<p>In the terminology of the Go memory model,
the n&apos;th call to Unlock “synchronizes before” the m&apos;th call to Lock
for any n &lt; m.
A successful call to TryLock is equivalent to a call to Lock.
A failed call to TryLock does not establish any “synchronizes before”
relation at all.

			<pre>type Mutex struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Mutex.Lock">func (*Mutex) <a href="../../src/sync/mutex.go?s=2871:2893#L71">Lock</a>
					<a class="permalink" href="index.html#Mutex.Lock">&#xb6;</a>
					
					
				</h3>
				<pre>func (m *<a href="index.html#Mutex">Mutex</a>) Lock()</pre>
				<p>Lock locks m.
If the lock is already in use, the calling goroutine
blocks until the mutex is available.

				
				
				
			
				
				<h3 id="Mutex.TryLock">func (*Mutex) <a href="../../src/sync/mutex.go?s=3366:3396#L88">TryLock</a>
					<a class="permalink" href="index.html#Mutex.TryLock">&#xb6;</a>
					
					
				</h3>
				<pre>func (m *<a href="index.html#Mutex">Mutex</a>) TryLock() <a href="../builtin/index.html#bool">bool</a></pre>
				<p>TryLock tries to lock m and reports whether it succeeded.
<p>Note that while correct uses of TryLock do exist, they are rare,
and use of TryLock is often a sign of a deeper problem
in a particular use of mutexes.

				
				
				
			
				
				<h3 id="Mutex.Unlock">func (*Mutex) <a href="../../src/sync/mutex.go?s=6857:6881#L202">Unlock</a>
					<a class="permalink" href="index.html#Mutex.Unlock">&#xb6;</a>
					
					
				</h3>
				<pre>func (m *<a href="index.html#Mutex">Mutex</a>) Unlock()</pre>
				<p>Unlock unlocks m.
It is a run-time error if m is not locked on entry to Unlock.
<p>A locked Mutex is not associated with a particular goroutine.
It is allowed for one goroutine to lock a Mutex and then
arrange for another goroutine to unlock it.

				
				
				
			
		
			
			
			<h2 id="Once">type <a href="../../src/sync/once.go?s=448:836#L8">Once</a>
				<a class="permalink" href="index.html#Once">&#xb6;</a>
				
				
			</h2>
			<p>Once is an object that will perform exactly one action.
<p>A Once must not be copied after first use.
<p>In the terminology of the Go memory model,
the return from f “synchronizes before”
the return from any call of once.Do(f).

			<pre>type Once struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_Once" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">var once sync.Once
onceBody := func() {
    fmt.Println(&#34;Only once&#34;)
}
done := make(chan bool)
for i := 0; i &lt; 10; i++ {
    go func() {
        once.Do(onceBody)
        done &lt;- true
    }()
}
for i := 0; i &lt; 10; i++ {
    &lt;-done
}
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">Only once
</pre>
			
		
	</div>
</div>

			
			

			

			
				
				<h3 id="Once.Do">func (*Once) <a href="../../src/sync/once.go?s=1672:1699#L38">Do</a>
					<a class="permalink" href="index.html#Once.Do">&#xb6;</a>
					
					
				</h3>
				<pre>func (o *<a href="index.html#Once">Once</a>) Do(f func())</pre>
				<p>Do calls the function f if and only if Do is being called for the
first time for this instance of Once. In other words, given
<pre>var once Once
</pre>
<p>if once.Do(f) is called multiple times, only the first call will invoke f,
even if f has a different value in each invocation. A new instance of
Once is required for each function to execute.
<p>Do is intended for initialization that must be run exactly once. Since f
is niladic, it may be necessary to use a function literal to capture the
arguments to a function to be invoked by Do:
<pre>config.once.Do(func() { config.init(filename) })
</pre>
<p>Because no call to Do returns until the one call to f returns, if f causes
Do to be called, it will deadlock.
<p>If f panics, Do considers it to have returned; future calls of Do return
without calling f.

				
				
				
			
		
			
			
			<h2 id="Pool">type <a href="../../src/sync/pool.go?s=1883:2343#L39">Pool</a>
				<a class="permalink" href="index.html#Pool">&#xb6;</a>
				
				
			</h2>
			<p>A Pool is a set of temporary objects that may be individually saved and
retrieved.
<p>Any item stored in the Pool may be removed automatically at any time without
notification. If the Pool holds the only reference when this happens, the
item might be deallocated.
<p>A Pool is safe for use by multiple goroutines simultaneously.
<p>Pool&apos;s purpose is to cache allocated but unused items for later reuse,
relieving pressure on the garbage collector. That is, it makes it easy to
build efficient, thread-safe free lists. However, it is not suitable for all
free lists.
<p>An appropriate use of a Pool is to manage a group of temporary items
silently shared among and potentially reused by concurrent independent
clients of a package. Pool provides a way to amortize allocation overhead
across many clients.
<p>An example of good use of a Pool is in the fmt package, which maintains a
dynamically-sized store of temporary output buffers. The store scales under
load (when many goroutines are actively printing) and shrinks when
quiescent.
<p>On the other hand, a free list maintained as part of a short-lived object is
not a suitable use for a Pool, since the overhead does not amortize well in
that scenario. It is more efficient to have such objects implement their own
free list.
<p>A Pool must not be copied after first use.
<p>In the terminology of the Go memory model, a call to Put(x) “synchronizes before”
a call to Get returning that same value x.
Similarly, a call to New returning x “synchronizes before”
a call to Get returning that same value x.

			<pre>type Pool struct {

<span id="Pool.New"></span>    <span class="comment">// New optionally specifies a function to generate</span>
    <span class="comment">// a value when Get would otherwise return nil.</span>
    <span class="comment">// It may not be changed concurrently with calls to Get.</span>
    New func() <a href="../builtin/index.html#any">any</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_Pool" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">package sync_test

import (
    &#34;bytes&#34;
    &#34;io&#34;
    &#34;os&#34;
    &#34;sync&#34;
    &#34;time&#34;
)

var bufPool = sync.Pool{
    New: func() any {
        <span class="comment">// The Pool&#39;s New function should generally only return pointer</span>
        <span class="comment">// types, since a pointer can be put into the return interface</span>
        <span class="comment">// value without an allocation:</span>
        return new(bytes.Buffer)
    },
}

<span class="comment">// timeNow is a fake version of time.Now for tests.</span>
func timeNow() time.Time {
    return time.Unix(1136214245, 0)
}

func Log(w io.Writer, key, val string) {
    b := bufPool.Get().(*bytes.Buffer)
    b.Reset()
    <span class="comment">// Replace this with time.Now() in a real logger.</span>
    b.WriteString(timeNow().UTC().Format(time.RFC3339))
    b.WriteByte(&#39; &#39;)
    b.WriteString(key)
    b.WriteByte(&#39;=&#39;)
    b.WriteString(val)
    w.Write(b.Bytes())
    bufPool.Put(b)
}

func ExamplePool() {
    Log(os.Stdout, &#34;path&#34;, &#34;/search?q=flowers&#34;)
    <span class="comment">// Output: 2006-01-02T15:04:05Z path=/search?q=flowers</span>
}
</pre>
			
		
	</div>
</div>

			
			

			

			
				
				<h3 id="Pool.Get">func (*Pool) <a href="../../src/sync/pool.go?s=4188:4212#L118">Get</a>
					<a class="permalink" href="index.html#Pool.Get">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#Pool">Pool</a>) Get() <a href="../builtin/index.html#any">any</a></pre>
				<p>Get selects an arbitrary item from the Pool, removes it from the
Pool, and returns it to the caller.
Get may choose to ignore the pool and treat it as empty.
Callers should not assume any relation between values passed to Put and
the values returned by Get.
<p>If Get would otherwise return nil and p.New is non-nil, Get returns
the result of calling p.New.

				
				
				
			
				
				<h3 id="Pool.Put">func (*Pool) <a href="../../src/sync/pool.go?s=3449:3474#L86">Put</a>
					<a class="permalink" href="index.html#Pool.Put">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#Pool">Pool</a>) Put(x <a href="../builtin/index.html#any">any</a>)</pre>
				<p>Put adds x to the pool.

				
				
				
			
		
			
			
			<h2 id="RWMutex">type <a href="../../src/sync/rwmutex.go?s=1293:1655#L25">RWMutex</a>
				<a class="permalink" href="index.html#RWMutex">&#xb6;</a>
				
				
			</h2>
			<p>A RWMutex is a reader/writer mutual exclusion lock.
The lock can be held by an arbitrary number of readers or a single writer.
The zero value for a RWMutex is an unlocked mutex.
<p>A RWMutex must not be copied after first use.
<p>If any goroutine calls Lock while the lock is already held by
one or more readers, concurrent calls to RLock will block until
the writer has acquired (and released) the lock, to ensure that
the lock eventually becomes available to the writer.
Note that this prohibits recursive read-locking.
<p>In the terminology of the Go memory model,
the n&apos;th call to Unlock “synchronizes before” the m&apos;th call to Lock
for any n &lt; m, just as for Mutex.
For any call to RLock, there exists an n such that
the n&apos;th call to Unlock “synchronizes before” that call to RLock,
and the corresponding call to RUnlock “synchronizes before”
the n+1&apos;th call to Lock.

			<pre>type RWMutex struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="RWMutex.Lock">func (*RWMutex) <a href="../../src/sync/rwmutex.go?s=4234:4259#L130">Lock</a>
					<a class="permalink" href="index.html#RWMutex.Lock">&#xb6;</a>
					
					
				</h3>
				<pre>func (rw *<a href="index.html#RWMutex">RWMutex</a>) Lock()</pre>
				<p>Lock locks rw for writing.
If the lock is already locked for reading or writing,
Lock blocks until the lock is available.

				
				
				
			
				
				<h3 id="RWMutex.RLock">func (*RWMutex) <a href="../../src/sync/rwmutex.go?s=2417:2443#L53">RLock</a>
					<a class="permalink" href="index.html#RWMutex.RLock">&#xb6;</a>
					
					
				</h3>
				<pre>func (rw *<a href="index.html#RWMutex">RWMutex</a>) RLock()</pre>
				<p>RLock locks rw for reading.
<p>It should not be used for recursive read locking; a blocked Lock
call excludes new readers from acquiring the lock. See the
documentation on the RWMutex type.

				
				
				
			
				
				<h3 id="RWMutex.RLocker">func (*RWMutex) <a href="../../src/sync/rwmutex.go?s=6997:7032#L226">RLocker</a>
					<a class="permalink" href="index.html#RWMutex.RLocker">&#xb6;</a>
					
					
				</h3>
				<pre>func (rw *<a href="index.html#RWMutex">RWMutex</a>) RLocker() <a href="index.html#Locker">Locker</a></pre>
				<p>RLocker returns a Locker interface that implements
the Lock and Unlock methods by calling rw.RLock and rw.RUnlock.

				
				
				
			
				
				<h3 id="RWMutex.RUnlock">func (*RWMutex) <a href="../../src/sync/rwmutex.go?s=3497:3525#L100">RUnlock</a>
					<a class="permalink" href="index.html#RWMutex.RUnlock">&#xb6;</a>
					
					
				</h3>
				<pre>func (rw *<a href="index.html#RWMutex">RWMutex</a>) RUnlock()</pre>
				<p>RUnlock undoes a single RLock call;
it does not affect other simultaneous readers.
It is a run-time error if rw is not locked for reading
on entry to RUnlock.

				
				
				
			
				
				<h3 id="RWMutex.TryLock">func (*RWMutex) <a href="../../src/sync/rwmutex.go?s=4996:5029#L155">TryLock</a>
					<a class="permalink" href="index.html#RWMutex.TryLock">&#xb6;</a>
					
					
				</h3>
				<pre>func (rw *<a href="index.html#RWMutex">RWMutex</a>) TryLock() <a href="../builtin/index.html#bool">bool</a></pre>
				<p>TryLock tries to lock rw for writing and reports whether it succeeded.
<p>Note that while correct uses of TryLock do exist, they are rare,
and use of TryLock is often a sign of a deeper problem
in a particular use of mutexes.

				
				
				
			
				
				<h3 id="RWMutex.TryRLock">func (*RWMutex) <a href="../../src/sync/rwmutex.go?s=2958:2992#L73">TryRLock</a>
					<a class="permalink" href="index.html#RWMutex.TryRLock">&#xb6;</a>
					
					
				</h3>
				<pre>func (rw *<a href="index.html#RWMutex">RWMutex</a>) TryRLock() <a href="../builtin/index.html#bool">bool</a></pre>
				<p>TryRLock tries to lock rw for reading and reports whether it succeeded.
<p>Note that while correct uses of TryRLock do exist, they are rare,
and use of TryRLock is often a sign of a deeper problem
in a particular use of mutexes.

				
				
				
			
				
				<h3 id="RWMutex.Unlock">func (*RWMutex) <a href="../../src/sync/rwmutex.go?s=5759:5786#L187">Unlock</a>
					<a class="permalink" href="index.html#RWMutex.Unlock">&#xb6;</a>
					
					
				</h3>
				<pre>func (rw *<a href="index.html#RWMutex">RWMutex</a>) Unlock()</pre>
				<p>Unlock unlocks rw for writing. It is a run-time error if rw is
not locked for writing on entry to Unlock.
<p>As with Mutexes, a locked RWMutex is not associated with a particular
goroutine. One goroutine may RLock (Lock) a RWMutex and then
arrange for another goroutine to RUnlock (Unlock) it.

				
				
				
			
		
			
			
			<h2 id="WaitGroup">type <a href="../../src/sync/waitgroup.go?s=713:848#L13">WaitGroup</a>
				<a class="permalink" href="index.html#WaitGroup">&#xb6;</a>
				
				
			</h2>
			<p>A WaitGroup waits for a collection of goroutines to finish.
The main goroutine calls Add to set the number of
goroutines to wait for. Then each of the goroutines
runs and calls Done when finished. At the same time,
Wait can be used to block until all goroutines have finished.
<p>A WaitGroup must not be copied after first use.
<p>In the terminology of the Go memory model, a call to Done
“synchronizes before” the return of any Wait call that it unblocks.

			<pre>type WaitGroup struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_WaitGroup" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		<p>This example fetches several URLs concurrently,
using a WaitGroup to block until all the fetches are complete.
</p>
		
		
			<p>Code:</p>
			<pre class="code">
var wg sync.WaitGroup
var urls = []string{
    &#34;http://www.golang.org/&#34;,
    &#34;http://www.google.com/&#34;,
    &#34;http://www.example.com/&#34;,
}
for _, url := range urls {
    <span class="comment">// Increment the WaitGroup counter.</span>
    wg.Add(1)
    <span class="comment">// Launch a goroutine to fetch the URL.</span>
    go func(url string) {
        <span class="comment">// Decrement the counter when the goroutine completes.</span>
        defer wg.Done()
        <span class="comment">// Fetch the URL.</span>
        http.Get(url)
    }(url)
}
<span class="comment">// Wait for all HTTP fetches to complete.</span>
wg.Wait()
</pre>
			
		
	</div>
</div>

			
			

			

			
				
				<h3 id="WaitGroup.Add">func (*WaitGroup) <a href="../../src/sync/waitgroup.go?s=1606:1641#L33">Add</a>
					<a class="permalink" href="index.html#WaitGroup.Add">&#xb6;</a>
					
					
				</h3>
				<pre>func (wg *<a href="index.html#WaitGroup">WaitGroup</a>) Add(delta <a href="../builtin/index.html#int">int</a>)</pre>
				<p>Add adds delta, which may be negative, to the WaitGroup counter.
If the counter becomes zero, all goroutines blocked on Wait are released.
If the counter goes negative, Add panics.
<p>Note that calls with a positive delta that occur when the counter is zero
must happen before a Wait. Calls with a negative delta, or calls with a
positive delta that start when the counter is greater than zero, may happen
at any time.
Typically this means the calls to Add should execute before the statement
creating the goroutine or other event to be waited for.
If a WaitGroup is reused to wait for several independent sets of events,
new Add calls must happen after all previous Wait calls have returned.
See the WaitGroup example.

				
				
				
			
				
				<h3 id="WaitGroup.Done">func (*WaitGroup) <a href="../../src/sync/waitgroup.go?s=2927:2954#L76">Done</a>
					<a class="permalink" href="index.html#WaitGroup.Done">&#xb6;</a>
					
					
				</h3>
				<pre>func (wg *<a href="index.html#WaitGroup">WaitGroup</a>) Done()</pre>
				<p>Done decrements the WaitGroup counter by one.

				
				
				
			
				
				<h3 id="WaitGroup.Wait">func (*WaitGroup) <a href="../../src/sync/waitgroup.go?s=3024:3051#L81">Wait</a>
					<a class="permalink" href="index.html#WaitGroup.Wait">&#xb6;</a>
					
					
				</h3>
				<pre>func (wg *<a href="index.html#WaitGroup">WaitGroup</a>) Wait()</pre>
				<p>Wait blocks until the WaitGroup counter is zero.

				
				
				
			
		
	

	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	<div class="pkg-dir">
		<table>
			<tr>
				<th class="pkg-name">Name</th>
				<th class="pkg-synopsis">Synopsis</th>
			</tr>

			
			<tr>
				<td colspan="2"><a href="../../index.html">..</a></td>
			</tr>
			

			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="atomic/index.html">atomic</a>
					</td>
				
					<td class="pkg-synopsis">
						Package atomic provides low-level atomic memory primitives useful for implementing synchronization algorithms.
					</td>
				</tr>
			
		</table>
	</div>



<div id="footer">
Build version go1.22.2.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:8080/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
