// This package is responsible for all kinds of middleware through which a request goes before the desired handler function.
// Right now middlewares available are:
//   - authentication middleware,
//   - HTTP Method miedleware,
package middleware

import (
	"backend/config"
	"backend/utils/database"
	"backend/utils/errhandle"
	"backend/utils/jwt"
	"fmt"
	"net/http"
	"time"
)

// -
//
//	This middleware is responsible for securing any sensitive endpoint. It operates on the access and refresh tokens which
//	are generated upon logging into the user's account and store in HTTP-Only Cookies. In short what it does is:
//	  - checking how to tokens were signed (whether they were generated on the server),
//	  - checking whether the refresh token has expired (if so, it replies with status 401)
//	  - checking whether the refresh token contains valid data (whether it's assigned to the same person as stored in the payload),
//	  - checking whether the access token has expired and if so, generating another one (we've already checked whether the person
//	    is who he says he is in all of the points above)
//
//	Methods: (All methods are accepted)
//
//	Possible Responses:
//		400 (Bad Request): At least one of the tokens was generated in a bad way (it doesn't have exactly 3 parts).
//
//		401 (Unauthorized): There's no access or refresh token in the HTTP-Only Cookie. At least one token wasn't generated on
//		this server.
//
//		404 (Not Found): There's no such refresh token database record associated with the user given in the refresh token.
//		There's no user with the id given in the access token.
//
//		500 (Internal Server Error): There's been an error while decoding the access or refresh token cookie. There's been an
//		error while decoding at least one of the token's payload. There's been an error while deleting the refresh token from
//		the database. There's been an error while trying to identify the user based on his refresh or access token. There's been
//		an error while trying to generate a new access token.
func Authenticate(next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		db := database.GetDb()
		now := time.Now()

		accessToken, refreshToken, e := getRefAccFromRequest(r)
		if e.Handle(w, r) {
			return
		}

		if !jwt.WasGeneratedWithSecret(refreshToken, config.JwtSecret) || !jwt.WasGeneratedWithSecret(accessToken, config.JwtSecret) {
			e := errhandle.Error{
				Type:          errhandle.JwtError,
				ServerMessage: "one of the tokens or both weren't created with the server secret",
				ClientMessage: "Your authentication medium wasn't generated by this server.",
				Status:        http.StatusUnauthorized,
			}
			e.Handle(w, r)
			return
		}

		claimsRefresh, e := jwt.DecodePayload(refreshToken)
		if e.Handle(w, r) {
			return
		}

		claimsAccess, e := jwt.DecodePayload(accessToken)
		if e.Handle(w, r) {
			return
		}

		expiresRefresh := int64(claimsRefresh["exp"].(float64))
		if expiresRefresh < now.Unix() {
			e := db.DeleteRefreshTokenByToken(refreshToken)
			if e.Handle(w, r) {
				return
			}

			http.SetCookie(w, &http.Cookie{
				Name:     "refresh_token",
				Value:    "",
				HttpOnly: true,
				Path:     "/",
				Expires:  time.Unix(0, 0),
			})

			http.SetCookie(w, &http.Cookie{
				Name:     "access_token",
				Value:    "",
				HttpOnly: true,
				Path:     "/",
				Expires:  time.Unix(0, 0),
			})

			w.WriteHeader(http.StatusUnauthorized)
			return
		}

		userId := claimsRefresh["user"].(string)
		tk, e := db.GetRefreshTokenByUserId(userId)
		if e.Handle(w, r) {
			return
		}

		if tk.UserId != userId {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}

		expiresAccess := int64(claimsAccess["exp"].(float64))
		if expiresAccess < now.Unix() {
			user, e := db.GetUserById(claimsAccess["user"].(string))
			if e.Handle(w, r) {
				return
			}

			access, e := jwt.GenerateAccessToken(user.Id, now)
			if e.Handle(w, r) {
				return
			}

			http.SetCookie(w, &http.Cookie{
				Name:     "access_token",
				Value:    access,
				HttpOnly: true,
				Path:     "/",
				Expires:  now.Add(time.Duration(config.JwtAccExpTime)),
			})
		}

		next(w, r)
	}
}

// -
//
//	This middleware is responsible for making sure that the request sent to a certain endpoint has a valid HTTP method.
//
//	Methods: (The one specified in the argument)
//
//	Possible Responses:
//		405 (Method Not Allowed): When the request is of an unaccepted method
func Method(method string, next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != method {
			w.WriteHeader(http.StatusMethodNotAllowed)
			return
		}

		next(w, r)
	}
}

func getRefAccFromRequest(r *http.Request) (string, string, *errhandle.Error) {
	access, err := r.Cookie("access_token")
	if err == http.ErrNoCookie {
		return "", "", &errhandle.Error{
			Type:          errhandle.JwtError,
			ServerMessage: "no access_token cookie present",
			ClientMessage: "There was no authentication medium present in the request.",
			Status:        http.StatusUnauthorized,
		}
	} else if err != nil {
		return "", "", &errhandle.Error{
			Type:          errhandle.JwtError,
			ServerMessage: fmt.Sprintf("while trying to retrieve the access_token cookie -> %v", err),
			ClientMessage: "An error has occurred while processing your request.",
			Status:        http.StatusInternalServerError,
		}
	}

	refresh, err := r.Cookie("refresh_token")
	if err == http.ErrNoCookie {
		return "", "", &errhandle.Error{
			Type:          errhandle.JwtError,
			ServerMessage: "no refresh_token cookie present",
			ClientMessage: "There was no authentication medium present in the request.",
			Status:        http.StatusUnauthorized,
		}
	} else if err != nil {
		return "", "", &errhandle.Error{
			Type:          errhandle.JwtError,
			ServerMessage: fmt.Sprintf("while trying to retrieve the refresh_token cookie -> %v", err),
			ClientMessage: "An error has occurred while processing your request.",
			Status:        http.StatusInternalServerError,
		}
	}

	return access.Value, refresh.Value, nil
}
