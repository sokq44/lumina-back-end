package middleware

import (
	"backend/config"
	"backend/handlers"
	"backend/utils/database"
	"backend/utils/errhandle"
	"backend/utils/jwt"
	"log"
	"net/http"
	"time"
)

func CORS(next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		origin := r.Header.Get("Origin")
		if origin != "" {
			w.Header().Set("Access-Control-Allow-Origin", origin)
		}
		w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PATCH, PUT, DELETE, OPTIONS")
		w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
		w.Header().Set("Access-Control-Allow-Credentials", "true")

		if r.Method == "OPTIONS" {
			w.WriteHeader(http.StatusOK)
			return
		}

		next.ServeHTTP(w, r)
	}
}

func Authenticate(next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		db := database.GetDb()
		now := time.Now()

		accessToken, refreshToken, e := handlers.GetRefAccFromRequest(r)
		if e.Handle(w, r) {
			return
		}

		secrets, err := db.GetLatestSecrets()
		if err.Handle(w, r) {
			return
		}

		if !jwt.WasGeneratedWithSecret(refreshToken, secrets[0].Secret) ||
			!jwt.WasGeneratedWithSecret(refreshToken, secrets[1].Secret) ||
			(accessToken != "" && !jwt.WasGeneratedWithSecret(accessToken, secrets[0].Secret)) ||
			(accessToken != "" && !jwt.WasGeneratedWithSecret(accessToken, secrets[1].Secret)) {
			e := errhandle.Error{
				Type:          errhandle.JwtError,
				ServerMessage: "one of the tokens or both weren't created with the server secret",
				ClientMessage: "Your authentication medium wasn't generated by this server.",
				Status:        http.StatusUnauthorized,
			}
			e.Handle(w, r)
			return
		}

		claimsRefresh, e := jwt.DecodePayload(refreshToken)
		if e.Handle(w, r) {
			return
		}

		userId := claimsRefresh["user"].(string)
		tk, e := db.GetRefreshTokenByUserId(userId)
		if e.Handle(w, r) {
			return
		}

		expiresRefresh := int64(claimsRefresh["exp"].(float64))
		if expiresRefresh < now.Unix() || now.After(tk.Expires) {
			e := db.DeleteRefreshTokenByToken(refreshToken)
			if e.Handle(w, r) {
				return
			}

			http.SetCookie(w, &http.Cookie{
				Name:     "refresh_token",
				Value:    "",
				HttpOnly: true,
				Path:     "/",
				Expires:  time.Unix(0, 0),
				Secure:   true,
				SameSite: http.SameSiteNoneMode,
			})

			http.SetCookie(w, &http.Cookie{
				Name:     "access_token",
				Value:    "",
				HttpOnly: true,
				Path:     "/",
				Expires:  time.Unix(0, 0),
				Secure:   true,
				SameSite: http.SameSiteNoneMode,
			})

			e = &errhandle.Error{
				Type:          errhandle.JwtError,
				ServerMessage: "refresh token has expired",
				ClientMessage: "Your authentication medium has expired.",
				Status:        http.StatusUnauthorized,
			}
			if e.Handle(w, r) {
				return
			}
		}

		if tk.UserId != userId {
			e = &errhandle.Error{
				Type:          errhandle.JwtError,
				ServerMessage: "refresh token doesn't belong to the user",
				ClientMessage: "Your authentication medium doesn't belong to you.",
				Status:        http.StatusUnauthorized,
			}
			if e.Handle(w, r) {
				return
			}
		}

		if accessToken == "" {
			log.Println("debugging: access token has expired")
			user, e := db.GetUserById(userId)
			if e.Handle(w, r) {
				return
			}

			access, e := jwt.GenerateAccessToken(user.Id, now)
			if e.Handle(w, r) {
				return
			}

			http.SetCookie(w, &http.Cookie{
				Name:     "access_token",
				Value:    access,
				HttpOnly: true,
				Path:     "/",
				Expires:  now.Add(time.Duration(config.JwtAccExpTime)),
			})
		}

		next(w, r)
	}
}

func Method(method string, next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != method {
			w.WriteHeader(http.StatusMethodNotAllowed)
			return
		}

		next(w, r)
	}
}
