package middleware

import (
	"backend/config"
	"backend/utils/database"
	"backend/utils/errhandle"
	"backend/utils/jwt"
	"errors"
	"fmt"
	"net/http"
	"time"
)

func CORS(next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		origin := r.Header.Get("Origin")
		if origin != "" {
			w.Header().Set("Access-Control-Allow-Origin", origin)
		}
		w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PATCH, PUT, DELETE, OPTIONS")
		w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
		w.Header().Set("Access-Control-Allow-Credentials", "true")

		if r.Method == "OPTIONS" {
			w.WriteHeader(http.StatusOK)
			return
		}

		next.ServeHTTP(w, r)
	}
}

func Authenticate(next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		db := database.GetDb()
		now := time.Now()

		accessToken, refreshToken, e := getRefAccFromRequest(r)
		if e.Handle(w, r) {
			return
		}

		secrets, err := db.GetLatestSecrets()
		if err.Handle(w, r) {
			return
		}

		if !jwt.WasGeneratedWithSecret(refreshToken, secrets[0].Secret) ||
			!jwt.WasGeneratedWithSecret(accessToken, secrets[0].Secret) ||
			!jwt.WasGeneratedWithSecret(refreshToken, secrets[1].Secret) ||
			!jwt.WasGeneratedWithSecret(accessToken, secrets[1].Secret) {
			e := errhandle.Error{
				Type:          errhandle.JwtError,
				ServerMessage: "one of the tokens or both weren't created with the server secret",
				ClientMessage: "Your authentication medium wasn't generated by this server.",
				Status:        http.StatusUnauthorized,
			}
			e.Handle(w, r)
			return
		}

		claimsRefresh, e := jwt.DecodePayload(refreshToken)
		if e.Handle(w, r) {
			return
		}

		claimsAccess, e := jwt.DecodePayload(accessToken)
		if e.Handle(w, r) {
			return
		}

		refreshTokenDb, e := db.GetRefreshTokenByUserId(claimsRefresh["user"].(string))
		if e.Handle(w, r) {
			return
		}

		expiresRefresh := int64(claimsRefresh["exp"].(float64))
		if expiresRefresh < now.Unix() || now.After(refreshTokenDb.Expires) {
			e := db.DeleteRefreshTokenByToken(refreshToken)
			if e.Handle(w, r) {
				return
			}

			http.SetCookie(w, &http.Cookie{
				Name:     "refresh_token",
				Value:    "",
				HttpOnly: true,
				Path:     "/",
				Expires:  time.Unix(0, 0),
				Secure:   true,
				SameSite: http.SameSiteNoneMode,
			})

			http.SetCookie(w, &http.Cookie{
				Name:     "access_token",
				Value:    "",
				HttpOnly: true,
				Path:     "/",
				Expires:  time.Unix(0, 0),
				Secure:   true,
				SameSite: http.SameSiteNoneMode,
			})

			e = &errhandle.Error{
				Type:          errhandle.JwtError,
				ServerMessage: "refresh token has expired",
				ClientMessage: "Your authentication medium has expired.",
				Status:        http.StatusUnauthorized,
			}
			if e.Handle(w, r) {
				return
			}
		}

		userId := claimsRefresh["user"].(string)
		tk, e := db.GetRefreshTokenByUserId(userId)
		if e.Handle(w, r) {
			return
		}

		if tk.UserId != userId {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		
		expiresAccess := int64(claimsAccess["exp"].(float64))
		if expiresAccess < now.Unix() {
			user, e := db.GetUserById(claimsAccess["user"].(string))
			if e.Handle(w, r) {
				return
			}

			access, e := jwt.GenerateAccessToken(user.Id, now)
			if e.Handle(w, r) {
				return
			}

			http.SetCookie(w, &http.Cookie{
				Name:     "access_token",
				Value:    access,
				HttpOnly: true,
				Path:     "/",
				Expires:  now.Add(time.Duration(config.JwtAccExpTime)),
			})
		}

		next(w, r)
	}
}

func Method(method string, next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != method {
			w.WriteHeader(http.StatusMethodNotAllowed)
			return
		}

		next(w, r)
	}
}

func getRefAccFromRequest(r *http.Request) (string, string, *errhandle.Error) {
	access, err := r.Cookie("access_token")
	if errors.Is(err, http.ErrNoCookie) {
		return "", "", &errhandle.Error{
			Type:          errhandle.JwtError,
			ServerMessage: "no access_token cookie present",
			ClientMessage: "There was no authentication medium present in the request.",
			Status:        http.StatusUnauthorized,
		}
	} else if err != nil {
		return "", "", &errhandle.Error{
			Type:          errhandle.JwtError,
			ServerMessage: fmt.Sprintf("while trying to retrieve the access_token cookie -> %v", err),
			ClientMessage: "An error has occurred while processing your request.",
			Status:        http.StatusInternalServerError,
		}
	}

	refresh, err := r.Cookie("refresh_token")
	if errors.Is(err, http.ErrNoCookie) {
		return "", "", &errhandle.Error{
			Type:          errhandle.JwtError,
			ServerMessage: "no refresh_token cookie present",
			ClientMessage: "There was no authentication medium present in the request.",
			Status:        http.StatusUnauthorized,
		}
	} else if err != nil {
		return "", "", &errhandle.Error{
			Type:          errhandle.JwtError,
			ServerMessage: fmt.Sprintf("while trying to retrieve the refresh_token cookie -> %v", err),
			ClientMessage: "An error has occurred while processing your request.",
			Status:        http.StatusInternalServerError,
		}
	}

	return access.Value, refresh.Value, nil
}
